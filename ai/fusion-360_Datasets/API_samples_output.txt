Delete Empty Components
Description
Deletes empty components from the active design.
Code Samples
Python
Copy Code
#Author-Autodesk Inc.
#Description-Delete empty components from an assembly.
import adsk, adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
app = adsk.core.Application.get()
ui = app.userInterface        # Get all components in the active design.
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        title = 'Delete Empty Components'
        if not design:
            ui.messageBox('No active Fusion design', title)
            return
        components = design.allComponents
        # Find all of the empty components.
        # It is empty if it has no occurrences, bodies, featres, sketches, or construction.
        root = design.rootComponent
        componentsToDelete = []
        for component in components:
            # Skip the root component.
            if root == component:
                continue
            if component.occurrences.count == 0 \
                and component.bRepBodies.count == 0 \
                and component.features.count == 0 \
                and component.sketches.count == 0 \
                and component.constructionPlanes.count == 0 \
                and component.constructionAxes.count == 0 \
                and component.constructionPoints.count == 0:
                componentsToDelete.append(component)
        # Delete all immediate occurrences of the empty components.
        deletedComponents = []
        for component in componentsToDelete:
            # Get the name first because deleting the final Occurrence will delete the Component.
            name = component.name
            # Build a list of unique immediate occurrences of the component.
            occurrences = root.allOccurrencesByComponent(component)
            uniqueOccurrences = []
            for occurrence in occurrences:
                index = 0
                for k in range(0, len(uniqueOccurrences)):
                    if occurrence is uniqueOccurrences[k]:
                        break
                    index = k+1
                if index == len(uniqueOccurrences):
                    uniqueOccurrences.append(occurrence)
            # Delete them.
            for uniqueOccurrencesI in uniqueOccurrences:
                uniqueOccurrencesI.deleteMe()
            deletedComponents.append(name)
        if len(deletedComponents) == 0:
            msg = 'No empty components found.'
        else:
            if len(deletedComponents) > 1:
                msg = str(len(deletedComponents)) + ' empty component' + 's'
            else:
                msg = str(len(deletedComponents)) + ' empty component' + ' deleted'
            msg += '\n\n'
            for deletedComponentI in deletedComponents:
                msg += '\n' + deletedComponentI
        ui.messageBox(msg, title)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Assembly traversal using r ecursion API Sample
Description
Traverses the entire structure of the currently open assemlby using a recursive function and displays the result in a message box. This will match the occurrence structure seen in the
browser .
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
# Performs a recursive traversal of an entire assembly structure.
def traverseAssembly(occurrences, currentLevel, inputString):
    for i in range(0, occurrences.count):
        occ = occurrences.item(i)
        inputString += spaces(currentLevel * 5) + occ.name + '\n'
        
        if occ.childOccurrences:            inputString = traverseAssembly(occ.childOccurrences, currentLevel + 1, inputString)
    return inputString
# Returns a string containing the especified number of spaces.
def spaces(spaceCount):
    result = ''
    for i in range(0, spaceCount):
        result += ' '
    return result
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        if not design:
            ui.messageBox('No active Fusion design', 'No Design')
            return
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create the title for the output.
        resultString = 'Root (' + design.parentDocument.name + ')\n'
        
        # Call the recursive function to traverse the assembly and build the output string.
        resultString = traverseAssembly(rootComp.occurrences.asList, 1, resultString)
        # Display the result.
        # Write the results to the TEXT COMMANDS window.
        textPalette = ui.palettes.itemById('TextCommands')
        if not textPalette.isVisible:
            textPalette.isVisible = True
        textPalette.writeText(resultString)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

As-Built Joint Sample
Description
Demonstrates creating a new As-Built Joint.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create two new components under root component
        allOccs = rootComp.occurrences
        transform = adsk.core.Matrix3D.create()
        subOcc0 = allOccs.addNewComponent(transform)
        # Create sketch 1 in sub component 1
        subComp0 = subOcc0.component
        sketches0 = subComp0.sketches
        sketch0 = sketches0.add(subComp0.xZConstructionPlane)
        sketchCircles0 = sketch0.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles0.addByCenterRadius(centerPoint, 2.5)
        # Get the profile defined by the circle
        prof0 = sketch0.profiles.item(0)
        # Create an extrude input and make sure it's in the new component        extrudes0 = subComp0.features.extrudeFeatures
        extInput0 = extrudes0.createInput(prof0, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Set the extrude input
        distance0 = adsk.core.ValueInput.createByString("5 mm")
        extInput0.setDistanceExtent(False, distance0)
        extInput0.isSolid = True
        # Create the extrude
        extrude0 = extrudes0.add(extInput0)
        # Get the end face of the created extrude
        endFaceOfExtrude0 = extrude0.endFaces.item(0)
        # Create a construction plane for extrude 2
        constructionPlanes_ = subComp0.constructionPlanes
        constructionPlaneInput = constructionPlanes_.createInput()
        constructionPlaneInput.setByOffset(endFaceOfExtrude0, adsk.core.ValueInput.createByString("20 mm"))
        constructionPlane = constructionPlanes_.add(constructionPlaneInput)
        constructionPlaneProxy = constructionPlane.createForAssemblyContext(subOcc0)
        # Create sketch 2 in sub component 2
        subOcc1 = allOccs.addNewComponent(transform)
        subComp1 = subOcc1.component
        sketches1 = subComp1.sketches
        sketch1 = sketches1.add(constructionPlaneProxy)
        sketchCircles1 = sketch1.sketchCurves.sketchCircles
        sketchCircles1.addByCenterRadius(centerPoint, 0.5)
        # Get the profile defined by the circle
        prof1 = sketch1.profiles.item(0)
        # Create an extrude input and make sure it's in the new component
        extrudes1 = subComp1.features.extrudeFeatures
        extInput1 = extrudes1.createInput(prof1, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Set the extrude input
        distance1 = adsk.core.ValueInput.createByString("50 mm")
        extInput1.setDistanceExtent(False, distance1)
        extInput1.isSolid = False
        # Create the extrude
        extrudes1.add(extInput1)
        # Create the AsBuiltJointInput
        asBuiltJoints_ = rootComp.asBuiltJoints
        asBuiltJointInput = asBuiltJoints_.createInput(subOcc0, subOcc1, None)
        # Create the AsBuiltJoint
        asBuiltJoints_.add(asBuiltJointInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

BallJointMotion API Sample
Description
Demonstrates creating a joint with ball joint motion
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create sketch in root component
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchPts = sketch.sketchPoints
        point = adsk.core.Point3D.create(1, 0, 1)
        sketchPt = sketchPts.add(point)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 5.0)
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input and make sure it's in a new component
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
        # Set the extrusion input
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        extInput.isSolid = True
        # Create the extrusion
        ext = extrudes.add(extInput)
        # Get the end face of the created extrusion body
        endFace = ext.endFaces.item(0)
        # Get the occurrence of the new component
        occ = rootComp.occurrences.item(0)
        # Create a new sketch in the occurrence
        sketchInOcc = sketches.add(endFace, occ)
        # Get the sketch curve projected to the sketch
        curve = sketchInOcc.sketchCurves.item(0)
        # Create the first joint geometry with the sketch curve
        geo0 = adsk.fusion.JointGeometry.createByCurve(curve, adsk.fusion.JointKeyPointTypes.CenterKeyPoint)
        # Create the second joint geometry with sketch point
        geo1 = adsk.fusion.JointGeometry.createByPoint(sketchPt)
        # Create joint input
        joints = rootComp.joints
        jointInput = joints.createInput(geo0, geo1)
        # Set the joint input
        jointInput.setAsBallJointMotion(adsk.fusion.JointDirections.ZAxisJointDirection, adsk.fusion.JointDirections.XAxisJointDirection)
        # Create the joint
        joint = joints.add(jointInput)
        ballMotion = joint.jointMotion
        limits = ballMotion.pitchLimits
        limits.isRestValueEnabled = True
        limits.restValue = 1.0
    except:        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

CylindricalJointMotion API Sample
Description
Demonstrates creating a joint with cylindrical joint motion.
Code Samples
Python
C++
--
#Author-
#Description-
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create sketch in root component
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchPts = sketch.sketchPoints
        point = adsk.core.Point3D.create(1, 0, 1)
        sketchPt = sketchPts.add(point)
        sketchLines = sketch.sketchCurves.sketchLines
        point1 = adsk.core.Point3D.create(1, 0, 2)
        point2 = adsk.core.Point3D.create(2, 0, 1)
        point1SketchSpace = sketch.modelToSketchSpace(point1)
        point2SketchSpace = sketch.modelToSketchSpace(point2)
        lines = sketchLines.addTwoPointRectangle(point1SketchSpace, point2SketchSpace)
        
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input and make sure it's in a new component
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
        
        # Set the extrusion input
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        extInput.isSolid = True
        # Create the extrusion
        ext = extrudes.add(extInput)
        
        # Get the end face of the created extrusion body
        endFace = ext.endFaces.item(0)
        
        # Get the occurrence of the new component
        occ = rootComp.occurrences.item(0)
        
        # Create a new sketch in the occurrence
        sketchInOcc = sketches.add(endFace, occ)
        
        # Get the sketch curve projected to the sketch
        curve = sketchInOcc.sketchCurves.item(0)
        
        # Create the first joint geometry with the sketch curve
        geo0 = adsk.fusion.JointGeometry.createByCurve(curve, adsk.fusion.JointKeyPointTypes.StartKeyPoint)
        
        # Create the second joint geometry with sketch point
        geo1 = adsk.fusion.JointGeometry.createByPoint(sketchPt)
        
        # Create joint input
        joints = rootComp.joints
        jointInput = joints.createInput(geo0, geo1)        
        # Set the joint input
        jointInput.setAsCylindricalJointMotion(adsk.fusion.JointDirections.CustomJointDirection, curve.createForAssemblyContext(occ))
        
        # Create the joint
        joint = joints.add(jointInput)
        cylindricalMotion = joint.jointMotion
        rotLimits = cylindricalMotion.rotationLimits
        rotLimits.isRestValueEnabled = True
        rotLimits.restValue = 3.14 / 3
        slideLimits = cylindricalMotion.slideLimits
        slideLimits.isMinimumValueEnabled = True
        slideLimits.minimumValue = 0.1
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Joint Origin Between Two Faces Sample
Description
Demonstrates creating a new Joint Origin between two planes.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create a sub component under root component
        allOccs = rootComp.occurrences
        transform = adsk.core.Matrix3D.create()
        subOcc = allOccs.addNewComponent(transform)
        # Create an extrude in the sub component
        subComp = subOcc.component
        sketches = subComp.sketches
        sketch = sketches.add(subComp.xZConstructionPlane)
        sketchLines = sketch.sketchCurves.sketchLines
        sketchLines.addTwoPointRectangle(adsk.core.Point3D.create(0, 0, 0), adsk.core.Point3D.create(10, 10, 0))        profile = sketch.profiles.item(0)
        extrudes = subComp.features.extrudeFeatures
        extInput = extrudes.createInput(profile, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        distance = adsk.core.ValueInput.createByString("50 mm")
        extInput.setDistanceExtent(False, distance)
        extInput.isSolid = True
        extrude = extrudes.add(extInput)
        faces = extrude.faces
        # Create the joint geometry
        jointGeometry = adsk.fusion.JointGeometry.createByBetweenTwoPlanes(faces.item(0), faces.item(1), faces.item(0), None, adsk.fusion.JointKeyPointTypes.CenterKeyPoint
        # Create the JointOriginInput
        jointOrigins = subComp.jointOrigins
        jointOriginInput = jointOrigins.createInput(jointGeometry)
        # Create the JointOrigin
        jointOrigins.add(jointOriginInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Joint Origin Sample
Description
Demonstrates creating a new Joint Origin.Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create a sub component under root component
        allOccs = rootComp.occurrences
        transform = adsk.core.Matrix3D.create()
        subOcc = allOccs.addNewComponent(transform)
        # Create an extrude in the sub component
        subComp = subOcc.component
        sketches = subComp.sketches
        sketch = sketches.add(subComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 2.5)
        profile = sketch.profiles.item(0)
        extrudes = subComp.features.extrudeFeatures
        extInput = extrudes.createInput(profile, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        distance = adsk.core.ValueInput.createByString("50 mm")
        extInput.setDistanceExtent(False, distance)
        extInput.isSolid = True
        extrude = extrudes.add(extInput)
        endFaceOfExtrude = extrude.endFaces.item(0)
        # Create the joint geometry
        jointGeometry = adsk.fusion.JointGeometry.createByPlanarFace(endFaceOfExtrude, None, adsk.fusion.JointKeyPointTypes.CenterKeyPoint)
        # Create the JointOriginInput
        jointOrigins_ = subComp.jointOrigins
        jointOriginInput = jointOrigins_.createInput(jointGeometry)
        # Create the JointOrigin
        jointOrigins_.add(jointOriginInput)
        camera_ = app.activeViewport.camera
        camera_.isFitView = True
        app.activeViewport.camera = camera_
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Joint API Sample
Description
Demonstrates creating a new joint.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create sketch in root component
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        sketchLines = sketch.sketchCurves.sketchLines
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 5.0)
        point0 = adsk.core.Point3D.create(0, 10, 0)
        point1 = adsk.core.Point3D.create(10, 10, 0)
        line = sketchLines.addByTwoPoints(point0, point1)
        
        # Get the profile defined by the circle        prof = sketch.profiles.item(0)
        # Create an extrusion input and make sure it's in a new component
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
        
        # Set the extrusion input
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        extInput.isSolid = True
        # Create the extrusion
        ext = extrudes.add(extInput)
        
        # Get the end face of the created extrusion body
        endFace = ext.endFaces.item(0)
        
        # Create the first joint geometry with the end face
        geo0 = adsk.fusion.JointGeometry.createByPlanarFace(endFace, None, adsk.fusion.JointKeyPointTypes.CenterKeyPoint)
        
        # Create the second joint geometry with the sketch line
        geo1 = adsk.fusion.JointGeometry.createByCurve(line, adsk.fusion.JointKeyPointTypes.EndKeyPoint)
        
        # Create joint input
        joints = rootComp.joints
        jointInput = joints.createInput(geo0, geo1)
        
        # Set the joint input
        angle = adsk.core.ValueInput.createByString('90 deg')
        jointInput.angle = angle
        offset = adsk.core.ValueInput.createByString('1 cm')
        jointInput.offset = offset
        jointInput.isFlipped = True
        jointInput.setAsRevoluteJointMotion(adsk.fusion.JointDirections.ZAxisJointDirection)
        
        # Create the joint
        joint = joints.add(jointInput)
        # Lock the joint
        joint.isLocked = True
        
        # Get health state of a joint
        health = joint.healthState
        if health == adsk.fusion.FeatureHealthStates.ErrorFeatureHealthState or health == adsk.fusion.FeatureHealthStates.WarningFeatureHealthState:
            message = joint.errorOrWarningMessage
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Pin Slot Joint Motion API Sample
Description
Demonstrates creating a joint with pin slot joint motion
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create sketch in root component
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchPts = sketch.sketchPoints
        point = adsk.core.Point3D.create(1, 0, 1)
        sketchPt = sketchPts.add(point)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 5.0)
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input and make sure it's in a new component
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)        # Set the extrusion input
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        extInput.isSolid = True
        # Create the extrusion
        ext = extrudes.add(extInput)
        # Get the end face of the created extrusion body
        endFace = ext.endFaces.item(0)
        # Get the occurrence of the new component
        occ = rootComp.occurrences.item(0)
        # Create a new sketch in the occurrence
        sketchInOcc = sketches.add(endFace, occ)
        # Get the sketch curve projected to the sketch
        curve = sketchInOcc.sketchCurves.item(0)
        # Create the first joint geometry with the sketch curve
        geo0 = adsk.fusion.JointGeometry.createByCurve(curve, adsk.fusion.JointKeyPointTypes.CenterKeyPoint)
        # Create the second joint geometry with sketch point
        geo1 = adsk.fusion.JointGeometry.createByPoint(sketchPt)
        # Create joint input
        joints = rootComp.joints
        jointInput = joints.createInput(geo0, geo1)
        # Set the joint input
        jointInput.setAsPinSlotJointMotion(adsk.fusion.JointDirections.ZAxisJointDirection, adsk.fusion.JointDirections.XAxisJointDirection)
        # Create the joint
        joint = joints.add(jointInput)
        pinSlotMotion = joint.jointMotion
        limits = pinSlotMotion.rotationLimits
        limits.isRestValueEnabled = True
        limits.restValue = 1.0
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Planar  Joint Motion API Sample
Description
Demonstrates creating a joint with planar joint motion
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create sketch in root component
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchPts = sketch.sketchPoints
        point = adsk.core.Point3D.create(1, 0, 1)
        sketchPt = sketchPts.add(point)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 5.0)        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input and make sure it's in a new component
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
        # Set the extrusion input
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        extInput.isSolid = True
        # Create the extrusion
        ext = extrudes.add(extInput)
        # Get the end face of the created extrusion body
        endFace = ext.endFaces.item(0)
        # Get the occurrence of the new component
        occ = rootComp.occurrences.item(0)
        # Create a new sketch in the occurrence
        sketchInOcc = sketches.add(endFace, occ)
        # Get the sketch curve projected to the sketch
        curve = sketchInOcc.sketchCurves.item(0)
        # Create the first joint geometry with the sketch curve
        geo0 = adsk.fusion.JointGeometry.createByCurve(curve, adsk.fusion.JointKeyPointTypes.CenterKeyPoint)
        # Create the second joint geometry with sketch point
        geo1 = adsk.fusion.JointGeometry.createByPoint(sketchPt)
        # Create joint input
        joints = rootComp.joints
        jointInput = joints.createInput(geo0, geo1)
        # Set the joint input
        jointInput.setAsPlanarJointMotion(adsk.fusion.JointDirections.YAxisJointDirection)
        # Create the joint
        joint = joints.add(jointInput)
        planarMotion = joint.jointMotion
        limits = planarMotion.rotationLimits
        limits.isRestValueEnabled = True
        limits.restValue = 1.0
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

RevoluteJointMotion API Sample
Description
Demonstrates creating a joint with revolute joint motion.
Code Samples
Python
C++
--
#Author-
#Description-
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create sketch in root component        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint0 = adsk.core.Point3D.create(0, 0, 0)
        circle0 = sketchCircles.addByCenterRadius(centerPoint0, 5.0)
        centerPoint1 = adsk.core.Point3D.create(10, 10, 0)
        circle1 = sketchCircles.addByCenterRadius(centerPoint1, 5.0)
        
        # Get the profile defined by the circle
        prof0 = sketch.profiles.item(0)
        prof1 = sketch.profiles.item(1)
        # Create an extrusion input and make sure it's in a new component
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof0, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
        
        # Set the extrusion input
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        extInput.isSolid = True
        # Create the extrusion
        ext = extrudes.add(extInput)
        
        # Get the side face of the created extrusion body
        sideFace = ext.sideFaces.item(0)
        
        # Create the first joint geometry with the side face
        geo0 = adsk.fusion.JointGeometry.createByNonPlanarFace(sideFace, adsk.fusion.JointKeyPointTypes.StartKeyPoint)
        
        # Create the second joint geometry with prof1
        geo1 = adsk.fusion.JointGeometry.createByProfile(prof1, circle1, adsk.fusion.JointKeyPointTypes.CenterKeyPoint)
        
        # Create joint input
        joints = rootComp.joints
        jointInput = joints.createInput(geo0, geo1)
        
        # Set the joint input
        angle = adsk.core.ValueInput.createByString('90 deg')
        jointInput.angle = angle
        offset = adsk.core.ValueInput.createByString('1 cm')
        jointInput.offset = offset
        jointInput.isFlipped = True
        jointInput.setAsRevoluteJointMotion(adsk.fusion.JointDirections.YAxisJointDirection)
        
        # Create the joint
        joint = joints.add(jointInput)
        revoluteMotion = joint.jointMotion
        limits = revoluteMotion.rotationLimits
        limits.isMinimumValueEnabled = True
        limits.minimumValue = 3.14 / 3
        limits.isMaximumValueEnabled = True
        limits.maximumValue = 3.14 / 3 * 2
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Rigid Gr oup API Sample
Description
Demonstrates creating a new Rigid Group.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create four sub components under root component
        allOccs = rootComp.occurrences
        transform0 = adsk.core.Matrix3D.create()
        vector3d0 = adsk.core.Vector3D.create(10.0, 0.0, 0.0)
        transform0.translation = vector3d0
        subOcc0 = allOccs.addNewComponent(transform0)
        transform1 = adsk.core.Matrix3D.create()
        vector3d1 = adsk.core.Vector3D.create(0.0, 0.0, 12.0)        transform1.translation = vector3d1
        subOcc1 = allOccs.addNewComponent(transform1)
        transform2 = adsk.core.Matrix3D.create()
        vector3d2 = adsk.core.Vector3D.create(-8.0, 0.0, 0.0)
        transform2.translation = vector3d2
        subOcc2 = allOccs.addNewComponent(transform2)
        transform3 = adsk.core.Matrix3D.create()
        vector3d3 = adsk.core.Vector3D.create(0.0, 0.0, -6.0)
        transform3.translation = vector3d3
        subOcc3 = allOccs.addNewComponent(transform3)
        # Create cylinder 1 in sub component 1
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        subComp0 = subOcc0.component
        sketches0 = subComp0.sketches
        sketch0 = sketches0.add(subComp0.xZConstructionPlane)
        sketchCircles0 = sketch0.sketchCurves.sketchCircles
        sketchCircles0.addByCenterRadius(centerPoint, 0.5)
        profile0 = sketch0.profiles.item(0)
        extrudes0 = subComp0.features.extrudeFeatures
        extInput0 = extrudes0.createInput(profile0, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        distance0 = adsk.core.ValueInput.createByString("50 mm")
        extInput0.setDistanceExtent(False, distance0)
        extInput0.isSolid = False
        extrudes0.add(extInput0)
        # Create cylinder 2 in sub component 2
        subComp1 = subOcc1.component
        sketches1 = subComp1.sketches
        sketch1 = sketches1.add(subComp1.xZConstructionPlane)
        sketchCircles1 = sketch1.sketchCurves.sketchCircles
        sketchCircles1.addByCenterRadius(centerPoint, 0.75)
        profile1 = sketch1.profiles.item(0)
        extrudes1 = subComp1.features.extrudeFeatures
        extInput1 = extrudes1.createInput(profile1, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        distance1 = adsk.core.ValueInput.createByString("75 mm")
        extInput1.setDistanceExtent(False, distance1)
        extInput1.isSolid = False
        extrudes1.add(extInput1)
        # Create cylinder 3 in sub component 3
        subComp2 = subOcc2.component
        sketches2 = subComp2.sketches
        sketch2 = sketches2.add(subComp2.xZConstructionPlane)
        sketchCircles2 = sketch2.sketchCurves.sketchCircles
        sketchCircles2.addByCenterRadius(centerPoint, 1.0)
        profile2 = sketch2.profiles.item(0)
        extrudes2 = subComp2.features.extrudeFeatures
        extInput2 = extrudes2.createInput(profile2, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        distance2 = adsk.core.ValueInput.createByString("100 mm")
        extInput2.setDistanceExtent(False, distance2)
        extInput2.isSolid = False
        extrudes2.add(extInput2)
        # Create cylinder 4 in sub component 4
        subComp3 = subOcc3.component
        sketches3 = subComp3.sketches
        sketch3 = sketches3.add(subComp3.xZConstructionPlane)
        sketchCircles3 = sketch3.sketchCurves.sketchCircles
        sketchCircles3.addByCenterRadius(centerPoint, 1.25)
        profile3 = sketch3.profiles.item(0)
        extrudes3 = subComp3.features.extrudeFeatures
        extInput3 = extrudes3.createInput(profile3, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        distance3 = adsk.core.ValueInput.createByString("125 mm")
        extInput3.setDistanceExtent(False, distance3)
        extInput3.isSolid = False
        extrudes3.add(extInput3)
        # Create object collection
        occs = adsk.core.ObjectCollection.create()
        occs.add(subOcc0)
        occs.add(subOcc1)
        occs.add(subOcc2)
        occs.add(subOcc3)
        # Create a Rigid group
        isIncludeChildren = True
        rigidGroups_ = rootComp.rigidGroups
        rigidGroups_.add(occs, isIncludeChildren)
        camera_ = app.activeViewport.camera
        camera_.isFitView = True
        app.activeViewport.camera = camera_
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

SliderJointMotion API Sample
Description
Demonstrates creating a joint with slider joint motion.
Code Samples
Python
C++
--
#Author-
#Description-
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create sketch in root component
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchPts = sketch.sketchPoints
        point = adsk.core.Point3D.create(1, 0, 1)
        sketchPt = sketchPts.add(point)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 5.0)
        
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input and make sure it's in a new component
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
        
        # Set the extrusion input
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        extInput.isSolid = True
        # Create the extrusion
        ext = extrudes.add(extInput)
                # Get the end face of the created extrusion body
        endFace = ext.endFaces.item(0)
        
        # Get the occurrence of the new component
        occ = rootComp.occurrences.item(0)
        
        # Create a new sketch in the occurrence
        sketchInOcc = sketches.add(endFace, occ)
        
        # Get the sketch curve projected to the sketch
        curve = sketchInOcc.sketchCurves.item(0)
        
        # Create the first joint geometry with the sketch curve
        geo0 = adsk.fusion.JointGeometry.createByCurve(curve, adsk.fusion.JointKeyPointTypes.CenterKeyPoint)
        
        # Create the second joint geometry with sketch point
        geo1 = adsk.fusion.JointGeometry.createByPoint(sketchPt)
        
        # Create joint input
        joints = rootComp.joints
        jointInput = joints.createInput(geo0, geo1)
        
        # Set the joint input
        jointInput.setAsSliderJointMotion(adsk.fusion.JointDirections.ZAxisJointDirection)
        
        # Create the joint
        joint = joints.add(jointInput)
        sliderMotion = joint.jointMotion
        limits = sliderMotion.slideLimits
        limits.isRestValueEnabled = True
        limits.restValue = 1.0
        
        # Create ContactSets
        mat = adsk.core.Matrix3D.create()
        mat.translation = adsk.core.Vector3D.create(0, 10, 0)
        rootComp.occurrences.addExistingComponent(ext.parentComponent, mat)
        
        design.isContactAnalysisEnabled = True
        design.isContactSetAnalysis = True
        
        contacts = design.contactSets
        occurrencesAndBodies = []
        occurrencesAndBodies.append(rootComp.occurrences[0])
        occurrencesAndBodies.append(rootComp.occurrences[1])
        
        contacts.add(occurrencesAndBodies)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Get Physical Pr operties API Sample
Description
Script that demonstrates getting physical properties using the API. When this script is run it will create a new document, build a simple model, and get the various physical properties from
the model.
Code Samples
Python
C++--
#Author-
#Description-
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
                
        # Create sub occurrence
        occurrences = rootComp.occurrences
        subOcc = occurrences.addNewComponent(adsk.core.Matrix3D.create())
        
        # Get features from sub component
        subComponent = subOcc.component
        features = subComponent.features
        # Create sketch circle on the xz plane.
        sketches = subComponent.sketches
        sketch = sketches.add(subComponent.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 10)
        # Create a collection of entities for extrude
        entities0 = adsk.core.ObjectCollection.create()
        entities0.add(sketch.profiles.item(0))
        # Create a cylinder with ExtrudeFeature using the profile above.
        extrudeFeats = features.extrudeFeatures
        extrudeFeatureInput = extrudeFeats.createInput(entities0, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeFeatureInput.isSolid = True
        extrudeFeatureInput.setDistanceExtent(False, adsk.core.ValueInput.createByReal(2.5))
        extrudeFeature = extrudeFeats.add(extrudeFeatureInput)
        
        # Get physical properties from body
        body = extrudeFeature.bodies[0]
        physicalProperties = body.physicalProperties
        
        # Get physical properties from occurrence
        physicalProperties = subOcc.physicalProperties
        
        # Get physical properties from occurrence (low accuracy)
        physicalProperties = subOcc.getPhysicalProperties(adsk.fusion.CalculationAccuracy.LowCalculationAccuracy);
        
    # Get physical properties from occurrence (medium accuracy)
        physicalProperties = subOcc.getPhysicalProperties(adsk.fusion.CalculationAccuracy.MediumCalculationAccuracy);
    # Get physical properties from occurrence (high accuracy)
        physicalProperties = subOcc.getPhysicalProperties(adsk.fusion.CalculationAccuracy.HighCalculationAccuracy);     
        # Get physical properties from occurrence (very high accuracy)
        physicalProperties = subOcc.getPhysicalProperties(adsk.fusion.CalculationAccuracy.VeryHighCalculationAccuracy);
        
        # Get physical properties from component
        physicalProperties = subComponent.physicalProperties
        
        # Get physical properties from component (low accuracy)
        physicalProperties = subComponent.getPhysicalProperties(adsk.fusion.CalculationAccuracy.LowCalculationAccuracy);
    # Get physical properties from component (medium accuracy)
        physicalProperties = subComponent.getPhysicalProperties(adsk.fusion.CalculationAccuracy.MediumCalculationAccuracy);
        
    # Get physical properties from component (high accuracy)
        physicalProperties = subComponent.getPhysicalProperties(adsk.fusion.CalculationAccuracy.HighCalculationAccuracy);
        
        # Get physical properties from component (very high accuracy)
        physicalProperties = subComponent.getPhysicalProperties(adsk.fusion.CalculationAccuracy.VeryHighCalculationAccuracy);   
        
        # Get data from physical properties
        area = physicalProperties.area
        density = physicalProperties.density
        mass = physicalProperties.mass
        volume = physicalProperties.volume
        
        # Get accuracy from physical properties
        accuracy = physicalProperties.accuracy
        # Get center of mass from physical properties
        cog = physicalProperties.centerOfMass
        # Get principal axes from physical properties
        (retVal, xAxis0, yAxis0, zAxis0) = physicalProperties.getPrincipalAxes()   
        
        # Get the moments of inertia about the principal axes. Unit for returned values is kg/cm^2.
        (retVal,i1,i2,i3) = physicalProperties.getPrincipalMomentsOfInertia()
        # Get the radius of gyration about the principal axes. Unit for returned values is cm.
        (retVal, kx, ky, kz) = physicalProperties.getRadiusOfGyration()
        # Get the rotation from the world coordinate system of the target to the principal coordinate system.
        (retVal, rx, ry, rz) = physicalProperties.getRotationToPrincipal()        # Get the moment of inertia about the world coordinate system.
        (retVal, xx, yy, zz, xy, yz, xz) = physicalProperties.getXYZMomentsOfInertia()
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Get Volume of Active Design API Sample
Description
Traverses through the active design and totals the volume of every body within the design.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        design = app.activeProduct
        if not design:
            ui.messageBox('No active Fusion design', 'No Design')
            return
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Iterate over any bodies in the root component.
        totalVolume = 0
        for j in range(0, rootComp.bRepBodies.count):
            body = rootComp.bRepBodies.item(j)
            # Get the volume of the current body and add it to the total.
            totalVolume += body.volume
        # Iterate through all of the occurrences in the assembly.
        for i in range(0, rootComp.allOccurrences.count):
            occ = rootComp.allOccurrences.item(i)
            
            # Get the associated component.
            comp = occ.component
            
            # Iterate over all of the bodies within the component.
            for j in range(0, comp.bRepBodies.count):
                body = comp.bRepBodies.item(j)
                
                # Get the volume of the current body and add it to the total.
                totalVolume += body.volume
        
        # Format a string to display the volume using the default distance units.
        result = design.unitsManager.formatInternalValue(totalVolume, design.unitsManager.defaultLengthUnits + '^3', True)
        ui.messageBox('The volume of the entire asembly is: ' + result)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Get Cir cle and Arc Data fr om Edge API Sample
Description
Display the arc and circle geometric information from a selected circular edge.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def getArcGeometryInfo(arcGeom):
    result = arcGeom.getData()
    if (result[0]):        (retVal, center, axis, refVector, radius, startAngle, endAngle) = result
                    
        arcInfo = "Center: %.6f, %.6f, %.6f\n" % (center.x, center.y, center.z)
        arcInfo += "Axis: %.6f, %.6f, %.6f\n" % (axis.x, axis.y, axis.z)
        arcInfo += "Reference vector: %.6f, %.6f, %.6f\n" % (refVector.x, refVector.y, refVector.z)
        arcInfo += "Radius: %.6f\n" % radius
        arcInfo += "Start angle: %.6f\n" % startAngle
        arcInfo += "End angle: %.6f" % endAngle
        return arcInfo
        
def getCircleGeometryInfo(circGeom):
    result = circGeom.getData()                
    if (result[0]):
        (retVal, center, axis, radius) = result
        circleInfo = "Center: %.6f, %.6f, %.6f\n" % (center.x, center.y, center.z)
        circleInfo += "Axis: %.6f, %.6f, %.6f\n" % (axis.x, axis.y, axis.z)
        circleInfo += "Radius: %.6f" % radius
        return circleInfo
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        ent = ui.selectEntity("Select a circular edge", "CircularEdges")
        
        if (isinstance(ent.entity.geometry, adsk.core.Arc3D)): 
            arcGeom = ent.entity.geometry
            
            arcInfo = getArcGeometryInfo(arcGeom)
                            
            ui.messageBox(arcInfo, "Arc Info")
        else:  
            if (isinstance(ent.entity.geometry, adsk.core.Circle3D)):
                circGeom = ent.entity.geometry
                
                circleInfo = getCircleGeometryInfo(circGeom)
                
                ui.messageBox( circleInfo, "Circle Info")
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Analyze Interfer ence API Sample
Description
Demonstrates analyzing the interference between components. This uses a direct modeling design because the ability to create bodies that represent the interference volume is only
supported in a direct modeling design.
Code Samples
C++
Python
--

Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a new document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # Set the design type to DirectDesignType (for non-parametric modelling)        
        design.designType = adsk.fusion.DesignTypes.DirectDesignType
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create the first component - containing a box
        occurrences = rootComp.occurrences
        matrix = adsk.core.Matrix3D.create()
        firstComponentOccurrence = occurrences.addNewComponent(matrix)                
        
        # Create sketch
        sketches = firstComponentOccurrence.component.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)        
        
        # Create a rectangle
        sketchLines = sketch.sketchCurves.sketchLines
        startPoint = adsk.core.Point3D.create(0, 0, 0)
        endPoint = adsk.core.Point3D.create(5, 5, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        
        # Get the profile defined by the rectangle
        prof = sketch.profiles.item(0)
        
        # Create an extrusion input for the profile.
        features = firstComponentOccurrence.component.features
        extrudes = features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent of the extrusion is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        
        # Create the extrusion.
        ext = extrudes.add(extInput)
        # Create the second component - containing a box that overlaps the box in the first component
        secondComponentOccurrence = occurrences.addNewComponent(matrix)                
        
        # Create sketch
        sketches = secondComponentOccurrence.component.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)        
        
        # Create a rectangle
        sketchLines = sketch.sketchCurves.sketchLines
        startPoint = adsk.core.Point3D.create(3, 3, 0)
        endPoint = adsk.core.Point3D.create(8, 8, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        # Get the profile defined by the rectangle
        prof = sketch.profiles.item(0)
        
        # Create an extrusion input for the profile.
        features = secondComponentOccurrence.component.features
        extrudes = features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent of the extrusion is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        
        # Create the extrusion.
        ext = extrudes.add(extInput)
        
        # Create the third component - containing a cylinder that overlaps the box in the second component
        thirdComponentOccurrence = occurrences.addNewComponent(matrix)                
        
        # Create sketch
        sketches = thirdComponentOccurrence.component.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)        
                # Create a circle
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(8, 8, 0)
        sketchCircles.addByCenterRadius(centerPoint, 2)
        
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        
        # Create an extrusion input for the profile.
        features = thirdComponentOccurrence.component.features
        extrudes = features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent of the extrusion is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        
        # Create the extrusion.
        ext = extrudes.add(extInput)    
        
        # Create a collection of the components to check for interference
        inputOccurrences = adsk.core.ObjectCollection.create()
        inputOccurrences.add(firstComponentOccurrence)
        inputOccurrences.add(secondComponentOccurrence)
        inputOccurrences.add(thirdComponentOccurrence)
        
        # Create the interferenceInput object and run the analysis.
        interferenceInput = design.createInterferenceInput(inputOccurrences)
        interferenceInput.areCoincidentFacesIncluded = False
        results = design.analyzeInterference(interferenceInput)    
        
        # Create bodies for every intersection.  This is not supported in Parametric designs.
        interferenceBodies = results.createBodies(True)
        
        # Activate the Intersections component created by Fusion that stores the interference bodies
        resultsOccurrence = occurrences.item(occurrences.count-1)
        resultsOccurrence.activate()
        
        # Fit the view        
        viewport = app.activeViewport
        viewport.fit()
        
        # Report the results
        bod = 0        
        for res in results:
            comp1Name = res.entityOne.parentComponent.name
            comp2Name = res.entityTwo.parentComponent.name
            bodyVolume = str(round(res.interferenceBody.volume, 2))
            interferenceBodies.item(bod).name = 'Interference between ' + comp1Name + ' & ' + comp2Name
            ui.messageBox('There is interference between ' + comp1Name + ' and ' + comp2Name + ' with a volume of ' + bodyVolume + ' cubic centimeters')
            bod += 1
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Application Event API Sample
Description
Add-In that demonstrates application events. To use this sample, create a new folder using the name you want to use for the new add-in. Inside the folder , create a new file that is the same
name as the folder but has a .py extension. Copy the code below into the .py file. Create another file that is the same name as the folder but has a .manifest extension and copy the JSON
data below into that file. { "autodeskProduct": "Fusion360", "type": "addin", "author": "", "description": { "": "" }, "supportedOS": "windows|mac", "editEnabled": true } Run the "Scripts
and Add-Ins" command and click the green plus button near the top of the dialog. Browse to the location where you created the folder and select the folder . The add-in should now be
displayed in the list of add-ins on the "Add-Ins" tab of the dialog. Select the add-in and click the "Run" button. This will load the add-in and when any of the application events occurr that
it is watching for it will report them in the TEXT  COMMAND window .
Code Samples
C++
Python
--

Copy Code
import adsk.core, traceback
# global set of event handlers to keep them referenced
handlers = []
app = adsk.core.Application.get()
# Event handler for the documentOpened event.
class MyDocumentOpenedHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentOpenedHandler event handler.')
# Event handler for the documentOpening event.
class MyDocumentOpeningHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentOpeningHandler event handler.')
# Event handler for the startupCompleted event.
class StartupCompletedHandler(adsk.core.ApplicationEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
           app.log('Startup completed')
        except:
           app.log('Startup completed event failed: {}'.format(traceback.format_exc()))
# Event handler for the onlineStatusChanged event.
class OnlineStatusChangedHandler(adsk.core.ApplicationEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
           status = 'Online'
           if args.isOffLine:
               status = 'Offline'
           app.log('Online status changed: ' + status)
        except:
           app.log('Online status changed event failed: {}'.format(traceback.format_exc()))
# Event handler for the documentCreated event.
class MyDocumentCreatedHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentCreatedHandler event handler.')        
# Event handler for the documentSaved event.
class MyDocumentSavedHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentSavedHandler event handler.')   
        
# Event handler for the documentSaving event.
class MyDocumentSavingHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentSavingHandler event handler.')     
# Event handler for the documentClosing event.
class MyDocumentClosingHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentClosingHandler event handler.')     
        
# Event handler for the documentClosed event.
class MyDocumentClosedHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentClosedHandler event handler.')     # Event handler for the documentDeactivated event.
class MyDocumentDeactivatedHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentDeactivatedHandler event handler.\ndocument: {}'.format(eventArgs.document.name))    
# Event handler for the documentActivated event.
class MyDocumentActivatedHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentActivatedHandler event handler.\ndocument: {}'.format(eventArgs.document.name))    
# Event handler for the documentDeactivating event.
class MyDocumentDeactivatingHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        # Code to react to the event.
        app.log('In MyDocumentDeactivatingHandler event handler.\ndocument: {}'.format(eventArgs.document.name))    
# Event handler for the documentActivating event.
class MyDocumentActivatingHandler(adsk.core.DocumentEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        eventArgs = adsk.core.DocumentEventArgs.cast(args)
        
        # Code to react to the event.
        app.log('In MyDocumentActivatingHandler event handler.\ndocument: {}'.format(eventArgs.document.name))    
                 
def run(context):
    try:
        onStartupCompleted = StartupCompletedHandler()
        app.startupCompleted.add(onStartupCompleted)
        handlers.append(onStartupCompleted)
        
        onOnlineStatusChanged = OnlineStatusChangedHandler()
        app.onlineStatusChanged.add(onOnlineStatusChanged)
        handlers.append(onOnlineStatusChanged)
        
        onDocumentCreated = MyDocumentCreatedHandler()
        app.documentCreated.add(onDocumentCreated)
        handlers.append(onDocumentCreated)
        
        onDocumentSaved = MyDocumentSavedHandler()
        app.documentSaved.add(onDocumentSaved)
        handlers.append(onDocumentSaved)
        
        onDocumentSaving = MyDocumentSavingHandler()
        app.documentSaving.add(onDocumentSaving)
        handlers.append(onDocumentSaving)
     
        onDocumentOpened = MyDocumentOpenedHandler()
        app.documentOpened.add(onDocumentOpened)
        handlers.append(onDocumentOpened)   
        
        onDocumentOpening = MyDocumentOpeningHandler()
        app.documentOpening.add(onDocumentOpening)
        handlers.append(onDocumentOpening)    
        
        onDocumentClosing = MyDocumentClosingHandler()
        app.documentClosing.add(onDocumentClosing)
        handlers.append(onDocumentClosing)   
        
        onDocumentClosed = MyDocumentClosedHandler()
        app.documentClosed.add(onDocumentClosed)
        handlers.append(onDocumentClosed)           
        
        onDocumentDeactivated = MyDocumentDeactivatedHandler()
        app.documentDeactivated.add(onDocumentDeactivated)
        handlers.append(onDocumentDeactivated)    
        
        onDocumentActivated = MyDocumentActivatedHandler()
        app.documentActivated.add(onDocumentActivated)
        handlers.append(onDocumentActivated)
        
        onDocumentDeactivating = MyDocumentDeactivatingHandler()
        app.documentDeactivating.add(onDocumentDeactivating)
        handlers.append(onDocumentDeactivating)   
        
        onDocumentActivating = MyDocumentActivatingHandler()
        app.documentActivating.add(onDocumentActivating)
        handlers.append(onDocumentActivating)   
    except:
        app.log('AddIn Start Failed:\n{}'.format(traceback.format_exc()))
def stop(context):
    try:
        pass
    except:
        app.log('AddIn Stop Failed: {}'.format(traceback.format_exc()))API Sample for  AreaPr operties
Description
Demonstrates how to use AreaProperties
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        
        # Create sketch circle
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 5.0)        
        centerPointTwo = adsk.core.Point3D.create(15, 0, 0)
        sketchCircles.addByCenterRadius(centerPointTwo, 5.0)
        
        # Get the profiles defined by the circle
        prof = sketch.profiles.item(0)
        profTwo = sketch.profiles.item(1)
        
        # Get area properties from a profile
        areaProps = prof.areaProperties(adsk.fusion.CalculationAccuracy.MediumCalculationAccuracy)
        
        # Get area
        area = areaProps.area
        
        # Get centroid
        centroid = areaProps.centroid
        
        # Get perimeter
        perimeter = areaProps.perimeter
        
        # Get angle of rotation of the principal axes
        rotationOfPrincipal = areaProps.rotationToPrincipal
        
        # Accuracy
        accuracy = areaProps.accuracy
        
        # Get area properties from two profiles
        inputs = adsk.core.ObjectCollection.create()
        inputs.add(prof)
        inputs.add(profTwo)
        areaProps = design.areaProperties(inputs)
        
        # Get principal axes
        (retVal, xAxis, yAxis) = areaProps.getPrincipalAxes()
        
        # Get centroid moments of inertia
        (retVal, centixx, centiyy, centizz, centixy, centiyz, centixz) = areaProps.getCentroidMomentsOfInertia()
        
        # Get principal moments of inertia
        (retVal, i1, i2, i3) = areaProps.getPrincipalMomentsOfInertia()
        
        # Get radius of gyration
        (retVal, kxx, kyy, kzz) = areaProps.getRadiusOfGyration()
        
        # Get moments of inertia
        (retVal, ixx, iyy, izz, ixy, iyz, ixz) = areaProps.getMomentsOfInertia()
 
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Create Animation API Sample
Description
Creates a series of images of a design where a parameter is being changed. The series of images can be used to create an animation using other software. To run this sample, have a part
open that contains a parameter named "Length". The parameter should be able to be successfully modified from 10 to 15 centimeters. Run the sample and choose or create a directory for
the output. After running you should have a folder full of images that are snapshots of each parameter value.
Code Samples
C++
Python
--

Copy Code
import adsk.core, adsk.fusion, traceback
import os
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface        
        des = adsk.fusion.Design.cast(app.activeProduct)
        paramName = 'Length'
        startValue = 10
        endValue = 15
        increment = .1
        # Get the output folder.
        fd = ui.createFolderDialog()
        fd.title = "Specify Output Folder"
        if fd.showDialog() != adsk.core.DialogResults.DialogOK:
            return
        resultFolder = fd.folder
        param = des.allParameters.itemByName(paramName)
        if not param:
            ui.messageBox('The parameter "' + paramName + '" must exist.')
            return
        currentValue = startValue
        param.value = currentValue
        # Iterate from the start to end values, capturing a screen 
        # for each one.        
        cnt = 0
        while param.value < endValue:
            param.value = currentValue
            currentValue += increment
            adsk.doEvents()
            filename = os.path.join(resultFolder, "frame" + str(cnt).zfill(4))
            app.activeViewport.saveAsImageFile(filename, 0, 0)                
            cnt += 1            
        ui.messageBox('Finished.')
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Custom Event for  Command Dialog
Description
Demonstrates using a custom event to process getting information in the background to display in a command dialog. This is an add-in and should be copied and pasted into an add-in
project.
Code Samples
Python
--
import adsk.core, adsk.fusion, adsk.cam, traceback
import threading, time, json 
from datetime import datetime
import ctypes
handlers = []
_app = adsk.core.Application.cast(None)
_ui = adsk.core.UserInterface.cast(None)
_tableInput = adsk.core.TableCommandInput.cast(None)
_cmdDef = adsk.core.CommandDefinition.cast(None)
_workerThread = None
myCustomEvent = 'MyDialogDataEvent'
# The event handler that responds when the custom event is fired.
class DialogDataEventHandler(adsk.core.CustomEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            eventArgs = adsk.core.CustomEventArgs.cast(args)
            # Get the data passed through event.  In this case it is
            # formatted as JSON so it extracts the values named
            # "label" and "value".    
            dialogData = eventArgs.additionalInfo
            valueData = json.loads(dialogData)
            label = valueData['label']
            value = valueData['value']
            
            # Set the value of a string value input using the data passed in.
            stringInput = adsk.core.StringValueCommandInput.cast(_tableInput.getInputAtPosition(int(label), 1))
            stringInput.value = value
        except:
            if _ui:
                _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
            
# The worker thread class. 
class GetDialogInfoThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.isStopped = False
    def run(self):
        try:
            # Iterate 5 steps to fill each of the 5 rows in the table.
            for i in range(5):
                # Check to see if the thread has been stopped.
                if not self.isStopped:
                    # Simulate calling a web service that will take some
                    # time and returns some data by sleeping and building
                    # some data using the current time.
                    time.sleep(2)
                    date_object = datetime.now()
                    current_time = date_object.strftime('%H:%M:%S')
                    returnInfo = {'label': str(i), 'value': current_time}
                    returnJson = json.dumps(returnInfo)
                    # Fire the custom event to allow the add-in to update the dialog.    
                    _app.fireCustomEvent(myCustomEvent, returnJson)                    
                else:
                    return
        except:
            ctypes.windll.user32.MessageBoxW(0, 'Failed:\n{}'.format(traceback.format_exc()), "Failed", 1)
    # Method to allow the thread to be stopped.                
    def stop(self):
        self.isStopped = True
# Event handler that is called when the add-in is destroyed. The custom event is
# unregistered here and the thread is stopped.
class MyDestroyHandler(adsk.core.CommandEventHandler):
    def __init__(self):
        super().__init__()    def notify(self, args):
        try:
            eventArgs = adsk.core.CommandEventArgs.cast(args)
            _app.unregisterCustomEvent(myCustomEvent)
            _workerThread.stop()
        except:
            if _ui:
                _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
        
# Event handler to handle when the command is run by the user.
class MyCommandCreatedHandler(adsk.core.CommandCreatedEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            eventArgs = adsk.core.CommandCreatedEventArgs.cast(args)
            inputs = eventArgs.command.commandInputs
            
            # Create a table command input and add five rows of two columns of string 
            # command inputs.  The first column is populated with values and the
            # second is left empty to be populated later as the data is obtained.
            global _tableInput
            _tableInput = inputs.addTableCommandInput('table', 'Info', 2, '1:2')
            _tableInput.maximumVisibleRows = 5
            for i in range(5):
                labelText = inputs.addStringValueInput('label' + str(i), 'Label ' + str(i), 'Item ' + str(i))
                labelText.isReadOnly = True
                _tableInput.addCommandInput(labelText, i, 0, 0, 0)
            
                valueText = inputs.addStringValueInput('value' + str(i), 'Value ' + str(i), '')
                valueText.isReadOnly = True
                _tableInput.addCommandInput(valueText, i, 1, 0, 0)
            
            # Register the custom event and connect the handler.
            customEvent = _app.registerCustomEvent(myCustomEvent)
            onDialogData = DialogDataEventHandler()
            customEvent.add(onDialogData)
            handlers.append(onDialogData)
            
            # Connect a handler to the command destroyed event.
            onDestroy = MyDestroyHandler()
            inputs.command.destroy.add(onDestroy)
            handlers.append(onDestroy)        
    
            # Start the seperate thread that will collect the data to populate
            # the second column of the dialog.
            global _workerThread
            _workerThread = GetDialogInfoThread()
            _workerThread.start()
        except:
            if _ui:
                _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
        
        
def run(context):
    try:
        global _app, _ui, _cmdDef
        _app = adsk.core.Application.get()
        _ui  = _app.userInterface
        # Create a new command and add it to the ADD-INS panel in the model workspace.
        _cmdDef = _ui.commandDefinitions.addButtonDefinition('ThreadTestCmd', 'Thread Test', 'Thread Test') 
        addInsPanel = _ui.allToolbarPanels.itemById('SolidScriptsAddinsPanel')
        buttonControl = addInsPanel.controls.addCommand(_cmdDef)        
        # Connect the command created handler to the event.
        onCommandCreated = MyCommandCreatedHandler()
        _cmdDef.commandCreated.add(onCommandCreated)
        handlers.append(onCommandCreated)
    except:
        if _ui:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
def stop(context):
    try:
        # Clean up the command.
        addInsPanel = _ui.allToolbarPanels.itemById('SolidScriptsAddinsPanel')
        cntrl = addInsPanel.controls.itemById('ThreadTestCmd')
        if cntrl:
            cntrl.deleteMe()
        if _cmdDef:
            _cmdDef.deleteMe()
    except:
        if _ui:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Custom Event Sample
Description
Demonstrates the ability to call into the main thread from a worker thread. This sample is an add-in . To use it, use the Scripts and Add-Ins  command to create a new add-in. Delete all of
the code in the newly created add-in and replace it with the code below . Have a model open that has a parameter named "Length". Load the add-in. The add-in will change the value of the
parameter every two seconds using a random value between 1 and 10.
Code SamplesC++
Python
Copy Code

--
#Author-
#Description-
import adsk.core, adsk.fusion, adsk.cam, traceback
import threading, random, json
app = None
ui = adsk.core.UserInterface.cast(None)
handlers = []
stopFlag = None
myCustomEvent = 'MyCustomEventId'
customEvent = None
# The event handler that responds to the custom event being fired.
class ThreadEventHandler(adsk.core.CustomEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            # Make sure a command isn't running before changes are made.
            if ui.activeCommand != 'SelectCommand':
                ui.commandDefinitions.itemById('SelectCommand').execute()
                            
            # Get the value from the JSON data passed through the event.
            eventArgs = json.loads(args.additionalInfo)
            newValue = float(eventArgs['Value'])
            
            # Set the parameter value.
            design = adsk.fusion.Design.cast(app.activeProduct)
            param = design.rootComponent.modelParameters.itemByName('Length')
            param.value = newValue
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
# The class for the new thread.
class MyThread(threading.Thread):
    def __init__(self, event):
        threading.Thread.__init__(self)
        self.stopped = event
    def run(self):
        # Every five seconds fire a custom event, passing a random number.
        while not self.stopped.wait(2):
            args = {'Value': random.randint(1000, 10000)/1000}
            app.fireCustomEvent(myCustomEvent, json.dumps(args)) 
        
        
def run(context):
    global ui
    global app
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Register the custom event and connect the handler.
        global customEvent
        customEvent = app.registerCustomEvent(myCustomEvent)
        onThreadEvent = ThreadEventHandler()
        customEvent.add(onThreadEvent)
        handlers.append(onThreadEvent)
        # Create a new thread for the other processing.        
        global stopFlag        
        stopFlag = threading.Event()
        myThread = MyThread(stopFlag)
        myThread.start()    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
def stop(context):
    try:
        if handlers.count:
            customEvent.remove(handlers[0])
        stopFlag.set() 
        app.unregisterCustomEvent(myCustomEvent)
        ui.messageBox('Stop addin')
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Custom Graphics Sample
Description
A sample demonstrating how to create custom graphics entities.
To use the sample, create a new Python or C++ script and copy and paste this code, replacing the default code. You also need to unpack this zip file which contains a resource folder  into the
same folder where the source code file (.py or .cpp) is.
Code Samples
C++
Python
Copy Code

--
#Author-Autodesk Inc.
#Description-Demo custom graphics examples
import adsk.core, adsk.fusion, adsk.cam, traceback
import math
# Globals
_app = adsk.core.Application.cast(None)
_ui = adsk.core.UserInterface.cast(None)
_des = adsk.fusion.Design.cast(None)
_cgGroups = adsk.fusion.CustomGraphicsGroups.cast(None)
_numTeeth = 5
_handlers = []
appearancesMap = {}
coordNumber = 0
stripNumber = 0
_pointSetImage = './resources/16x16.png'
_thickness = 0.5 * 2.54
_anchorPt = adsk.core.Point3D.cast(None)
#_scaleFactor is used to limit the size of pixel-scaled model however large the actual graphics model.
_scaleFactor = 10
_commandId = 'CustomGraphicsSample_Python'
_colorEffect_solid_id = 'SolidColorEfect'
_colorEffect_basicMaterial_id = 'BasicMaterialColorEffect'
_colorEffect_appearance_id = 'AppearanceColorEffect'
_colorEffect_vertex_id = 'VertexColorEffect'
# Global Command inputs
_customGraphicsObj = adsk.core.DropDownCommandInput.cast(None)
_colorEffects = adsk.core.DropDownCommandInput.cast(None)
_red = adsk.core.IntegerSliderCommandInput.cast(None)
_green = adsk.core.IntegerSliderCommandInput.cast(None)
_blue = adsk.core.IntegerSliderCommandInput.cast(None)
_opacity = adsk.core.SliderCommandInput.cast(None)
_glossiness = adsk.core.SliderCommandInput.cast(None)
#_text = adsk.core.StringValueCommandInput.cast(None)
_selection = adsk.core.SelectionCommandInput.cast(None)
_transform = adsk.core.DistanceValueCommandInput.cast(None)
_materialLibList = adsk.core.DropDownCommandInput.cast(None)
_appearanceList = adsk.core.DropDownCommandInput.cast(None)
_appearanceFilter = adsk.core.StringValueCommandInput.cast(None)
_coordTable = adsk.core.TableCommandInput.cast(None)
_add = adsk.core.BoolValueCommandInput.cast(None)_addStrip = adsk.core.BoolValueCommandInput.cast(None)
_delete = adsk.core.BoolValueCommandInput.cast(None)
_isLineStrip = adsk.core.BoolValueCommandInput.cast(None)
_lineStylePattern = adsk.core.DropDownCommandInput.cast(None)
_lineStyleWeight = adsk.core.IntegerSliderCommandInput.cast(None)
_lineStyleScale = adsk.core.IntegerSliderCommandInput.cast(None)
_viewPlacementGroup = adsk.core.GroupCommandInput.cast(None)
_viewCorner = adsk.core.ButtonRowCommandInput.cast(None)
_viewScaleGroup = adsk.core.GroupCommandInput.cast(None)
_pixelScale = adsk.core.FloatSliderCommandInput.cast(None)
_billboardingGroup = adsk.core.GroupCommandInput.cast(None)
_billboardingStyle = adsk.core.ButtonRowCommandInput.cast(None)
def run(context):
    try:
        global _app, _ui, _des, _cgGroups
        _app = adsk.core.Application.get()
        _ui  = _app.userInterface        
        doc = _app.activeDocument
        prods = doc.products
        _des = prods.itemByProductType('DesignProductType')
        if not _des:
            raise Exception('Failed to get fusion design.')
        # get the entry for custom graphics
        activeProd = _app.activeProduct
        cam = adsk.cam.CAM.cast(activeProd)
        if cam:              
            _cgGroups = cam.customGraphicsGroups
        else:
            _cgGroups = _des.rootComponent.customGraphicsGroups
        cmdDef = _ui.commandDefinitions.itemById(_commandId)
        if not cmdDef:
            # Create a command definition.
            cmdDef = _ui.commandDefinitions.addButtonDefinition(_commandId, 'CustomGraphicsSample', 'Custom Graphics Sample') 
        
        # Connect to the command created event.
        onCommandCreated = MyCommandCreatedHandler()
        cmdDef.commandCreated.add(onCommandCreated)
        _handlers.append(onCommandCreated)
        
        # Execute the command.
        cmdDef.execute()
        # prevent this module from being terminate when the script returns, because we are waiting for event handlers to fire
        adsk.autoTerminate(False)
    except:
        if _ui:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
            
class MyCommandDestroyHandler(adsk.core.CommandEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
#            eventArgs = adsk.core.CommandEventArgs.cast(args)
            # when the command is done, terminate the script
            # this will release all globals which will remove all event handlers
            adsk.terminate()
        except:
            if _ui:
                _ui.messageBox('Failed in MyCommandDestroyHandler:\n{}'.format(traceback.format_exc()))     
def addRow(tableInput):
    global coordNumber
    tableChildInputs = tableInput.commandInputs
    xValueInput = tableChildInputs.addValueInput(_coordTable.id + '_x{}'.format(coordNumber), 'Value', 'cm', adsk.core.ValueInput.createByReal(coordNumber))
    yValueInput = tableChildInputs.addValueInput(_coordTable.id + '_y{}'.format(coordNumber), 'Value', 'cm', adsk.core.ValueInput.createByReal(coordNumber))
    zValueInput = tableChildInputs.addValueInput(_coordTable.id + '_z{}'.format(coordNumber), 'Value', 'cm', adsk.core.ValueInput.createByReal(coordNumber))
    
    row = tableInput.rowCount
    tableInput.addCommandInput(xValueInput, row, 0)
    tableInput.addCommandInput(yValueInput, row, 1)
    tableInput.addCommandInput(zValueInput, row, 2)
    
    coordNumber = coordNumber + 1
    
def addLineStrip(tableInput):
    global stripNumber
    tableChildInputs = tableInput.commandInputs
    strInput = tableChildInputs.addStringValueInput(_coordTable.id + '_strip{}'.format(stripNumber), 'Line Strip', '-- Line Strip --')
    strInput.isReadOnly = True
    
    row = tableInput.rowCount
    tableInput.addCommandInput(strInput, row, 0, 0, 2)
    
    stripNumber = stripNumber + 1                
    
def replaceItems(cmdInput, newItems):
    try:
        cmdInput.listItems.clear()
        itemNone = cmdInput.listItems.add('None', True, '')
        itemNone.isSelected = True
        if len(newItems) > 0:
            for item in newItems:
                cmdInput.listItems.add(item, False, '')
            cmdInput.listItems[1].isSelected = True
            cmdInput.listItems[0].deleteMe()   
    except:
        if _ui:
            _ui.messageBox('Failed in replaceItems:\n{}'.format(traceback.format_exc()))        
        def getAppearancesFromLib(libName, filterExp):
    try:
        global appearancesMap
        appearanceList = None
        if libName in appearancesMap:
            appearanceList = appearancesMap[libName]
        else:
            materialLib = _app.materialLibraries.itemByName(libName)
            appearances = materialLib.appearances
            appearanceNames = []
            for appearance in appearances:
                appearanceNames.append(appearance.name)
            appearancesMap[libName] = appearanceNames
            appearanceList = appearanceNames
        if filterExp and len(filterExp) > 0:
            filteredList = []
            for appearanceName in appearanceList:
                if appearanceName.lower().find(filterExp.lower()) >= 0:
                    filteredList.append(appearanceName)
            return filteredList
        else:
            return appearanceList
    except:
        if _ui:
            _ui.messageBox('Failed in getAppearancesFromLib:\n{}'.format(traceback.format_exc()))        
def hasAppearances(lib):
    if lib and lib.appearances.count > 0:
        return True
    return False
    
def getMaterialLibNames(libFilter):
    materialLibs = _app.materialLibraries
    libNames = []
    for materialLib in materialLibs:
        if (not libFilter) or libFilter(materialLib):
            libNames.append(materialLib.name)
    return libNames   
             
def getAppearance(libName, appearanceName):
    try:
        if not appearanceName or appearanceName == 'None':
            return
        appearance = _des.appearances.itemByName(appearanceName)
        if appearance:
            return appearance
        
        matLib = _app.materialLibraries.itemByName(libName)      
        if matLib:
            appearance = matLib.appearances.itemByName(appearanceName)
        return appearance            
    except:
        if _ui:
            _ui.messageBox('Failed in getAppearance:\n{}'.format(traceback.format_exc()))        
    
# Event handler for the commandCreated event.
class MyCommandCreatedHandler(adsk.core.CommandCreatedEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            eventArgs = adsk.core.CommandCreatedEventArgs.cast(args)
            
            # Verify that a Fusion design is active.
            if not _des:
                _ui.messageBox('A Fusion design must be active when invoking this command.')
                return()
            cmd = eventArgs.command
            cmd.isExecutedWhenPreEmpted = False
            inputs = cmd.commandInputs            
            
            global _customGraphicsObj, _selection, _coordTable, _add, _delete
            global _colorEffects,_glossiness, _opacity, _transform, _isLineStrip, _addStrip, _lineStyleWeight, _lineStyleScale, _lineStylePattern
            global _red,_green,_blue, _appearanceList, _materialLibList, _appearanceFilter
            
            # menu for different kinds of custom graphics
            _customGraphicsObj = inputs.addDropDownCommandInput(_commandId + '_cgObj', 'Custom Graphics Object', adsk.core.DropDownStyles.TextListDropDownStyle)
            _customGraphicsObj.listItems.add('Mesh', True)     
            _customGraphicsObj.listItems.add('Lines', False) 
            _customGraphicsObj.listItems.add('PointSet', False)
            _customGraphicsObj.listItems.add('Curve', False)
            _customGraphicsObj.listItems.add('BRep', False)
            #_customGraphicsObj.listItems.add('Text', False)       
            _customGraphicsObj.listItems.add('Lines - Custom', False)
            _customGraphicsObj.listItems.add('PointSet - Custom', False) 
            
            # coordinates table used by 'Lines - Custom' and 'PointSet - Custom'
            _coordTable = inputs.addTableCommandInput(_commandId + '_table', 'Coordinates Table', 3, '1:1:1')    
            _coordTable.maximumVisibleRows = 10
            addRow(_coordTable)          
            _add = inputs.addBoolValueInput(_coordTable.id + '_add', 'Add', False, '', True)
            _coordTable.addToolbarCommandInput(_add)
            _addStrip = inputs.addBoolValueInput(_coordTable.id + '_addStrip', 'AddStrip', False, '', True)
            _coordTable.addToolbarCommandInput(_addStrip)
            _delete = inputs.addBoolValueInput(_coordTable.id + '_delete', 'Delete', False, '', True)
            _coordTable.addToolbarCommandInput(_delete)
            _coordTable.isVisible = False
            _add.isVisible = False
            _delete.isVisible = False
            _addStrip.isVisible = False
            
            # specific for 'Lines - Custom'            _isLineStrip = inputs.addBoolValueInput(_commandId + '_isLineStrip', 'Use LineStrip', True, '', True)
            _isLineStrip.isVisible = False
            
            # color effects for custom graphics Mesh/BRep
            _colorEffects = inputs.addDropDownCommandInput(_commandId + '_colorEffects', 'Color Effect', adsk.core.DropDownStyles.TextListDropDownStyle)
            _colorEffects.listItems.add(_colorEffect_solid_id, True) 
            _colorEffects.listItems.add(_colorEffect_basicMaterial_id, False) 
            _colorEffects.listItems.add(_colorEffect_appearance_id, False)     
            _colorEffects.listItems.add(_colorEffect_vertex_id, False)   
            
            # RGB for solid colors
            _red = inputs.addIntegerSliderCommandInput(_commandId + '_red', 'Red', 0, 255, False)
            _red.valueOne = 255
            _green = inputs.addIntegerSliderCommandInput(_commandId + '_green', 'Green', 0, 255, False)
            _green.valueOne = 0
            _blue = inputs.addIntegerSliderCommandInput(_commandId + '_blue', 'Blue', 0, 255, False)   
            _blue.valueOne = 0
            
            # specific for basic material color effect
            _glossiness = inputs.addFloatSliderCommandInput(_commandId + '_glossiness', 'Glossiness', '', 0.0, 128.0, False)
            _glossiness.valueOne = 128.0
            _glossiness.isVisible = False            
            _opacity = inputs.addFloatSliderCommandInput(_commandId + '_opacity', 'Opacity', '', 0.0, 1.0, False)
            _opacity.valueOne = 1.0
            _opacity.isVisible = False
            # for appearance color effect
            _materialLibList = inputs.addDropDownCommandInput(_commandId + '_materialLib', 'Material Library', adsk.core.DropDownStyles.TextListDropDownStyle)
            listItems = _materialLibList.listItems
            materialLibNames = getMaterialLibNames(hasAppearances)
            for materialName in materialLibNames:
                listItems.add(materialName, False, '')
            listItems[0].isSelected = True
            _materialLibList.isVisible = False
            _appearanceList = inputs.addDropDownCommandInput(_commandId + '_appearanceList', 'Appearance', adsk.core.DropDownStyles.TextListDropDownStyle)
            appearances = getAppearancesFromLib(materialLibNames[0], '')
            listItems = _appearanceList.listItems
            for appearanceName in appearances:
                listItems.add(appearanceName, False, '')
            listItems[0].isSelected = True
            _appearanceList.isVisible = False
            _appearanceFilter = inputs.addStringValueInput(_commandId + '_appearanceFilter', 'Filter', '')
            _appearanceFilter.isVisible = False
            # selection input for custom graphics BRep/Curve
            _selection = inputs.addSelectionInput(_commandId + '_sel', 'Selection', '')
            _selection.setSelectionLimits(0, 1)
            _selection.isVisible = False
            _selection.isEnabled = False
            
            # for custom graphics text
            #_text = inputs.addStringValueInput(_commandId + '_text', 'Text', 'This is a text.')
            #_text.isVisible = False
            
            # transform for all custom graphics entity
            _transform = inputs.addDistanceValueCommandInput(_commandId + '_transform', 'Transform', adsk.core.ValueInput.createByReal(0))
            _transform.setManipulator( adsk.core.Point3D.create(0,0,0), adsk.core.Vector3D.create(1,0,0))
            
            # menu for different kinds of line sytles
            _lineStylePattern = inputs.addDropDownCommandInput(_commandId + '_LSPattern', 'Line Style Pattern', adsk.core.DropDownStyles.TextListDropDownStyle)
            _lineStylePattern.listItems.add('Solid Line', True)     
            _lineStylePattern.listItems.add('Center Line', False) 
            _lineStylePattern.listItems.add('Dashed Line', False)
            _lineStylePattern.listItems.add('Dot Line', False)
            _lineStylePattern.listItems.add('Phantom Line', False)
            _lineStylePattern.listItems.add('Tracks Line', False)       
            _lineStylePattern.listItems.add('ZigZag Line', False)
            _lineStylePattern.isVisible = False
            
            # for line sytle weight
            _lineStyleWeight = inputs.addIntegerSliderCommandInput(_commandId + '_LSWeight', 'Line Style Weight', 1, 20, False)
            _lineStyleWeight.valueOne = 1
            _lineStyleWeight.isVisible = False
            
            # for line style scale
            _lineStyleScale = inputs.addIntegerSliderCommandInput(_commandId + '_LSScale', 'Line Style Scale', 1, 100, False)
            _lineStyleScale.valueOne = 10
            _lineStyleScale.isVisible = False
            
            global _viewPlacementGroup, _viewCorner, _viewScaleGroup, _pixelScale, _billboardingGroup, _billboardingStyle            
            # for view placement attribute
            _viewPlacementGroup = inputs.addGroupCommandInput(_commandId + '_VPGroup', 'View Placement')
            _viewPlacementGroup.isEnabledCheckBoxDisplayed = True
            _viewPlacementGroup.isEnabledCheckBoxChecked = False
            _viewCorner = _viewPlacementGroup.children.addButtonRowCommandInput(_commandId + '_viewCorner', 'corner', False)
            _viewCorner.listItems.add('Upper Left', False, './resources/upperLeft')
            _viewCorner.listItems.add('Upper Right', False, './resources/upperRight')
            _viewCorner.listItems.add('Lower Left', False, './resources/lowerLeft')
            _viewCorner.listItems.add('Lower Right', False, './resources/lowerRight')     
            
            # for view scale attribute
            _viewScaleGroup = inputs.addGroupCommandInput(_commandId + '_VSGroup', 'View Scale')
            _viewScaleGroup.isEnabledCheckBoxDisplayed = True
            _viewScaleGroup.isEnabledCheckBoxChecked = False
            _pixelScale = _viewScaleGroup.children.addFloatSliderCommandInput(_commandId + '_pixelScale', 'pixel scale', '', 0.5, 5, False)
            _pixelScale.valueOne = 1
            _pixelScale.setText('Smaller', 'Larger')
            
            # for billboarding attribute
            _billboardingGroup = inputs.addGroupCommandInput(_commandId + '_BBGroup', 'Billboarding')
            _billboardingGroup.isEnabledCheckBoxDisplayed = True
            _billboardingGroup.isEnabledCheckBoxChecked = False        
            _billboardingStyle = _billboardingGroup.children.addButtonRowCommandInput(_commandId + '_billboardingStyle', 'style', False)
            _billboardingStyle.listItems.add('Screen', False, './resources/One')
            _billboardingStyle.listItems.add('Axis', False, './resources/Two')            _billboardingStyle.listItems.add('Right Reading', False, './resources/Three')          
            
            # Connect to the command related events.
            onExecute = MyCommandExecuteHandler()
            cmd.execute.add(onExecute)
            _handlers.append(onExecute)        
            
            onExecutePreview = MyCommandExecuteHandler()
            cmd.executePreview.add(onExecutePreview)
            _handlers.append(onExecutePreview)  
            
            onInputChanged = MyCommandInputChangedHandler()
            cmd.inputChanged.add(onInputChanged)
            _handlers.append(onInputChanged)     
            onDestroy = MyCommandDestroyHandler()
            cmd.destroy.add(onDestroy)
            _handlers.append(onDestroy)
        except:
            if _ui:
                _ui.messageBox('Failed in MyCommandCreatedHandler:\n{}'.format(traceback.format_exc()))
def applyColorEffect(cgEnt):
    try:
        colorEffect = None
        if _colorEffects.selectedItem.name == _colorEffect_solid_id:
            colorEffect = adsk.fusion.CustomGraphicsSolidColorEffect.create(adsk.core.Color.create(int(_red.valueOne),int(_green.valueOne),int(_blue.valueOne),255))
        elif _colorEffects.selectedItem.name == _colorEffect_basicMaterial_id:
            diffuseColor = adsk.core.Color.create(0,255,0,255)                      
            ambientColor = adsk.core.Color.create(255,0,0,255)            
            specularColor = adsk.core.Color.create(0,0,255,255)  
            emissiveColor = adsk.core.Color.create(0,0,0,255) 
            colorEffect = adsk.fusion.CustomGraphicsBasicMaterialColorEffect.create(diffuseColor, ambientColor, specularColor, emissiveColor, float(_glossiness.valueOne), 
        elif _colorEffects.selectedItem.name == _colorEffect_appearance_id:
            appearance = getAppearance(_materialLibList.selectedItem.name, _appearanceList.selectedItem.name)
            if appearance:
                if not _des.appearances.itemByName(appearance.name):
                    appearance = _des.appearances.addByCopy(appearance, appearance.name)
                colorEffect = adsk.fusion.CustomGraphicsAppearanceColorEffect.create(appearance)
        elif _colorEffects.selectedItem.name == _colorEffect_vertex_id:
            colorEffect = adsk.fusion.CustomGraphicsVertexColorEffect.create()
        if colorEffect:
            cgEnt.color = colorEffect
    except:
        if _ui:
            _ui.messageBox('Failed in applyColorEffect:\n{}'.format(traceback.format_exc()))
def getCoordinatesFromTable(tableInput):
    try:
        vecCoord = []
        vecStripLen = []
        stripLen = 0
        if _coordTable:
            for i in range(0, _coordTable.rowCount):
                xValueInput = adsk.core.ValueCommandInput.cast(_coordTable.getInputAtPosition(i,0))
                if xValueInput:
                    stripLen = stripLen + 1
                    yValueInput = adsk.core.ValueCommandInput.cast(_coordTable.getInputAtPosition(i,1))
                    zValueInput = adsk.core.ValueCommandInput.cast(_coordTable.getInputAtPosition(i,2))
                    vecCoord.extend([xValueInput.value, yValueInput.value, zValueInput.value])    
                else:
                    vecStripLen.append(stripLen)
                    stripLen = 0
            vecStripLen.append(stripLen)
        return vecCoord, vecStripLen
    except:
        if _ui:
            _ui.messageBox('Failed in getCoordinatesFromTable:\n{}'.format(traceback.format_exc()))    
# Event handler for the execute event.
class MyCommandExecuteHandler(adsk.core.CommandEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            # get selection entity first since it's fragile and any creation/edit operations will clear the selection.
            selEntity = None
            if _selection.selectionCount > 0:
                selEntity = _selection.selection(0).entity
                                    
            if _customGraphicsObj:
                cgGroup = adsk.fusion.CustomGraphicsGroup.cast(_cgGroups.add())     
                
                global _anchorPt, _scaleFactor
                if not _anchorPt:
                    _anchorPt = adsk.core.Point3D.create(0,0,0)
                cgEnt = None
                if _customGraphicsObj.selectedItem.name == 'Mesh':
                    cgEnt = drawMesh(cgGroup) 
                    _anchorPt.setWithArray([0,0,_thickness/2])
                elif _customGraphicsObj.selectedItem.name == 'Lines':
                    cgEnt = drawLines(cgGroup)                
                    _anchorPt.setWithArray([0,0,_thickness/2])
                elif _customGraphicsObj.selectedItem.name == 'PointSet':
                    cgEnt = drawPointSet(cgGroup)
                elif _customGraphicsObj.selectedItem.name == 'BRep':                    
                    if selEntity:
                        body = adsk.fusion.BRepBody.cast(selEntity)
                        cgEnt = cgGroup.addBRepBody(body)
                elif _customGraphicsObj.selectedItem.name == 'Curve':
                    if selEntity:
                        skCurve = adsk.fusion.SketchCurve.cast(selEntity)
                        sk = skCurve.parentSketch
                        curve = skCurve.geometry
                        curve.transformBy(sk.transform)                        cgEnt = cgGroup.addCurve(curve)
                        cgEnt.weight = float(_lineStyleWeight.valueOne)                        
                #elif _customGraphicsObj.selectedItem.name == 'Text':
                #    if _text.value:
                #        cgEnt = cgGroup.addText(_text.value, 'None', 10, adsk.core.Point3D.create(0,0,0))
                elif _customGraphicsObj.selectedItem.name == 'PointSet - Custom':
                    vecCoords, vecStripLen = getCoordinatesFromTable(_coordTable)
                    coords = adsk.fusion.CustomGraphicsCoordinates.create(vecCoords)
                    cgEnt = cgGroup.addPointSet(coords, [], adsk.fusion.CustomGraphicsPointTypes.UserDefinedCustomGraphicsPointType, _pointSetImage)
                elif _customGraphicsObj.selectedItem.name == 'Lines - Custom':
                    vecCoords, vecStripLength = getCoordinatesFromTable(_coordTable)
                    coords = adsk.fusion.CustomGraphicsCoordinates.create(vecCoords)
                    isLineStrip = _isLineStrip.value
                    if coords.coordinateCount < 1:
                        return
                    cgEnt = cgGroup.addLines(coords, [], isLineStrip, vecStripLength)
                
                # add attributes to the custom graphics entity
                if cgEnt:
                    # transform
                    transMat = adsk.core.Matrix3D.create()
                    origin = adsk.core.Point3D.create(float(_transform.value),0,0)
                    transMat.setWithCoordinateSystem(origin, adsk.core.Vector3D.create(1,0,0), adsk.core.Vector3D.create(0,1,0), adsk.core.Vector3D.create(0,0,1))
                    cgEnt.transform = transMat   
                    # color effect
                    if not adsk.fusion.CustomGraphicsPointSet.cast(cgEnt):
                        applyColorEffect(cgEnt)                    
                    # calculate _scaleFactor and _anchorPt for viewPlacement, viewScale and billboarding attributes based on the bounding box of custom graphics entity
                    maxPt = cgEnt.boundingBox.maxPoint
                    minPt = cgEnt.boundingBox.minPoint       
                    _scaleFactor = 100 / minPt.distanceTo(maxPt)
                    _anchorPt.setWithArray([(minPt.x + maxPt.x) / 2, (minPt.y + maxPt.y) / 2, (minPt.z + maxPt.z) / 2])
                    # view placement
                    if _viewPlacementGroup and _viewPlacementGroup.isVisible and _viewPlacementGroup.isEnabledCheckBoxChecked and _viewCorner and _viewCorner.selectedItem
                        viewPt = adsk.core.Point2D.create(100,100)
                        # upper left by default
                        corner = adsk.fusion.ViewCorners.upperLeftViewCorner                          
                        if _viewCorner.selectedItem.name == 'Upper Right':
                            corner = adsk.fusion.ViewCorners.upperRightViewCorner
                        elif _viewCorner.selectedItem.name == 'Lower Left':
                            corner = adsk.fusion.ViewCorners.lowerLeftViewCorner
                        elif _viewCorner.selectedItem.name == 'Lower Right':
                            corner = adsk.fusion.ViewCorners.lowerRightViewCorner
                        attr = adsk.fusion.CustomGraphicsViewPlacement.create(_anchorPt, corner, viewPt)
                        cgEnt.viewPlacement = attr
                    # view scale
                    if _viewScaleGroup and _viewScaleGroup.isVisible and _viewScaleGroup.isEnabledCheckBoxChecked and _pixelScale:
                        attr = adsk.fusion.CustomGraphicsViewScale.create(_scaleFactor * _pixelScale.valueOne, _anchorPt)
                        cgEnt.viewScale = attr
                    # billboarding
                    if _billboardingGroup and _billboardingGroup.isVisible and _billboardingGroup.isEnabledCheckBoxChecked and _billboardingStyle and _billboardingStyle.se
                        # screen style by default
                        bbStyle = adsk.fusion.CustomGraphicsBillBoardStyles.ScreenBillBoardStyle
                        if _billboardingStyle.selectedItem.name == 'Axis':
                            bbStyle = adsk.fusion.CustomGraphicsBillBoardStyles.AxialBillBoardStyle
                        elif _billboardingStyle.selectedItem.name == 'Right Reading':
                            bbStyle = adsk.fusion.CustomGraphicsBillBoardStyles.RightReadingBillBoardStyle
                        attr = adsk.fusion.CustomGraphicsBillBoard.create(_anchorPt)
                        attr.axis = adsk.core.Vector3D.create(0,1,0)
                        attr.billBoardStyle = bbStyle
                        cgEnt.billBoarding = attr
                            
        except:
            if _ui:
                _ui.messageBox('Failed in MyCommandExecuteHandler:\n{}'.format(traceback.format_exc()))
def changeCGObjVisibility(strObjName):
    try:       
        _colorEffects.listItems.clear()
        _colorEffects.listItems.add(_colorEffect_solid_id, True) 
        _colorEffects.listItems.add(_colorEffect_basicMaterial_id, False) 
        _colorEffects.listItems.add(_colorEffect_appearance_id, False)   
        _colorEffects.isVisible = False
        _selection.clearSelection()
        _selection.clearSelectionFilter()
        _selection.setSelectionLimits(0, 0)
        _selection.isVisible = False
        _selection.isEnabled = False        
        #_text.isVisible = False
        _coordTable.isVisible = False
        _isLineStrip.isVisible = False
        _lineStylePattern.isVisible = False
        _lineStyleWeight.isVisible = False
        _lineStyleScale.isVisible = False
        changeColorEffectVisibility(None)
        
        _viewPlacementGroup.isVisible = False
        _viewScaleGroup.isVisible = False
        _billboardingGroup.isVisible = False
        
        if strObjName == 'Mesh':
            _colorEffects.isVisible = True
            _colorEffects.listItems.add(_colorEffect_vertex_id, False) 
            changeColorEffectVisibility(_colorEffect_solid_id)
            _viewPlacementGroup.isVisible = True
            _viewScaleGroup.isVisible = True
            _billboardingGroup.isVisible = True
        elif strObjName == 'Lines':             
            changeColorEffectVisibility(_colorEffect_solid_id)
            _lineStylePattern.isVisible = True
            _lineStyleWeight.isVisible = True
            if _lineStylePattern.selectedItem.name != 'Solid Line':
                _lineStyleScale.isVisible = True
            _viewPlacementGroup.isVisible = True
            _viewScaleGroup.isVisible = True            _billboardingGroup.isVisible = True
        elif strObjName == 'Curve':
            _selection.isVisible = True
            _selection.isEnabled = True
            _selection.tooltip = 'select a curve'
            _selection.commandPrompt = 'select a curve'
            _selection.addSelectionFilter('SketchCurves')
            _selection.setSelectionLimits(1,1)
            changeColorEffectVisibility(_colorEffect_solid_id)
            _lineStyleWeight.isVisible = True
            _viewPlacementGroup.isVisible = True
            _viewScaleGroup.isVisible = True
            _billboardingGroup.isVisible = True
        elif strObjName == 'BRep':
            _selection.isVisible = True
            _selection.isEnabled = True
            _selection.tooltip = 'select a body'
            _selection.commandPrompt = 'select a body'
            _selection.addSelectionFilter('Bodies')  
            _selection.setSelectionLimits(1,1)
            _colorEffects.isVisible = True
            changeColorEffectVisibility(_colorEffect_solid_id)
            _viewPlacementGroup.isVisible = True
            _viewScaleGroup.isVisible = True
            _billboardingGroup.isVisible = True
        #elif strObjName == 'Text':
        #    _text.isVisible = True
        #    changeColorEffectVisibility(_colorEffect_solid_id)   
        elif strObjName == 'PointSet - Custom':   
            _coordTable.isVisible = True 
            _addStrip.isEnabled = False
        elif strObjName == 'Lines - Custom': 
            _coordTable.isVisible = True
            _isLineStrip.isVisible = True
            _addStrip.isEnabled = True
            changeColorEffectVisibility(_colorEffect_solid_id)
            _lineStylePattern.isVisible = True
            _lineStyleWeight.isVisible = True
            if _lineStylePattern.selectedItem.name != 'Solid Line':
                _lineStyleScale.isVisible = True
    except:
        if _ui:
            _ui.messageBox('Failed in changeCGObjVisibility:\n{}'.format(traceback.format_exc()))
                 
def changeColorEffectVisibility(strColorEffectName):
    try:
        _red.isVisible = False
        _green.isVisible = False
        _blue.isVisible = False
        _opacity.isVisible = False
        _glossiness.isVisible = False
        _appearanceList.isVisible = False
        _materialLibList.isVisible = False
        _appearanceFilter.isVisible = False
        
        if strColorEffectName == _colorEffect_solid_id:
            _red.isVisible = True
            _green.isVisible = True
            _blue.isVisible = True         
        elif strColorEffectName == _colorEffect_basicMaterial_id:     
            _opacity.isVisible = True
            _glossiness.isVisible = True
        elif strColorEffectName == _colorEffect_appearance_id:
            _appearanceList.isVisible = True
            _materialLibList.isVisible = True
            _appearanceFilter.isVisible = True
            
    except:
        if _ui:
            _ui.messageBox('Failed in changeColorEffectVisibility:\n{}'.format(traceback.format_exc()))
def changeLineStyleInputsVisibility(patternName):
    try:
        if patternName == 'Solid Line':
            _lineStyleScale.isVisible = False
        else:
            _lineStyleScale.isVisible = True
        
    except:
        if _ui:
            _ui.messageBox('Failed in changeLineStyleInputsVisibility:\n{}'.format(traceback.format_exc()))
    
# Event handler for the inputChanged event.
class MyCommandInputChangedHandler(adsk.core.InputChangedEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            eventArgs = adsk.core.InputChangedEventArgs.cast(args)
            changedInput = eventArgs.input
            if changedInput.id == _commandId + '_cgObj':
                changeCGObjVisibility(_customGraphicsObj.selectedItem.name)
            elif changedInput.id == _commandId + '_colorEffects':
                changeColorEffectVisibility(_colorEffects.selectedItem.name)  
            elif changedInput.id == _commandId + '_appearanceFilter' or changedInput.id == _commandId + '_materialLib':
                appearances = getAppearancesFromLib(_materialLibList.selectedItem.name, _appearanceFilter.value)
                replaceItems(_appearanceList, appearances)
            elif changedInput.id == _coordTable.id + '_add':
                addRow(_coordTable)
            elif changedInput.id == _coordTable.id + '_addStrip':
                addLineStrip(_coordTable)
            elif changedInput.id == _coordTable.id + '_delete':
               if _coordTable.selectedRow == -1:
                   _ui.messageBox('Select one row to delete')
               else:                   _coordTable.deleteRow(_coordTable.selectedRow)
            elif changedInput.id == _commandId + '_LSPattern':
                changeLineStyleInputsVisibility(_lineStylePattern.selectedItem.name)
        except:
            if _ui:
                _ui.messageBox('Failed in MyCommandInputChangedHandler:\n{}'.format(traceback.format_exc()))
def rotate2D(rad, vec):
    try:
        x = vec[0]
        y = vec[1]
        return (x*math.cos(rad)-y*math.sin(rad), x*math.sin(rad)+y*math.cos(rad))
    except:
        if _ui:
            _ui.messageBox('Failed in rotate2D:\n{}'.format(traceback.format_exc()))    
def calculateCoordinates(numTeeth):
    try:         
        # holeDia < rootDia < pitchDia < outsideDia     
        holeDia = 0.5 * 2.54
        diametralPitch = 2 / 2.54
        pitchDia = numTeeth / diametralPitch
        if (diametralPitch < (20 *(math.pi/180))-0.000001):
            dedendum = 1.157 / diametralPitch
        else:
            circularPitch = math.pi / diametralPitch
            if circularPitch >= 20:
                dedendum = 1.25 / diametralPitch
            else:
                dedendum = (1.2 / diametralPitch) + (.002 * 2.54)                
        rootDia = pitchDia - (2 * dedendum)        
        outsideDia = (numTeeth + 2) / diametralPitch
        
        rPts0 = []    # 2 * numTeeth for root
        hPts0 = []    # 2 * numTeeth for hole
        pPts0 = []    # 2 * numTeeth for pitch
        oPts0 = []    # 1 * numTeeth for outside
        rPts1 = []    # 2 * numTeeth for root with thickness
        hPts1 = []    # 2 * numTeeth for hole with thickness
        pPts1 = []    # 2 * numTeeth for pitch with thickness
        oPts1 = []    # 1 * numTeeth for outside with thickness
        
        vecRootRadi = [rootDia/2.0, 0]
        vecHoleRadi = [holeDia/2.0, 0]
        vecPitchRadi = [pitchDia/2.0, 0]
        vecOutRadi = [outsideDia/2.0, 0]
        unitRadian = math.pi / numTeeth
        
        vecCoords = []    
        vecColors = []
        for i in range(0, 2 * numTeeth):            
            x, y = rotate2D(unitRadian * (i - 0.5), vecRootRadi)
            rPts0.append(int(len(vecCoords) / 3))
            rPts1.append(int(len(vecCoords) / 3) + 1)
            vecCoords.extend([x, y, 0, x, y, _thickness])
            vecColors.extend([255,0,255,128, 255,0,255,128])
    
        for i in range(0, 2 * numTeeth):            
            x, y = rotate2D(unitRadian * (i - 0.5), vecHoleRadi)
            hPts0.append(int(len(vecCoords) / 3))
            hPts1.append(int(len(vecCoords) / 3) + 1)   
            vecCoords.extend([x, y, 0, x, y, _thickness])
            vecColors.extend([255,0,0,128,  255,0,0,128])
            
        for i in range(0, 2 * numTeeth):            
            x, y = rotate2D(unitRadian * (i - 0.5), vecPitchRadi)
            pPts0.append(int(len(vecCoords) / 3))
            pPts1.append(int(len(vecCoords) / 3) + 1)   
            vecCoords.extend([x, y, 0, x, y, _thickness])
            vecColors.extend([0,0,255,128, 0,0,255,128])
    
        for i in range(0, numTeeth):            
            x, y = rotate2D(unitRadian * i * 2 , vecOutRadi)
            oPts0.append(int(len(vecCoords) / 3))
            oPts1.append(int(len(vecCoords) / 3) + 1)   
            vecCoords.extend([x, y, 0, x, y, _thickness])
            vecColors.extend([0,255,255,128, 0,255,255,128])
    
        return (rPts0, hPts0, pPts0, oPts0, rPts1, hPts1, pPts1, oPts1, vecCoords, vecColors)
    except:
        if _ui:
            _ui.messageBox('Failed in calculateCoordinates:\n{}'.format(traceback.format_exc()))
def calculateStripLen(numTeeth):
    try:
        vecStripLen = []
        for i in range(0, numTeeth):
            vecStripLen.append(6)
        for i in range(0, 2 * numTeeth):
            vecStripLen.append(21)  
        for i in range(0, numTeeth):
            vecStripLen.append(24)
        for i in range(0, 2 * numTeeth):
            vecStripLen.append(6)            
        return vecStripLen
    except Exception as error:
        _ui.messageBox("calculateTriangles Failed : " + str(error)) 
            
def calculateTriangles(numTeeth, rPts0, hPts0, pPts0, oPts0, rPts1, hPts1, pPts1, oPts1):
    try: 
        vertexIndexList = []    
        # triangles between teeth
        for i in range(0, numTeeth):
            idx0 = (2*i+1) % (2*numTeeth)
            idx1 = (2*i+2) % (2*numTeeth)
            rPtA0 = rPts0[idx0]            rPtB0 = rPts0[idx1]         
            rPtA1 = rPts1[idx0]
            rPtB1 = rPts1[idx1]  
            vertexIndexList.extend([rPtA0,rPtB0,rPtB1, rPtB1,rPtA1,rPtA0])
        # triangles on surface0
        for i in range(0, numTeeth):
            rPtA = rPts0[i*2]
            rPtB = rPts0[i*2 + 1]
            rPtC = rPts0[(i*2 + 2)%(2*numTeeth)]        
            hPtA = hPts0[i*2]
            hPtB = hPts0[i*2 + 1]  
            hPtC = hPts0[(i*2 + 2)%(2*numTeeth)]        
            pPtA = pPts0[i*2]
            pPtB = pPts0[i*2 + 1]               
            oPt = oPts0[i]                                  
            vertexIndexList.extend([hPtB,hPtC,rPtC, rPtC,rPtB,hPtB])
            vertexIndexList.extend([rPtA,rPtB,pPtB, pPtB,pPtA,rPtA])  
            vertexIndexList.extend([hPtA,hPtB,rPtB, rPtB,rPtA,hPtA])           
            vertexIndexList.extend([pPtA,pPtB,oPt])              
        # triangles on surface1
        for i in range(0, numTeeth):
            rPtA = rPts1[i*2]
            rPtB = rPts1[i*2 + 1]
            rPtC = rPts1[(i*2 + 2)%(2*numTeeth)]
            hPtA = hPts1[i*2]
            hPtB = hPts1[i*2 + 1]  
            hPtC = hPts1[(i*2 + 2)%(2*numTeeth)]
            pPtA = pPts1[i*2]
            pPtB = pPts1[i*2 + 1]         
            oPt = oPts1[i]             
            vertexIndexList.extend([hPtC,hPtB,rPtB, rPtB,rPtC,hPtC])
            vertexIndexList.extend([rPtB,rPtA,pPtA, pPtA,pPtB,rPtB]) 
            vertexIndexList.extend([hPtB,hPtA,rPtA, rPtA,rPtB,hPtB])          
            vertexIndexList.extend([pPtB,pPtA,oPt])         
        # triangles on teeth
        for i in range(0, numTeeth):
            rPtA0 = rPts0[i*2]
            rPtB0 = rPts0[i*2 + 1]  
            pPtA0 = pPts0[i*2]
            pPtB0 = pPts0[i*2 + 1]    
            rPtA1 = rPts1[i*2]
            rPtB1 = rPts1[i*2 + 1]  
            pPtA1 = pPts1[i*2]
            pPtB1 = pPts1[i*2 + 1] 
            oPt0 = oPts0[i]
            oPt1 = oPts1[i]        
            # triangles on one tooth
            vertexIndexList.extend([rPtA1, rPtA0, pPtA0, pPtA0, pPtA1, rPtA1])
            vertexIndexList.extend([pPtA1, pPtA0, oPt0, oPt0, oPt1, pPtA1])
            vertexIndexList.extend([rPtB0, rPtB1, pPtB1, pPtB1, pPtB0, rPtB0])    
            vertexIndexList.extend([pPtB0, pPtB1, oPt1, oPt1, oPt0, pPtB0])         
        # triangles on inner face
        for i in range(0, 2*numTeeth):
            hPtA0 = hPts0[i]
            hPtB0 = hPts0[(i + 1)%(2*numTeeth)] 
            hPtA1 = hPts1[i]
            hPtB1 = hPts1[(i + 1)%(2*numTeeth)] 
            vertexIndexList.extend([hPtA1,hPtB1,hPtB0, hPtB0,hPtA0,hPtA1])                
            
        return vertexIndexList
    except Exception as error:
        _ui.messageBox("calculateTriangles Failed : " + str(error)) 
        return None
# Builds a custom graphics mesh.
def drawMesh(cgGroup):
    try:        
        # Calculate mesh coordinates
        rPts0, hPts0, pPts0, oPts0, rPts1, hPts1, pPts1, oPts1, vecCoords, vecColors = calculateCoordinates(_numTeeth)        
        coordinates = adsk.fusion.CustomGraphicsCoordinates.create(vecCoords)
        coordinates.colors = vecColors
        # Calculate mesh triangles
        vertexIndexList = calculateTriangles(_numTeeth, rPts0, hPts0, pPts0, oPts0, rPts1, hPts1, pPts1, oPts1)        
        # Add Custom Graphics mesh
        normalVectors = []
        normalIndexList = []
        cgMesh = cgGroup.addMesh(coordinates, vertexIndexList, normalVectors, normalIndexList)        
        return cgMesh
        
    except Exception as error:
        _ui.messageBox("drawMesh Failed : " + str(error)) 
        return None
        
def drawLines(cgGroup):
    try:
        rPts0, hPts0, pPts0, oPts0, rPts1, hPts1, pPts1, oPts1, vecCoords, vecColors = calculateCoordinates(_numTeeth)        
        coordinates = adsk.fusion.CustomGraphicsCoordinates.create(vecCoords)       
        vertexIndexList = calculateTriangles(_numTeeth, rPts0, hPts0, pPts0, oPts0, rPts1, hPts1, pPts1, oPts1)        
            
        stripLen = calculateStripLen(_numTeeth)
        cgLines = cgGroup.addLines(coordinates, vertexIndexList, True, stripLen)
        
        if _lineStylePattern.selectedItem.name == 'Solid Line':
            cgLines.lineStylePattern = adsk.fusion.LineStylePatterns.continuousLineStylePattern
        elif _lineStylePattern.selectedItem.name == 'Center Line':
            cgLines.lineStylePattern = adsk.fusion.LineStylePatterns.centerLineStylePattern
        elif _lineStylePattern.selectedItem.name == 'Dashed Line':
            cgLines.lineStylePattern = adsk.fusion.LineStylePatterns.dashedLineStylePattern
        elif _lineStylePattern.selectedItem.name == 'Dot Line':
            cgLines.lineStylePattern = adsk.fusion.LineStylePatterns.dotLineStylePattern
        elif _lineStylePattern.selectedItem.name == 'Dashed Line':
            cgLines.lineStylePattern = adsk.fusion.LineStylePatterns.dashedLineStylePattern
        elif _lineStylePattern.selectedItem.name == 'Phantom Line':
            cgLines.lineStylePattern = adsk.fusion.LineStylePatterns.phantomLineStylePattern
        elif _lineStylePattern.selectedItem.name == 'Tracks Line':            cgLines.lineStylePattern = adsk.fusion.LineStylePatterns.tracksLineStylePattern
        elif _lineStylePattern.selectedItem.name == 'ZigZag Line':
            cgLines.lineStylePattern = adsk.fusion.LineStylePatterns.zigzagLineStylePattern
            
        cgLines.weight = float(_lineStyleWeight.valueOne)
        cgLines.lineStyleScale = float(_lineStyleScale.valueOne)
        
        return cgLines
    except Exception as error:
        _ui.messageBox("drawLines Failed : " + str(error)) 
        return None   
        
def drawPointSet(cgGroup):
    try:
        rPts0, hPts0, pPts0, oPts0, rPts1, hPts1, pPts1, oPts1, vecCoords, vecColors = calculateCoordinates(_numTeeth)        
        coordinates = adsk.fusion.CustomGraphicsCoordinates.create(vecCoords)       
               
        cgPoints = cgGroup.addPointSet(coordinates, [], adsk.fusion.CustomGraphicsPointTypes.UserDefinedCustomGraphicsPointType, _pointSetImage)
        return cgPoints
    except Exception as error:
        _ui.messageBox("drawPointSet Failed : " + str(error)) 
        return None
ExportManager  API Sample
Description
Demonstrates how to export f3d to dif ferent formats.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
import os.path, sys
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        
        # get active design        
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
         
        # get all components in this design
        allComps = design.allComponents
         
        # get the script location
        scriptDir = os.path.dirname(os.path.realpath(__file__))        
         
        # create a single exportManager instance
        exportMgr = design.exportManager
        
        # export the component one by one with a specified format
        for comp in allComps:
            compName = comp.name
            fileName = scriptDir + "/" + compName
             
            # export the component with IGS format
            igesOptions = exportMgr.createIGESExportOptions(fileName, comp)
            exportMgr.execute(igesOptions)
             
            # export the component with SAT format
            satOptions = exportMgr.createSATExportOptions(fileName, comp)
            exportMgr.execute(satOptions)
         
            # export the component with SMT format
            smtOptions = exportMgr.createSMTExportOptions(fileName, comp)
            exportMgr.execute(smtOptions)
             
            # export the component with STP format
            stpOptions = exportMgr.createSTEPExportOptions(fileName, comp)
            exportMgr.execute(stpOptions)
             
            # export the component with F3D format
            archOptions = exportMgr.createFusionArchiveExportOptions(fileName, comp)
            exportMgr.execute(archOptions)
            
            # export the component with USD (Universal Scene Description) format
            usdOptions = exportMgr.createUSDExportOptions(fileName, comp)
            exportMgr.execute(usdOptions)           
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

std::string getDllPath()
{
#if defined(_WINDOWS) || defined(_WIN32) || defined(_WIN64)
HMODULE hModule = NULL;
if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | 
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
(LPCSTR) &getDllPath, 
&hModule))
return "";
char winTempPath[2048];
::GetModuleFileNameA (hModule, winTempPath, 2048);
std::string strPath = winTempPath;
size_t stPos = strPath.rfind('\\');
return strPath.substr(0, stPos);
#else
Dl_info info;
dladdr((void*) getDllPath, &info);
std::string strPath = info.dli_fname;
int stPos = (int)strPath.rfind('/');
if(stPos != -1)
return strPath.substr(0, stPos);
else
return "";;
#endif
}
Export to other  formats API Sample
Description
Demonstrates exporting the active design to IGES, STEP , SAT, SMT , F3D and STL  formats. To run this sample, have a design open and run the script. It will write out the translated files to
a temp directory , which will it show in a message box.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback, tempfile
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        design = app.activeProduct
        # Get the ExportManager from the active design.
        exportMgr = design.exportManager
        
        tmpDir = tempfile.gettempdir()
        # Create an IgesExportOptions object and do the export.
        igesOptions = exportMgr.createIGESExportOptions(tmpDir + '/test.igs')
        res = exportMgr.execute(igesOptions)
        
        # Create an STEPExportOptions object and do the export.
        stepOptions = exportMgr.createSTEPExportOptions(tmpDir+ '/test.step')
        res = exportMgr.execute(stepOptions)
        
        # Create a SATExportOptions object and do the export.
        satOptions = exportMgr.createSATExportOptions(tmpDir + '/test.sat')
        res = exportMgr.execute(satOptions)
        
        # Create a SMTExportOptions object and do the export.
        smtOptions = exportMgr.createSMTExportOptions(tmpDir + '/test.smt')
        res = exportMgr.execute(smtOptions)
        
        # Create a FusionArchiveExportOptions object and do the export.
        fusionArchivevOptions = exportMgr.createFusionArchiveExportOptions(tmpDir + '/test.f3d')
        res = exportMgr.execute(fusionArchivevOptions)
        ui.messageBox(f'Design exported to: {tmpDir}')
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

std::string getDllPath()
{
#if defined(_WINDOWS) || defined(_WIN32) || defined(_WIN64)
HMODULE hModule = NULL;
if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | 
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
(LPCSTR) &getDllPath, 
&hModule))
return "";
char winTempPath[2048];
::GetModuleFileNameA (hModule, winTempPath, 2048);
std::string strPath = winTempPath;
size_t stPos = strPath.rfind('\\');
return strPath.substr(0, stPos);
#else
Dl_info info;
dladdr((void*) getDllPath, &info);
std::string strPath = info.dli_fname;
int stPos = (int)strPath.rfind('/');
if(stPos != -1)
return strPath.substr(0, stPos);
else
return "";;
#endif
}
Import Manager  API Sample
Description
Demonstrates how to import dif ferent formats to Fusion document
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
import os.path, sys
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Get import manager
        importManager = app.importManager
        
        # Get iges import options
        igesFileName = 'C:\\APISampleImportNeutralIgs.igs'
        igesOptions = importManager.createIGESImportOptions(igesFileName)
        
        # Import iges file to new document
        importManager.importToNewDocument(igesOptions)
        
        # Get sat import options
        satFileName = 'C:\\APISampleImportNeutralSat.sat'
        satOptions = importManager.createSATImportOptions(satFileName)
        satOptions.isViewFit = False
        
        # Get active design
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # Get root component
        rootComp = design.rootComponent
        
        # Import sat file to root component
        importManager.importToTarget(satOptions, rootComp)
        
        # Get smt import options
        smtFileName = 'C:\\APISampleImportNeutralSmt.smt'
        smtOptions = importManager.createSMTImportOptions(smtFileName)
        smtOptions.isViewFit = False
        
        # Import smt file to root component
        importManager.importToTarget(smtOptions, rootComp)
        
        # Get step import options
        stpFileName = 'C:\\APISampleImportNeutralStp.stp'
        stpOptions = importManager.createSTEPImportOptions(stpFileName)
        stpOptions.isViewFit = False
        
        # Import step file to root component
        importManager.importToTarget(stpOptions, rootComp)
        #FUS-135845 since Linux doesn't have publish submodule at the moment.        #we need to disable createDXF2DImportOptions on Linux in ImportManager.py
        if sys.platform.startswith('Linux'):
            # Get dxf import options
            dxfFileName = 'C:\\APISampleImportNeutralDxf2D.dxf'
            dxfOptions = importManager.createDXF2DImportOptions(dxfFileName, rootComp.xZConstructionPlane)
            dxfOptions.isViewFit = False
            
            # Import dxf file to root component
            importManager.importToTarget(dxfOptions, rootComp)
            
            dxfOptions = importManager.createDXF2DImportOptions(dxfFileName, rootComp.xZConstructionPlane)
            dxfOptions.isViewFit = False
            # Set the flag true to merge all the layers of DXF into single sketch.
            dxfOptions.isSingleSketchResult = True
            
            # Import dxf file to root component
            importManager.importToTarget(dxfOptions, rootComp)
        # Get archive import options
        archiveFileName = 'C:\\APISampleImportNeutralF3d2.f3d'
        archiveOptions = importManager.createFusionArchiveImportOptions(archiveFileName)
        
        # Import archive file to root component
        importManager.importToTarget(archiveOptions, rootComp)
        
        # Close the new created document
        doc = app.activeDocument
        doc.close(False)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Use inputBox to get value and evaluateExpr ession to validate it
Description
Uses the UserInterface.inputBox function to get a string from the user and then validates that the strinng entered is a valid expression by using the UnitsManager .evaluateExpression
function.
Code Samples
C++
Python
Copy Code

--
#Author-
#Description-
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        design = app.activeProduct
        if not design:
            ui.messageBox('No active Fusion design', 'No Design')
            return
        # Prompt the user for a string and validate it's valid.
        isValid = False
        input = '1 in'  # The initial default value.
        while not isValid:
            # Get a string from the user.
            retVals = ui.inputBox('Enter a distance', 'Distance', input)
            if retVals[0]:
                (input, isCancelled) = retVals
            
            # Exit the program if the dialog was cancelled.
            if isCancelled:
                return
            
            # Check that a valid length description was entered.
            unitsMgr = design.unitsManager
            try:
                realValue = unitsMgr.evaluateExpression(input, unitsMgr.defaultLengthUnits)
                isValid = True
            except:
                # Invalid expression so display an error and set the flag to allow them
                # to enter a value again.
                ui.messageBox('"' + input + '" is not a valid length expression.', 'Invalid entry', 
                              adsk.core.MessageBoxButtonTypes.OKButtonType, 
                              adsk.core.MessageBoxIconTypes.CriticalIconType)
                isValid = False
                # Use the value for something.
        ui.messageBox('input: ' + input + ', result: ' + str(realValue))
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Measur e Sample
Description
Measure related functions
Code Samples
Python
C++
Copy Code
#Author-
#Description-
import adsk.core, adsk.fusion, adsk.cam, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Create a new document
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create a sketch
        sketches = rootComp.sketches
        sketch1 = sketches.add(rootComp.yZConstructionPlane)
        
        # Create sketch lines
        sketchLines = sketch1.sketchCurves.sketchLines
        
        # Create some 3D points
        point1 = adsk.core.Point3D.create(0.0, 0.0, 0.0)
        point2 = adsk.core.Point3D.create(5.0, 5.0, 0.0)
        
        # Create sketch rectangle
        sketchLines.addTwoPointRectangle(point1, point2)
        
        # Get the profile
        profile = sketch1.profiles.item(0)
        
        # Create an extusion input
        extrudes = rootComp.features.extrudeFeatures
        extrudeInput = extrudes.createInput(profile, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)     
        # Set extrude distance is 6 cm
        distance = adsk.core.ValueInput.createByReal(6.0)
        # Set the distance extent
        extrudeInput.setDistanceExtent(False, distance)
        # Set the extrude type is solid
        extrudeInput.isSolid = True
        
        # Create the extrude
        extrude = extrudes.add(extrudeInput)
        
        # Get the extrude brepbody
        brepBody = extrude.bodies.item(0)
          
        # Measure minimum distance
        print("*** Measure minimum distance.")
        sketchLine = sketchLines.item(0)
        brepEdge = brepBody.edges.item(0)
        measureResult = app.measureManager.measureMinimumDistance(sketchLine, brepEdge)
        minDistance = measureResult.value
        print('Minimum distance value is ' + str(minDistance))
        
        position1 = measureResult.positionOne
        position2 = measureResult.positionTwo
        print('positionOne is ('
              + str(position1.x) 
              + ',' 
              + str(position1.y) 
              + ',' 
              + str(position1.z)
              + ')'
             )
        print('positionTwo is ('
              + str(position2.x) 
              + ',' 
              + str(position2.y) 
              + ',' 
              + str(position2.z)               + ')'
             ) 
        
        # Measure angle for three point
        print("*** Measure angle for three point.")
        constructionPoint = rootComp.originConstructionPoint
        vertex = brepBody.vertices.item(0)
        measureResult = app.measureManager.measureAngle(constructionPoint, point2, vertex)
        angle = measureResult.value
        print('Angle value is ' + str(angle))
        
        position1 = measureResult.positionOne
        position2 = measureResult.positionTwo
        position3 = measureResult.positionThree
        print('positionOne is ('
              + str(position1.x) 
              + ',' 
              + str(position1.y) 
              + ',' 
              + str(position1.z)
              + ')'
             )
        print('positionTwo is ('
              + str(position2.x) 
              + ',' 
              + str(position2.y) 
              + ',' 
              + str(position2.z) 
              + ')'
             )       
        print('positionThree is ('
              + str(position3.x) 
              + ',' 
              + str(position3.y) 
              + ',' 
              + str(position3.z) 
              + ')'
             )  
        
        # Measure angle for two object
        print("*** Measure angle for two objects.")
        brepFace = brepBody.faces.item(1)
        brepEdge = brepBody.edges.item(0)
        measureResult = app.measureManager.measureAngle(brepFace, brepEdge)
        angle = measureResult.value
        print('Angle value is ' + str(angle))
        
        # Get oriented bounding box
        print("*** Get oriented bounding box.")
        vector1 = adsk.core.Vector3D.create(0.0, 0.0, 1.0)
        vector2 = adsk.core.Vector3D.create(0.0, 1.0, 0.0)
        boundingBox = app.measureManager.getOrientedBoundingBox(brepBody, vector1, vector2)
        
        # Get the bounding box length, width and height
        length = boundingBox.length
        print("Bounding box length is " + str(length))
        width = boundingBox.width
        print("Bounding box width is " + str(width))
        height = boundingBox.height
        print("Bounding box height is " + str(height))
        
        # Get the bounding box width direction 
        widthDirection = boundingBox.widthDirection
        heightDirection = boundingBox.heightDirection
        lengthDirection = boundingBox.lengthDirection
        print("Bounding box width direction is " 
              + "("
              + str(widthDirection.x)
              + ", "
              + str(widthDirection.y)
              + ", "
              + str(widthDirection.z)
              + ")"
             )
        
        # Get the bounding contain a point or not
        pointA= adsk.core.Point3D.create(-2.0, 0.5, 2.0)
        isContain = boundingBox.contains(pointA)
        print("Dose the bounding box contain pointA? " + str(isContain))
        
        pointB = adsk.core.Point3D.create(0.0, 0.0, 0.0)
        isContain = boundingBox.contains(pointB)
        print("Dose the bounding box contain pointB? " + str(isContain))
        
        # Copy the bounding box
        boundingBoxCopy = boundingBox.copy()
        length = boundingBoxCopy.length
        print("The copied Bounding box length is " + str(length))
             
        # Set bounding box height
        boundingBoxCopy.height = 10.0
        length = boundingBoxCopy.height
        print("The new set length of the copied bounding box is " + str(length))
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Save and Insert File API Sample
Description
Demonstrates creating save a new file and then inserting it into a design. To use this sample, have a design open that has been saved and run the script. It will create a new design that
contains a cylinder , save it to the same folder the active design was saved to, and then insert it into the active design.
Code Samples
PythonCopy Code
#Author-
#Description-
import adsk.core, adsk.fusion, adsk.cam, traceback
# Global variable used to maintain a reference to all event handlers.
handlers = []
_app = adsk.core.Application.get()
_ui  = _app.userInterface
newFilename = 'SampleSave'
_docId = ''
def run(context):
    try:
        # Check that the active document has been saved.
        doc = _app.activeDocument
        if not doc.isSaved:
            _ui.messageBox('The active document must be saved before running this script.')
            return
        parentFolder = doc.dataFile.parentFolder
        # Connect to the dataFileComplete event, to watch for when the file has been fully saved on Fusion Team.
        onDataFileComplete = MyDataFileCompleteHandler()
        _app.dataFileComplete.add(onDataFileComplete)
        handlers.append(onDataFileComplete)
        # Create a new design with a cylinder.
        newDoc = CreateCylinderDesign(parentFolder, newFilename)
        adsk.autoTerminate(False)
    except:
        _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
# Event handler for the dataFileComplete event.
class MyDataFileCompleteHandler(adsk.core.DataEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args: adsk.core.DataEventArgs):
        try:
            # Check to see if the document we care about is the one that saved.
            if args.file.name == newFilename:
                cylinderDoc = args.file
                
                topDoc = _app.activeDocument
                # Insert the saved document into the activate document.
                des: adsk.fusion.Design = topDoc.products.itemByProductType('DesignProductType')
                root = des.rootComponent
                cylOcc = root.occurrences.addByInsert(args.file, adsk.core.Matrix3D.create(), True)
                adsk.terminate()
        except:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
        
def CreateCylinderDesign(folder, filename):
    try:
        # Create a new document and have it be invisible.
        cylinderDoc: adsk.fusion.FusionDocument = _app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType, True)
        # Get the Design and root component from the document.
        des: adsk.fusion.Design = cylinderDoc.products.itemByProductType('DesignProductType')
        root = des.rootComponent
        # Create a sketch with a single circle.
        sk: adsk.fusion.Sketch = root.sketches.add(root.yZConstructionPlane)
        sk.sketchCurves.sketchCircles.addByCenterRadius(adsk.core.Point3D.create(3,2,0), 4)
        prof = sk.profiles[0]
        # Create an extrusion, using the circle.
        root.features.extrudeFeatures.addSimple(prof, adsk.core.ValueInput.createByReal(12), adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Save the document.
        cylinderDoc.saveAs(filename, folder, 'Sample demonstrating watching for the save to complete.', '')
        global _docId
        _docId = cylinderDoc.creationId
        cylinderDoc.close(False)
    except:
        _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
STLExport API Sample
Description
Demonstrates how to export f3d to STL  format.
Code Samples
PythonC++
--
import adsk.core, adsk.fusion, traceback
import os.path, sys
    
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        
        # get active design        
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # get root component in this design
        rootComp = design.rootComponent
        
        # create a single exportManager instance
        exportMgr = design.exportManager
        
        # export the root component to printer utility
        stlRootOptions = exportMgr.createSTLExportOptions(rootComp)
        # get all available print utilities
        printUtils = stlRootOptions.availablePrintUtilities
        # export the root component to the print utility, instead of a specified file            
        for printUtil in printUtils:
            stlRootOptions.sendToPrintUtility = True
            stlRootOptions.printUtility = printUtil
            exportMgr.execute(stlRootOptions)
            
        # get the script location
        scriptDir = os.path.dirname(os.path.realpath(__file__))  
        
        # export the occurrence one by one in the root component to a specified file
        allOccu = rootComp.allOccurrences
        for occ in allOccu:
            fileName = scriptDir + "/" + occ.component.name
            
            # create stl exportOptions
            stlExportOptions = exportMgr.createSTLExportOptions(occ, fileName)
            stlExportOptions.sendToPrintUtility = False
            
            exportMgr.execute(stlExportOptions)
        # export the body one by one in the design to a specified file
        allBodies = rootComp.bRepBodies
        for body in allBodies:
            fileName = scriptDir + "/" + body.parentComponent.name + '-' + body.name
            
            # create stl exportOptions
            stlExportOptions = exportMgr.createSTLExportOptions(body, fileName)
            stlExportOptions.sendToPrintUtility = False
            
            exportMgr.execute(stlExportOptions)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code
std::string getDllPath()
{
#if defined(_WINDOWS) || defined(_WIN32) || defined(_WIN64)
HMODULE hModule = NULL;
if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | 
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
(LPCSTR) &getDllPath, 
&hModule))
return "";
char winTempPath[2048];
::GetModuleFileNameA (hModule, winTempPath, 2048);
std::string strPath = winTempPath;
size_t stPos = strPath.rfind('\\');
return strPath.substr(0, stPos);
#else
Dl_info info;
dladdr((void*) getDllPath, &info);
std::string strPath = info.dli_fname;
int stPos = (int)strPath.rfind('/');
if(stPos != -1)
return strPath.substr(0, stPos);
else
return "";;
#endif
}
Set parameters fr om a csv file and export to STEP
Description
Reads data from a .csv file and sets user parameters in the model and then exports the model to STEP . When setting parameters be aware that this sample is setting user parameters. It's also
possible to set model parameters but that's not demonstrated here. Also when accessing parameters, it is case sensitive so the names you use in your program much exactly match the names
in the model.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        design = app.activeProduct
        # Read the csv file.
        cnt = 0
        file = open('C://Temp//values.csv')
        for line in file:
            # Get the values from the csv file.
            pieces = line.split(',')
            
            length = pieces[0]
            width = pieces[1]
            height = pieces[2]
            
            # Set the parameters.
            lengthParam = design.userParameters.itemByName('Length')
            lengthParam.expression = length
            
            widthParam = design.userParameters.itemByName('Width')
            widthParam.expression = width
            heightParam = design.userParameters.itemByName('Height')
            heightParam.expression = height
            
            #Export the STEP file.
            exportMgr = design.exportManager
            stepOptions = exportMgr.createSTEPExportOptions('C:\\Temp\\test_ box' + str(cnt) + '.stp')
            cnt += 1
            res = exportMgr.execute(stepOptions)
        
        ui.messageBox('Finished')
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

return strTempPath;
}
extern "C" XI_EXPORT bool run(const char* context)
{
Ptr<Application> app = Application::get();
if (!app)
return false;
ui = app->userInterface();
if (!ui)
return false;
// Read the csv file.
int cnt = 0;
DataSet dataSet;
loadCSVFile("C:\\Temp\\values.csv", dataSet);
for (auto data : dataSet)
{
// Get the values from the csv file.
std::string length = data.at(0);
std::string width = data.at(1);
std::string height = data.at(2);
// Set the parameters.
Ptr<UserParameters> userParams = design->userParameters();
if (!userParams)
return false;
Ptr<UserParameter> lengthParam = userParams->itemByName("Length");
if (!lengthParam)
return false;
lengthParam->expression(length);
Ptr<UserParameter> widthParam = userParams->itemByName("Width");
if (!widthParam)
return false;
widthParam->expression(width);
Ptr<UserParameter> heightParam = userParams->itemByName("Height");
if (!heightParam)
return false;
heightParam->expression(height);
// Export the STEP file.
Ptr<ExportManager> exportMgr = design->exportManager();
if (!exportMgr)
return false;
std::string filename = "C:\\Temp\\test_box" + std::to_string(cnt) + ".stp";
Ptr<STEPExportOptions> stepOptions = exportMgr->createSTEPExportOptions(filename);
if (!stepOptions)
return false;
++cnt;exportMgr->execute(stepOptions);
}
return true;
}
#ifdef XI_WIN

Material API Sample
Description
Demonstrates using materials and appearance using the API.
To use the sample, create a new Python or C++ script and copy and paste this code, replacing the default code. The sample also used an external appearance library which you can get here.
Copy that to any location on your computer and edit the path in the script. When running the script, have a design open that contains a body in the root component.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Load a local material library. You'll need to edit the path to the libary.
        materialLibs = app.materialLibraries
        matLib = materialLibs.load('C:/Temp//APISampleMaterialLibrary2.adsklib')
        # Get the first appearance from the library.
        appear = matLib.appearances.item(0)
        # Copy the appearance into the design.
        des = adsk.fusion.Design.cast(app.activeProduct)             
        appear = des.appearances.addByCopy(appear, f'{appear.name}_Copied')
        
        # Apply the appearance to the first body in the design.
        root = des.rootComponent
        body = root.bRepBodies.item(0)
        body.appearance = appear
        
        # Unload the library.
        if matLib.isNative == False:
            matLib.unload()       
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Create cir cle by center  and radius API Sample
Description
Demonstrates creating a sketch circle by the center and radius.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a new sketch on the xy plane.
        sketches = rootComp.sketches
        xyPlane = rootComp.xYConstructionPlane
        sketch = sketches.add(xyPlane)
        # Draw some circles.
        circles = sketch.sketchCurves.sketchCircles
        circle1 = circles.addByCenterRadius(adsk.core.Point3D.create(0, 0, 0), 2)
        circle2 = circles.addByCenterRadius(adsk.core.Point3D.create(8, 3, 0), 3)        # Add a circle at the center of one of the existing circles.
        circle3 = circles.addByCenterRadius(circle2.centerSketchPoint, 4)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Create Cir cle By 3 Tangents API Sample
Description
Creates three lines and then draws a circle that is tangent to the lines. It then creates tangent constraints to maintain that relationship.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try: 
        app = adsk.core.Application.get()
        ui = app.userInterface
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a new sketch on the xy plane.
        sketches = rootComp.sketches;
        xyPlane = rootComp.xYConstructionPlane
        sketch = sketches.add(xyPlane)
        # Draw three lines.
        lines = sketch.sketchCurves.sketchLines;
        line1 = lines.addByTwoPoints(adsk.core.Point3D.create(0, 0, 0), adsk.core.Point3D.create(3, 1, 0))
        line2 = lines.addByTwoPoints(adsk.core.Point3D.create(4, 3, 0), adsk.core.Point3D.create(2, 4, 0))
        line3 = lines.addByTwoPoints(adsk.core.Point3D.create(-1, 0, 0), adsk.core.Point3D.create(0, 4, 0))
        # Draw circle tangent to the lines.
        circles = sketch.sketchCurves.sketchCircles
        circle1 = circles.addByThreeTangents(line1, line2, line3, adsk.core.Point3D.create(0,0,0))
        # Apply tangent contstraints to maintain the relationship.
        constraints = sketch.geometricConstraints
        constraints.addTangent(circle1, line1)
        constraints.addTangent(circle1, line2)
        constraints.addTangent(circle1, line3)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

API Sample that demonstrates cr eating sketch lines in various ways.
Description
Demonstrates several ways to create sketch lines, including as the result of creating a rectangle.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try: 
        app = adsk.core.Application.get()        ui = app.userInterface
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a new sketch on the xy plane.
        sketches = rootComp.sketches;
        xyPlane = rootComp.xYConstructionPlane
        sketch = sketches.add(xyPlane)
        # Draw two connected lines.
        lines = sketch.sketchCurves.sketchLines;
        line1 = lines.addByTwoPoints(adsk.core.Point3D.create(0, 0, 0), adsk.core.Point3D.create(3, 1, 0))
        line2 = lines.addByTwoPoints(line1.endSketchPoint, adsk.core.Point3D.create(1, 4, 0))
        # Draw a rectangle by two points.
        recLines = lines.addTwoPointRectangle(adsk.core.Point3D.create(4, 0, 0), adsk.core.Point3D.create(7, 2, 0))
        # Use the returned lines to add some constraints.
        sketch.geometricConstraints.addHorizontal(recLines.item(0))
        sketch.geometricConstraints.addHorizontal(recLines.item(2))
        sketch.geometricConstraints.addVertical(recLines.item(1))
        sketch.geometricConstraints.addVertical(recLines.item(3))
        sketch.sketchDimensions.addDistanceDimension(recLines.item(0).startSketchPoint, recLines.item(0).endSketchPoint,
                                                     adsk.fusion.DimensionOrientations.HorizontalDimensionOrientation,
                                                     adsk.core.Point3D.create(5.5, -1, 0));
        # Draw a rectangle by three points.
        recLines = lines.addThreePointRectangle(adsk.core.Point3D.create(8, 0, 0), adsk.core.Point3D.create(11, 1, 0), adsk.core.Point3D.create(9, 3, 0))
        # Draw a rectangle by a center point.
        recLines = lines.addCenterPointRectangle(adsk.core.Point3D.create(14, 3, 0), adsk.core.Point3D.create(16, 4, 0))
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Project To Surface API Sample
Description
Projects the specified set of curves onto the specified set of faces using the specified method of projection.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        allOccs = rootComp.occurrences
        transform = adsk.core.Matrix3D.create()
        
        # Create three components under root component
        occ1 = allOccs.addNewComponent(transform)        subComp1 = occ1.component
        occ2 = allOccs.addNewComponent(transform)
        subComp2 = occ2.component
        occ3 = allOccs.addNewComponent(transform)
        subComp3 = occ3.component
      
        # Create a sketch in sub component 1
        sketches1 = subComp1.sketches
        sketch1 = sketches1.add(rootComp.yZConstructionPlane)
        
        # Get sketch lines
        sketchLines = sketch1.sketchCurves.sketchLines
        
        # Create sketch rectangle
        startPoint = adsk.core.Point3D.create(-8.0, 0, 0)
        endPoint = adsk.core.Point3D.create(8.0, 8.0, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        
        # Get the profile of the first sketch
        prof1 = sketch1.profiles.item(0)
        
        # Create an extrusion input
        extrudes1 = subComp1.features.extrudeFeatures
        extInput1 = extrudes1.createInput(prof1, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 2 cm
        distance1 = adsk.core.ValueInput.createByReal(2.0)
        # Set the distance extent
        extInput1.setDistanceExtent(False, distance1)
        # Set the extrude type to be solid
        extInput1.isSolid = True
        
        # Create the extrusion
        ext1 = extrudes1.add(extInput1)
        
        # Create construction plane
        planes = rootComp.constructionPlanes
        planeInput = planes.createInput()
        offsetValue = adsk.core.ValueInput.createByReal(8.0)
        planeInput.setByOffset(rootComp.yZConstructionPlane, offsetValue)
        plane = planes.add(planeInput)
         # Create a sketch in sub component 2
        sketches2 = subComp2.sketches
        sketch2 = sketches2.add(plane)
        
        # Create the spline.
        points = adsk.core.ObjectCollection.create()
        points.add(adsk.core.Point3D.create(0, 8, 0))
        points.add(adsk.core.Point3D.create(5, 6, 0))
        points.add(adsk.core.Point3D.create(-5, 5, 0))
        
        sketch2Curves = sketch2.sketchCurves
        spline = sketch2Curves.sketchFittedSplines.add(points)
        
        # Create sketch rectangle
        sketch2Lines = sketch2Curves.sketchLines
        startPoint2 = adsk.core.Point3D.create(-4, 2, 0)
        endPoint2 = adsk.core.Point3D.create(3, 4, 0)
        sketch2Lines.addTwoPointRectangle(startPoint2, endPoint2)
        
        # Get the profile of the second sketch
        prof2 = sketch2.profiles.item(0)
        
        # Create an extrusion input       
        extrudes2 = subComp2.features.extrudeFeatures
        extInput2 = extrudes2.createInput(prof2, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 2 cm
        extent_distance_2 = adsk.fusion.DistanceExtentDefinition.create(adsk.core.ValueInput.createByString("2cm"))
        # Define that the taple angle is 10 degree
        deg10 = adsk.core.ValueInput.createByString("10 deg")
        extInput2.setOneSideExtent(extent_distance_2, adsk.fusion.ExtentDirections.PositiveExtentDirection, deg10)
        
        # Set the extrude type to be solid
        extInput2.isSolid = True
        # Create the extrusion
        ext2 = extrudes2.add(extInput2)
        
        # Get the body with the first extrude
        body = ext1.bodies.item(0)
        
        # Get faces
        faceList = []
        for face in body.faces:
            faceList.append(face)
        # Get curves
        curveList = []
        for curve in sketch2Curves:
            curveList.append(curve)
        
        # Get points
        for point in sketch2.sketchPoints:
            curveList.append(point)
        
        # Get the body with the second extrude
        body2 = ext2.bodies.item(0)
        
        # Get eges
        for edge in body2.edges:
            curveList.append(edge)
                # Get construction axis
        curveList.append(rootComp.yConstructionAxis)
        
        # Get construction point
        curveList.append(rootComp.originConstructionPoint)
        
        sketches3 = subComp3.sketches
        # Create a sketch in sub component 3
        skAlongVecProject = sketches3.add(rootComp.yZConstructionPlane)
        # sketch project to surface (along vector)
        projectedEntities = skAlongVecProject.projectToSurface(faceList, curveList, adsk.fusion.SurfaceProjectTypes.AlongVectorSurfaceProjectType, rootComp.xConstructionAx
        projectedEntities = []
        # Create a sketch in sub component 3
        skClosestPtProject = sketches3.add(rootComp.yZConstructionPlane)
        # sketch project to surface (closest point)
        projectedEntities = skClosestPtProject.projectToSurface(faceList, curveList, adsk.fusion.SurfaceProjectTypes.ClosestPointSurfaceProjectType)
        
    except:
        if ui:
            
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Sketch Chamfer  API Sample
Description
Demonstrates creating a new sketch point.
Code Samples
Python
--
#Author-Autodesk Inc. 
#Description-Create a sketch chamfer
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a new sketch on the xy plane.
        sketches = rootComp.sketches
        xyPlane = rootComp.xYConstructionPlane
        sketch = sketches.add(xyPlane)
        # Draw two point rectangle.
        lines = sketch.sketchCurves.sketchLines        lineList = lines.addTwoPointRectangle(adsk.core.Point3D.create(0, 0, 0), adsk.core.Point3D.create(5, 5, 0))
        
        # Add a distance distance chamfer.
        line = sketch.sketchCurves.sketchLines.addDistanceChamfer(lineList[0], lineList[0].endSketchPoint.geometry, lineList[1], lineList[1].startSketchPoint.geometry, 1,1
        
        # Add a distance angle chamfer.
        line = sketch.sketchCurves.sketchLines.addAngleChamfer(lineList[1], lineList[1].endSketchPoint.geometry, lineList[2], lineList[2].startSketchPoint.geometry, 1,1)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Sketch fillet and offset API Sample
Description
Demonstrates the creation of a fillet in a sketch and of fset a set of curves.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a new sketch on the xy plane.
        sketches = rootComp.sketches
        xyPlane = rootComp.xYConstructionPlane
        sketch = sketches.add(xyPlane)
        # Draw two connected lines.
        lines = sketch.sketchCurves.sketchLines
        line1 = lines.addByTwoPoints(adsk.core.Point3D.create(0, 0, 0), adsk.core.Point3D.create(3, 1, 0))
        line2 = lines.addByTwoPoints(line1.endSketchPoint, adsk.core.Point3D.create(1, 4, 0))
        
        # Add a fillet.
        arc = sketch.sketchCurves.sketchArcs.addFillet(line1, line1.endSketchPoint.geometry, line2, line2.startSketchPoint.geometry, 1)
        # Add the geometry to a collection. This uses a utility function that
        # automatically finds the connected curves and returns a collection.
        curves = sketch.findConnectedCurves(line1)
               
        # Create the offset.
        dirPoint = adsk.core.Point3D.create(0, .5, 0)
        offsetCurves = sketch.offset(curves, dirPoint, 0.25)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Sketch Intersect API Sample
Description
Intersects the specified entities with the sketch plane and creates sketch geometry that represents the intersection.Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create a sketch
        sketches = rootComp.sketches
        sketch1 = sketches.add(rootComp.yZConstructionPlane)
        
        # Create an object collection for the points.
        points = adsk.core.ObjectCollection.create()
        # Define the points the spline with fit through.
        points.add(adsk.core.Point3D.create(-5, 0, 0))
        points.add(adsk.core.Point3D.create(5, 1, 0))
        points.add(adsk.core.Point3D.create(6, 4, 3))
        points.add(adsk.core.Point3D.create(7, 6, 6))
        points.add(adsk.core.Point3D.create(2, 3, 0))
        points.add(adsk.core.Point3D.create(0, 1, 0))
        # Create the spline.
        spline = sketch1.sketchCurves.sketchFittedSplines.add(points)
    
        # Get sketch lines
        sketchLines = sketch1.sketchCurves.sketchLines
        
        # Create sketch rectangle
        startPoint = adsk.core.Point3D.create(0, 0, 0)
        endPoint = adsk.core.Point3D.create(5.0, 5.0, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        
        # Get two sketch lines
        sketchLineOne = sketchLines.item(0)
        sketchLineTwo = sketchLines.item(1)
        
        # Get the profile
        prof = sketch1.profiles.item(0)
        
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5.0)
        # Set the distance extent
        extInput.setDistanceExtent(False, distance)
        # Set the extrude type to be solid
        extInput.isSolid = True
        
        # Create the extrusion
        ext = extrudes.add(extInput)
   
        # Get the body with the extrude
        body = ext.bodies.item(0)
        
        # Get a vertex of the body
        vertex = body.vertices.item(5)
        
        # Get a face of the vertex
        face = vertex.faces.item(0)
        
        # Create perpendicular construction axis
        axes = rootComp.constructionAxes
        axisInput = axes.createInput()
        axisInput.setByPerpendicularAtPoint(face, vertex)
        axis = axes.add(axisInput)
        
         # Create construction point
        points = rootComp.constructionPoints
        pointInput = points.createInput()
        pointInput.setByTwoEdges(sketchLineOne, sketchLineTwo)
        point = points.add(pointInput)
        
        # Create construction plane
        planes = rootComp.constructionPlanes
        planeInput = planes.createInput()
        offsetValue = adsk.core.ValueInput.createByReal(3.0)
        planeInput.setByOffset(prof, offsetValue)
        plane = planes.add(planeInput)
        
        # Create another sketch
        sketch2 = sketches.add(rootComp.xZConstructionPlane)
        
        entities = []        entities.append(body) # body
        entities.append(face) # face
        entities.append(sketchLineOne) # edge 
        entities.append(vertex) # vertex
        entities.append(spline) # sketch curve
        entities.append(axis) # construction axis
        entities.append(point) # construction point
        entities.append(plane) # construction plane
        sketchEntities = sketch2.intersectWithSketchPlane(entities)
        
    except:
        if ui:
            
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Sketch Point API Sample
Description
Demonstrates creating a new sketch point.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try: 
        app = adsk.core.Application.get()
        ui = app.userInterface
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent        # Create a new sketch on the xy plane.
        sketches = rootComp.sketches;
        xyPlane = rootComp.xYConstructionPlane
        sketch = sketches.add(xyPlane)
        
        # Get sketch health state
        health = sketch.healthState
        if health == adsk.fusion.FeatureHealthStates.ErrorFeatureHealthState or health == adsk.fusion.FeatureHealthStates.WarningFeatureHealthState:        
            msg = sketch.errorOrWarningMessage
        # Get sketch points
        sketchPoints = sketch.sketchPoints
        
        # Create sketch point
        point = adsk.core.Point3D.create(1.0, 1.0, 0)
        sketchPoint = sketchPoints.add(point)
        
        # Move sketch point
        translation = adsk.core.Vector3D.create(1.0, 0, 0)
        sketchPoint.move(translation)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Sketch Sample API Sample
Description
Sketch related functions
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create a sketch
        sketches = rootComp.sketches
        sketch1 = sketches.add(rootComp.yZConstructionPlane)
        print(sketch1.revisionId)
        # Create an object collection for the points.
        points = adsk.core.ObjectCollection.create()
        # Define the points the spline with fit through.
        points.add(adsk.core.Point3D.create(-5, 0, 0))
        points.add(adsk.core.Point3D.create(5, 1, 0))
        points.add(adsk.core.Point3D.create(6, 4, 3))
        points.add(adsk.core.Point3D.create(7, 6, 6))
        points.add(adsk.core.Point3D.create(2, 3, 0))
        points.add(adsk.core.Point3D.create(0, 1, 0))
        # Create the spline.
        spline = sketch1.sketchCurves.sketchFittedSplines.add(points)
        print(sketch1.revisionId)
        # Get sketch lines
        sketchLines = sketch1.sketchCurves.sketchLines
        # Create sketch rectangle
        startPoint = adsk.core.Point3D.create(0, 0, 0)
        endPoint = adsk.core.Point3D.create(5.0, 5.0, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        print(sketch1.revisionId)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Sketch spline thr ough points cr eation and r elative functions API Sample
Description
Create a sketch spline with points and use some operations for spline tangent handle & curvature handle.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try: 
        app = adsk.core.Application.get()
        ui = app.userInterface
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a new sketch on the xy plane.
        sketch = rootComp.sketches.add(rootComp.xYConstructionPlane)
        # Create an object collection for the points.
        points = adsk.core.ObjectCollection.create()
        # Define the points the spline with fit through.
        points.add(adsk.core.Point3D.create(0, 0, 0))
        points.add(adsk.core.Point3D.create(5, 1, 0))
        points.add(adsk.core.Point3D.create(6, 4, 3))
        points.add(adsk.core.Point3D.create(7, 6, 6))
        points.add(adsk.core.Point3D.create(2, 3, 0))
        points.add(adsk.core.Point3D.create(0, 1, 0))
        # Create the spline.
        spline = sketch.sketchCurves.sketchFittedSplines.add(points)
        # Get spline fit points
        fitPoints = spline.fitPoints
        
        # Get the second fit point
        fitPoint = fitPoints.item(1)
        
        # If there is no the relative tangent handle, activate the tangent handle
        line = spline.getTangentHandle(fitPoint)
        if line is None:
             line = spline.activateTangentHandle(fitPoint)
                
        # Get the tangent handle           
        gottenLine = spline.getTangentHandle(fitPoint)
        
        # Delete the tangent handle
        gottenLine.deleteMe()
        # Activate the curvature handle
        # If the curvature handle activated. the relative tangentHandle is activated automatically
        activatedArc= spline.activateCurvatureHandle(fitPoint)
        
        # Get curvature handle and tangent handle
        gottenArc= spline.getCurvatureHandle(fitPoint)
        gottenLine = spline.getTangentHandle(fitPoint)
        
        # Delete curvature handle
        gottenArc.deleteMe();
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--
Sketch Text API Sample
Description
Demonstrates creating sketch text by creating both mult-line text and text along a curve.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try: 
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a new document and get the Design.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a new sketch on the XY construction plane.
        sk = rootComp.sketches.add(rootComp.xYConstructionPlane)
        # Get the SketchTexts collection object.
        texts = sk.sketchTexts        # Add multi-line text.
        input = texts.createInput2('This is a long line that is broken automatically.\n\nAnd this is a defined line break.', 0.5)
        input.setAsMultiLine(adsk.core.Point3D.create(0, 0, 0),
                             adsk.core.Point3D.create(10, 5, 0),
                             adsk.core.HorizontalAlignments.LeftHorizontalAlignment,
                             adsk.core.VerticalAlignments.TopVerticalAlignment, 0)
        texts.add(input)
        # Draw an arc to use to create text along a curve.
        arc = sk.sketchCurves.sketchArcs.addByThreePoints(adsk.core.Point3D.create(-10, 0, 0),
                                                          adsk.core.Point3D.create(-5, 3, 0),
                                                          adsk.core.Point3D.create(0, 0, 0))
        # Create text along the arc.
        input = texts.createInput2('Text Along a Curve', 0.75)
        input.setAsAlongPath(arc, False, adsk.core.HorizontalAlignments.CenterHorizontalAlignment, 0)
        input.isHorizontalFlip = True
        input.isVerticalFlip = True
        input.fontName = 'Comic Sans MS'
        texts.add(input)        
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

BaseFeatur e Sample
Description
Creates a new base feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try: 
        app = adsk.core.Application.get()
        ui = app.userInterface
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        design.designType = adsk.fusion.DesignTypes.ParametricDesignType
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a base feature
        baseFeats = rootComp.features.baseFeatures
        baseFeat = baseFeats.add()
        
        baseFeat.startEdit()
        
        # Create construction plane in base feature
        planes = rootComp.constructionPlanes
        planeInput = planes.createInput()
        planeInput.targetBaseOrFormFeature = baseFeat
        planeInput.setByOffset(rootComp.xYConstructionPlane, adsk.core.ValueInput.createByReal(1))
        plane = planes.add(planeInput)
        
        # Create sketch in base feature
        sketches = rootComp.sketches
        sketch = sketches.addToBaseOrFormFeature(plane, baseFeat, True)        # Draw a circle.
        circles = sketch.sketchCurves.sketchCircles
        circles.addByCenterRadius(adsk.core.Point3D.create(0, 0, 0), 2)
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        # Create an extrusion input to be able to define the input needed for an extrusion
        # while specifying the profile and that a new component is to be created
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Define that the extent is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        extInput.baseFeature = baseFeat
        # Create the extrusion.
        ext = extrudes.add(extInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Boss Featur e Sample
Description
Demonstrates creating a new boss feature
Code SamplesPython
Copy Code
import adsk.core, adsk.fusion, traceback, math
# Get the Application object.
app = adsk.core.Application.get()
def createBoss():
    ui = None
    # Get various top-level Fusion objects.
    ui = app.userInterface
    root = app.activeProduct.rootComponent
    # Select sketch point for boss location        
    selection = ui.selectEntity("Select Sketch Point", "SketchPoints")
    sp = selection.entity
    
    #Create the BossFeatureInput object
    bosses = root.features.bossFeatures
    input = bosses.createInput()
    input.setPositionBySketchPoints(sp)
    draftAng = adsk.core.ValueInput.createByReal(math.pi/90) #draft angle (2 deg)
    holeDraftAng = adsk.core.ValueInput.createByReal(math.pi/180) #draft angle (1 deg)
    
    #set top side inputs
    top = input.createSideInput()
    top.setCountersink(
        adsk.core.ValueInput.createByReal(1.3),
        adsk.core.ValueInput.createByReal(0.5),
        adsk.core.ValueInput.createByReal(0.9),
        adsk.core.ValueInput.createByReal(.3))
    top.draftAngle = draftAng
    top.holeDraftAngle = holeDraftAng
    top.holeMajorDraftAngle = draftAng
    top.rootRadius = adsk.core.ValueInput.createByReal(0.1)
    top.tipRadius = adsk.core.ValueInput.createByReal(0.05)    
    #set alignment properties
    top.alignmentType = adsk.fusion.BossAlignmentTypes.BossAlignStepIn
    top.alignmentDiameter = adsk.core.ValueInput.createByReal(0.9)
    top.alignmentDepth = adsk.core.ValueInput.createByReal(0.1)
    top.alignmentRootRadius = top.tipRadius 
    top.alignmentDraftAngle = draftAng
    #set top rib properties
    top.ribCount = adsk.core.ValueInput.createByReal(4)
    top.ribType = adsk.fusion.BossRibShapeTypes.BossRibShapeChamfer
    top.ribLength = adsk.core.ValueInput.createByReal(1.3)
    top.ribThickness = adsk.core.ValueInput.createByReal(0.2)
    top.ribOffset = adsk.core.ValueInput.createByReal(0.7)
    top.ribCutSize = adsk.core.ValueInput.createByReal(0.5)
    top.ribChamferAngle = adsk.core.ValueInput.createByReal(math.pi/3)
    top.ribOuterDraftAngle = adsk.core.ValueInput.createByReal(math.pi/18)
    top.ribDraftAngle = draftAng
    top.ribTipRadius =  adsk.core.ValueInput.createByReal(0.05)
    top.ribRootRadius = adsk.core.ValueInput.createByReal(0.05)
    #set individual rib extent type for the selected point
    top.setRibExtent(sp,[
        adsk.fusion.BossRibExtentTypes.RibSizeByLength,
        adsk.fusion.BossRibExtentTypes.RibSizeToNext,
        adsk.fusion.BossRibExtentTypes.RibSuppressed,
        adsk.fusion.BossRibExtentTypes.RibSizeByLength
    ])
    
    #set bottom side inputs
    bottom = input.createSideInput()
    bottom.setCounterbore(
        top.alignmentDiameter,
        adsk.core.ValueInput.createByReal(.3),
        adsk.core.ValueInput.createByReal(.5),
        adsk.core.ValueInput.createByReal(.1))
    bottom.tipRadius = top.alignmentRootRadius    
    bottom.holeMajorRootRadius = adsk.core.ValueInput.createByReal(0.05)
    bottom.holeExtentType = adsk.fusion.BossHoleExtentTypes.BossBlindFull
    bottom.holeDepth = adsk.core.ValueInput.createByReal(.3)
    bottom.holeEndRadius = adsk.core.ValueInput.createByReal(.05)
    bottom.draftAngle = draftAng
    bottom.holeDraftAngle = holeDraftAng
    bottom.rootRadius = adsk.core.ValueInput.createByReal(0.1)
    #set bottom rib properties
    bottom.ribCount = adsk.core.ValueInput.createByReal(3)
    bottom.ribType = adsk.fusion.BossRibShapeTypes.BossRibShapeFillet
    bottom.ribOffset = adsk.core.ValueInput.createByReal(0.7)
    bottom.ribLength = adsk.core.ValueInput.createByReal(0.8)
    bottom.ribCutSize = adsk.core.ValueInput.createByReal(0.5)
    bottom.ribThickness = top.ribThickness
    bottom.ribDraftAngle = draftAng
    bottom.ribOuterDraftAngle = top.ribOuterDraftAngle
    bottom.ribTipRadius =  adsk.core.ValueInput.createByReal(0.05)
    bottom.ribRootRadius = adsk.core.ValueInput.createByReal(0.05)
    input.side1 = top
    input.side2 = bottom
    # Create the boss.        
    bosses.add(input)
    
def run(context):    try:
        createBoss()
    except:
        app.log('AddIn Start Failed:\n{}'.format(traceback.format_exc()))
def stop(context):
    try:
        pass
    except:
        app.log('AddIn Stop Failed: {}'.format(traceback.format_exc()))
Boundary Fill Featur e API Sample
Description
Demonstrates creating a new boundary fill feature.
Code Samples
Python
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Get active design        
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # Get root component in this design
        rootComp = design.rootComponent   
        
        # Prepare tools to create boundary fill
        # Two bodies and one workplane are needed
        tools = adsk.core.ObjectCollection.create()
        tools.add(rootComp.bRepBodies.item(0))
        tools.add(rootComp.bRepBodies.item(1))
        tools.add(rootComp.constructionPlanes.item(0))
        
        # Create input
        boundaryFills = rootComp.features.boundaryFillFeatures
        boundaryFillInput = boundaryFills.createInput(tools, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Boundary fill will be created in sub component
        boundaryFillInput.creationOccurrence = rootComp.occurrences.item(0)
        
        # Specify which cell is kept
        cell = boundaryFillInput.bRepCells.item(0)
        cell.isSelected = True
        
        # Create the boundary fill
        boundaryFills.add(boundaryFillInput)      
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
CircularPattern Featur e API Sample
Description
Demonstrates creating a new circular pattern feature.
Code Samples
Python
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType) 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(10, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 3.0)
        
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        # Create the extrusion.
        ext = extrudes.add(extInput)
        
        # Get the body created by extrusion
        body = rootComp.bRepBodies.item(0)
        
        # Create input entities for circular pattern
        inputEntites = adsk.core.ObjectCollection.create()
        inputEntites.add(body)
        
        # Get Y axis for circular pattern
        yAxis = rootComp.yConstructionAxis
        
        # Create the input for circular pattern
        circularFeats = rootComp.features.circularPatternFeatures
        circularFeatInput = circularFeats.createInput(inputEntites, yAxis)
        
        # Set the quantity of the elements
        circularFeatInput.quantity = adsk.core.ValueInput.createByReal(5)
        
        # Set the angle of the circular pattern
        circularFeatInput.totalAngle = adsk.core.ValueInput.createByString('180 deg')
        
        # Set symmetry of the circular pattern
        circularFeatInput.isSymmetric = False
        
        # Create the circular pattern
        circularFeat = circularFeats.add(circularFeatInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Constant Radius Fillet API Sample
Description
Creates a constant radius fillet on the selected edge. If there are tangent contiguous edges that will also be included in the fillet.
Code Samples
C++
Python
--

Copy Code
import adsk.core, adsk.fusion, traceback
def createFillet():
    ui = None
    try:
        # Get the Application object.
        app = adsk.core.Application.get()
        # Get various top-level Fusion objects.
        ui  = app.userInterface
        design = app.activeProduct
        root = design.rootComponent
        # Have the edge selected and add it to an ObjectCollection.        
        selection = ui.selectEntity("Select edge to fillet", "Edges")
        edge = selection.entity
        edgeCollection = adsk.core.ObjectCollection.create()
        edgeCollection.add(edge)
        
        # Create the FilletInput object.
        fillets = root.features.filletFeatures
        filletInput = fillets.createInput()      
        filletInput.addConstantRadiusEdgeSet(edgeCollection, adsk.core.ValueInput.createByString('.25 in'), True)
        # Create the fillet.        
        fillet = fillets.add(filletInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
    
def main():
    createFillet()
main()Copy Paste Bodies API Sample
Description
Demonstrates how to use Copy Paste Bodies related API.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Get active design
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
 
        # Get root component in this design
        rootComp = design.rootComponent
        # Get the first sub component
        occs = rootComp.occurrences
        subComp1 = occs.item(0).component
        # Get the second sub component
        subComp2 = occs.item(1).component
        # Get the first body in sub component 1  
        bodyInSubComp1 = subComp1.bRepBodies.item(0)
        
        # Copy/paste body from sub component 1 to sub component 2
        copyPasteBody = subComp2.features.copyPasteBodies.add(bodyInSubComp1)
        
        # Copy/paste bodies from sub component to root component
        sourceBodies = adsk.core.ObjectCollection.create()
        for body in copyPasteBody.sourceBody:
            sourceBodies.add(body)
        for body in subComp2.bRepBodies:
            sourceBodies.add(body)
            
        rootComp.features.copyPasteBodies.add(sourceBodies)
        
        # Dump the information of Copy Paste Body in root component
        for copyPasteBody in rootComp.features.copyPasteBodies:
            copyPasteBodyInfo = 'CopyPasteBody: name - {}'.format(copyPasteBody.name)
            ui.messageBox(copyPasteBodyInfo)
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Cut Paste Bodies API Sample
Description
Demonstrates how to use Cut Paste Bodies related API.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Get active design
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
 
        # Get root component in this design
        rootComp = design.rootComponent
        # Get the first sub component
        occs = rootComp.occurrences
        subComp1 = occs.item(0).component
        # Get the second sub component
        subComp2 = occs.item(1).component
        # Get the first body in sub component 1  
        bodyInSubComp1 = subComp1.bRepBodies.item(0)
        
        # Cut/paste body from sub component 1 to sub component 2
        cutPasteBody = subComp2.features.cutPasteBodies.add(bodyInSubComp1)
        
        # Cut/paste bodies from sub component2 to root component
        sourceBodies = adsk.core.ObjectCollection.create()
        for body in subComp2.bRepBodies:
            sourceBodies.add(body)
            
        rootComp.features.cutPasteBodies.add(sourceBodies)
        
        # Dump the information of Cut Paste Body in root component
        for cutPasteBody in rootComp.features.cutPasteBodies:
            cutPasteBodyInfo = 'CutPasteBody: name - {}'.format(cutPasteBody.name)
            ui.messageBox(cutPasteBodyInfo)
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

DeleteFace Featur e API Sample
Description
Demonstrates creating a new deleteFace feature.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
         # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 5.0)
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        # Create the extrusion
        extrudeFeature = extrudes.add(extInput)
        # Get end faces
        endFacesObj = extrudeFeature.endFaces
        endFace = endFacesObj.item(0)
        # Create SurfaceDeleteFaceFeature
        surfaceDeleteFaceFeas = rootComp.features.surfaceDeleteFaceFeatures
        surfaceDeleteFaceFeas.add(endFace)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code
Draft Featur e API Sample
Description
Demonstrates creating a new draft feature.
Code Samples
Python
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Get active design        
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # Get root component in this design
        rootComp = design.rootComponent
        # Get the first face of box
        face1 = rootComp.bRepBodies.item(0).faces.item(0)
        
        # Get all faces which connect to the first face
        connectedFaces = [];
        for edge in face1.edges:
            for face in edge.faces:
                if face1 != face:
                    connectedFaces.append(face)
        
        # Create draft feature
        drafts = rootComp.features.draftFeatures
        draftFeatInput = drafts.createInput(connectedFaces, face1, True)
        draftFeatInput.isDirectionFlipped = False
        angle = adsk.core.ValueInput.createByString("10 deg")
        draftFeatInput.setSingleAngle(True, angle)
        drafts.add(draftFeatInput)       
        
    except:        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Equal Distance Chamfer  Featur e API Sample
Description
Creates an equal distance chamfer on the selected edge. If there are tangent contiguous edges that will also be included in the chamfer .
Code Samples
C++
Python
Copy Code

--
import adsk.core, adsk.fusion, traceback
def run(context):
    try:
        # Get various top-level objects.
        app = adsk.core.Application.get()
        ui = app.userInterface
        design: adsk.fusion.Design = app.activeProduct
        root = design.rootComponent
        
        # Have the edge selected and add it to an ObjectCollection.        
        selection = ui.selectEntity('Select edge to chamfer', 'Edges')
        edge: adsk.fusion.BRepEdge = selection.entity
        edgeCollection = adsk.core.ObjectCollection.create()
        edgeCollection.add(edge)
        
        # Create the ChamferInput object.
        chamfers = root.features.chamferFeatures
        input = chamfers.createInput2() 
        offset = adsk.core.ValueInput.createByReal(1)   
        input.chamferEdgeSets.addEqualDistanceChamferEdgeSet(edgeCollection, offset, True)
        
        # Create the chamfer.
        chamfer = chamfers.add(input) 
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Extend Featur e API Sample
Description
Demonstrates creating a new extend feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch line on the xz plane.
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchLines = sketch.sketchCurves.sketchLines
        startPoint = adsk.core.Point3D.create(0, 0, 0)
        endPoint = adsk.core.Point3D.create(1, 0, 0)
        sketchLine = sketchLines.addByTwoPoints(startPoint, endPoint)
        
        # Create a surface with ExtrudeFeature.
        features = rootComp.features
        extrudeFeatures = features.extrudeFeatures
        openProfile = rootComp.createOpenProfile(sketchLine)
        extrudeFeatureInput = extrudeFeatures.createInput(openProfile, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeFeatureInput.isSolid = False
        extrudeFeatureInput.setDistanceExtent(False, adsk.core.ValueInput.createByReal(1.0))
        
        # Get the surface body.
        extrudeFeature = extrudeFeatures.add(extrudeFeatureInput)
        surface = extrudeFeature.bodies.item(0)
        
        # Get an edge from surface, and add it to object collection.
        edges = surface.edges
        edge = edges.item(0)
        inputEdges = adsk.core.ObjectCollection.create()
        inputEdges.add(edge)
        
        # Define a distance to extend with 1 cm.
        distance = adsk.core.ValueInput.createByReal(1.0)
        
        # Create an extend input to be able to define the input needed for an extend.        extendFeatures = features.extendFeatures
        extendFeatureInput = extendFeatures.createInput(inputEdges, distance, adsk.fusion.SurfaceExtendTypes.NaturalSurfaceExtendType)
        extendFeatureInput.extendAlignment = adsk.fusion.SurfaceExtendAlignment.FreeEdges
        
        # Create an extend feature.
        extendFeature = extendFeatures.add(extendFeatureInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Extrude Featur e API Sample
Description
Demonstrates creating a new extrude feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
                
        # Get extrude features        extrudes = rootComp.features.extrudeFeatures
        # Create sketch     
        sketches = rootComp.sketches   
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 5.0)
        
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        
        # Create another sketch
        sketchVertical = sketches.add(rootComp.yZConstructionPlane)
        sketchCirclesVertical = sketchVertical.sketchCurves.sketchCircles
        centerPointVertical = adsk.core.Point3D.create(0, 1, 0)
        cicleVertical = sketchCirclesVertical.addByCenterRadius(centerPointVertical, 0.5)    
        
        # Get the profile defined by the vertical circle
        profVertical = sketchVertical.profiles.item(0)
        
        # Extrude Sample 1: A simple way of creating typical extrusions (extrusion that goes from the profile plane the specified distance).
        # Define a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5)
        extrude1 = extrudes.addSimple(prof, distance, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)        
        # Get the extrusion body
        body1 = extrude1.bodies.item(0)
        body1.name = "simple"
        # Get the state of the extrusion
        health = extrude1.healthState
        if health == adsk.fusion.FeatureHealthStates.WarningFeatureHealthState or health == adsk.fusion.FeatureHealthStates.ErrorFeatureHealthState:
            message = extrude1.errorOrWarningMessage
        
        # Get the state of timeline object
        timeline = design.timeline
        timelineObj = timeline.item(timeline.count - 1);
        health = timelineObj.healthState
        message = timelineObj.errorOrWarningMessage
        
        # Create another sketch
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle1 = sketchCircles.addByCenterRadius(centerPoint, 13.0)
        circle2 = sketchCircles.addByCenterRadius(centerPoint, 15.0)
        outerProfile = sketch.profiles.item(1)
        
        # Create taperAngle value inputs
        deg0 = adsk.core.ValueInput.createByString("0 deg")
        deg2 = adsk.core.ValueInput.createByString("2 deg")
        deg5 = adsk.core.ValueInput.createByString("5 deg")
        
        # Create distance value inputs
        mm10 = adsk.core.ValueInput.createByString("10 mm")
        mm100 = adsk.core.ValueInput.createByString("100 mm")
         
        # Extrude Sample 2: Create an extrusion that goes from the profile plane with one side distance extent
        extrudeInput = extrudes.createInput(outerProfile, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Create a distance extent definition
        extent_distance = adsk.fusion.DistanceExtentDefinition.create(mm100)        
        extrudeInput.setOneSideExtent(extent_distance, adsk.fusion.ExtentDirections.PositiveExtentDirection)
        # Create the extrusion
        extrude2 = extrudes.add(extrudeInput)
        # Get the body of the extrusion       
        body2 = extrude2.bodies.item(0)
        body2.name = "distance, from profile"
        
        # Extrude Sample 3: Create an extrusion that starts from an entity and goes the specified distance.
        extrudeInput = extrudes.createInput(profVertical, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Create a distance extent definition
        extent_distance_2 = adsk.fusion.DistanceExtentDefinition.create(mm10)
        # Create a start extent that starts from a brep face with an offset of 10 mm.
        start_from = adsk.fusion.FromEntityStartDefinition.create(body1.faces.item(0), mm10)
        # taperAngle should be 0 because extrude start face is not a planar face in this case
        extrudeInput.setOneSideExtent(extent_distance_2, adsk.fusion.ExtentDirections.PositiveExtentDirection)        
        extrudeInput.startExtent = start_from
        # Create the extrusion
        extrude3 = extrudes.add(extrudeInput)
        body3 = extrude3.bodies.item(0)
        body3.name = "distance, from entity"
        
        # Edit the distance extent of the extrusion.
        disDef = adsk.fusion.DistanceExtentDefinition.cast(extrude3.extentOne)
        distanceMP = adsk.fusion.ModelParameter.cast(disDef.distance)
        distanceMP.value = 5.0
        
        # Edit the start entity of the extrusion.
        startDef = adsk.fusion.FromEntityStartDefinition.cast(extrude3.startExtent)
        outerFace = body2.faces.item(1)
        extrude3.timelineObject.rollTo(True)
        startDef.entity = outerFace
        design.timeline.moveToEnd()
        # Edit the offset to the start entity in the extrusion.
        startDef = adsk.fusion.FromEntityStartDefinition.cast(extrude3.startExtent)
        offsetMP = adsk.fusion.ModelParameter.cast(startDef.offset)
        offsetMP.value = 1.5
        
        # Extrude Sample 4: Create an extrusion that goes from the profile plane to a specified entity.
        extrudeInput = extrudes.createInput(profVertical, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Create a to-entity extent definition
        isChained = True
        extent_toentity = adsk.fusion.ToEntityExtentDefinition.create(body1, isChained)
        # Set the one side extent with the to-entity-extent-definition, and with a taper angle of 0 degree        extrudeInput.setOneSideExtent(extent_toentity, adsk.fusion.ExtentDirections.PositiveExtentDirection)
        # Create an offset type start definition
        start_offset = adsk.fusion.OffsetStartDefinition.create(mm10)
        # Set the start extent of the extrusion
        extrudeInput.startExtent = start_offset
        # Create the extrusion
        extrude4 = extrudes.add(extrudeInput)
        body4 = extrude4.bodies.item(0)
        body4.name = "to entity, from offset"
        
        # Edit the start offset of the extrusion
        startDef = adsk.fusion.OffsetStartDefinition.cast(extrude4.startExtent)
        offsetMP = adsk.fusion.ModelParameter.cast(startDef.offset)
        offsetMP.value = 0.5
        # Edit the to-entity extent definition of the extrusion
        negative = adsk.core.Vector3D.create(-1,0,0)
        toDef = adsk.fusion.ToEntityExtentDefinition.cast(extrude4.extentOne)
        extrude4.timelineObject.rollTo(True)
        toDef.entity = body2
        toDef.isMinimumSolution = False
        toDef.directionHint = negative
        toDef.isChained = False
        design.timeline.moveToEnd()
      
        # Extrude Sample 5: Create an extrusion that goes through all entities
        extrudeInput = extrudes.createInput(profVertical, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Create an extent definition of through-all type.          
        extent_all = adsk.fusion.ThroughAllExtentDefinition.create()
        extrudeInput.setOneSideExtent(extent_all, adsk.fusion.ExtentDirections.NegativeExtentDirection, deg2)
        # Set the extrusion start with an offset
        extrudeInput.startExtent = start_offset
        # Create the extrusion
        extrude5 = extrudes.add(extrudeInput)
        body5 = extrude5.bodies.item(0)
        body5.name = "through-all, from offset"
        
        # Edit the start offset
        startDef = adsk.fusion.OffsetStartDefinition.cast(extrude5.startExtent)
        offsetMP = adsk.fusion.ModelParameter.cast(startDef.offset)
        offsetMP.value = 0.5
        
        # Edit the direction of the extrusion, make it in the same direction as the sketch plane.
        allDef = adsk.fusion.ThroughAllExtentDefinition.cast(extrude5.extentOne)
        extrude5.timelineObject.rollTo(True)
        if allDef.isPositiveDirection:
            allDef.isPositiveDirection = False
        design.timeline.moveToEnd()
        
        # Extrude Sample 6: Create a symmetric extrusion that goes 10 mm from the profile plane with a 5 degree taper angle.
        isFullLength = True
        extrudeInput = extrudes.createInput(profVertical, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeInput.setSymmetricExtent(mm10, isFullLength, deg5)
        # Create the extrusion
        extrude6 = extrudes.add(extrudeInput)
        body6 = extrude6.bodies.item(0)
        body6.name = "symmetric"
        
        # Edit the measurement, distance and taper angle properties of the symmetric extrusion
        symDef = adsk.fusion.SymmetricExtentDefinition.cast(extrude6.extentOne)
        extrude6.timelineObject.rollTo(True)
        symDef.isFullLength = not symDef.isFullLength
        design.timeline.moveToEnd()
        taperAngleMP = adsk.fusion.ModelParameter.cast(symDef.taperAngle)
        taperAngleMP.expression = "6 deg"
        distanceMP = adsk.fusion.ModelParameter.cast(symDef.distance)
        distanceMP.expression = "3 mm"
        # another way to get the symmetric extent definition
        if (extrude6.extentType == adsk.fusion.FeatureExtentTypes.SymmetricFeatureExtentType):
            symDef1 = extrude6.symmetricExtent
            distanceMP1 = symDef1.distance
            distanceMP1.value = 4
        
        # Extrude Sample 7: Create a 2-side extrusion, whose 1st side is 100 mm distance extent, and 2nd side is 10 mm distance extent.
        extrudeInput = extrudes.createInput(profVertical, adsk.fusion.FeatureOperations.CutFeatureOperation)
        extent_distance_2 = adsk.fusion.DistanceExtentDefinition.create(adsk.core.ValueInput.createByString("20cm"))
        extrudeInput.setTwoSidesExtent(extent_distance, extent_distance_2, deg5, deg0)
        extrude7 = extrudes.add(extrudeInput)
        
        # Edit the taper angles of both sides in the extrusion
        angleMP_1 = adsk.fusion.ModelParameter.cast(extrude7.taperAngleOne)
        angleMP_2 = adsk.fusion.ModelParameter.cast(extrude7.taperAngleTwo)
        angleMP_1.expression = "30 deg"
        angleMP_2.expression = "-1 deg"
        # Get the extent definition of both sides
        extent_1 = adsk.fusion.DistanceExtentDefinition.cast(extrude7.extentOne)
        extent_2 = adsk.fusion.DistanceExtentDefinition.cast(extrude7.extentTwo)
        # Edit the distances the extrusion
        distanceMP_1 = adsk.fusion.ModelParameter.cast(extent_1.distance)
        distanceMP_2 = adsk.fusion.ModelParameter.cast(extent_2.distance)
        distanceMP_1.expression = "80 mm"
        distanceMP_2.expression = "25 cm"
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Fillet Featur e Edit API Sample
Description
Demonstrates editing a fillet feature.
To successfully run this sample you can use this Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Get active design, root component, and timeline.
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        rootComp = design.rootComponent              
        timeline = design.timeline
        # Get the first fillet feature in the root component.
        fillet: adsk.fusion.FilletFeature = rootComp.features.filletFeatures[0]
        # Roll the timeline to just before the fillet.
        fillet.timelineObject.rollTo(True)
        # Iterate over the edge sets.
        edgeSet: adsk.fusion.FilletEdgeSet = None
        # Save the edges currently used by the edge sets into a list.
        edges = []
        for edgeSet in fillet.edgeSets:
            edges.append(edgeSet.edges[0])
        # Insert the last edge into the first index and remove the last edge.
        edges.insert(0, edges[len(edges)-1])
        edges.pop(len(edges)-1)
        # Process each edge set based on its type.
        for i in range(fillet.edgeSets.count):
            edgeSet = fillet.edgeSets[i]
            if edgeSet.objectType == adsk.fusion.ConstantRadiusFilletEdgeSet.classType():
                # Change the radious of the fillet.
                constantEdgeSet: adsk.fusion.ConstantRadiusFilletEdgeSet = edgeSet
                radiusParam = constantEdgeSet.radius
                radiusParam.value = radiusParam.value / 2.0
                # Toggle the continuity type between tangent and curvature.
                if constantEdgeSet.continuity == adsk.fusion.SurfaceContinuityTypes.TangentSurfaceContinuityType:
                    constantEdgeSet.continuity = adsk.fusion.SurfaceContinuityTypes.CurvatureSurfaceContinuityType
                elif constantEdgeSet.continuity == adsk.fusion.SurfaceContinuityTypes.CurvatureSurfaceContinuityType:
                    constantEdgeSet.continuity = adsk.fusion.SurfaceContinuityTypes.TangentSurfaceContinuityType
                # Change which edge is filleted.
                newEdge = adsk.core.ObjectCollection.create()
                newEdge.add(edges[i])
                constantEdgeSet.edges = newEdge
            elif edgeSet.objectType == adsk.fusion.VariableRadiusFilletEdgeSet.classType():
                variableEdgeSet: adsk.fusion.VariableRadiusFilletEdgeSet = edgeSet
                
                # Swap the values of the start and end radii.
                startRadiusParam = variableEdgeSet.startRadius
                endRadiusParam = variableEdgeSet.endRadius
                startVal = startRadiusParam.value
                startRadiusParam.expression = endRadiusParam.expression
                endRadiusParam.value = startVal
                # Edit the mid positions.
                midPositions = variableEdgeSet.midPositions  
                midRadii = variableEdgeSet.midRadii                for j in range(0, midPositions.count):
                    # Change the position and radius of the mid positions.
                    pos = midPositions.item(j).value
                    pos = pos + ((1 - pos) * 0.25)
                    midPositions.item(j).value = pos
                    midRadii.item(j).value = midRadii.item(j).value * 1.5
                
                # Add a new position.                    
                newMidPosition = adsk.core.ValueInput.createByReal(0.25)
                newMidRadius = adsk.core.ValueInput.createByReal(startRadiusParam.value * 0.75)
                variableEdgeSet.addMidPosition(newMidPosition, newMidRadius)
                # Toggle the continuity type between tangent and curvature.
                if variableEdgeSet.continuity == adsk.fusion.SurfaceContinuityTypes.TangentSurfaceContinuityType:
                    variableEdgeSet.continuity = adsk.fusion.SurfaceContinuityTypes.CurvatureSurfaceContinuityType
                elif variableEdgeSet.continuity == adsk.fusion.SurfaceContinuityTypes.CurvatureSurfaceContinuityType:
                    variableEdgeSet.continuity = adsk.fusion.SurfaceContinuityTypes.TangentSurfaceContinuityType
                # Change which edge is filleted.
                newEdge = adsk.core.ObjectCollection.create()
                newEdge.add(edges[i])
                variableEdgeSet.edges = newEdge
            elif edgeSet.objectType == adsk.fusion.ChordLengthFilletEdgeSet.classType():
                chordLengthEdgeSet = adsk.fusion.ChordLengthFilletEdgeSet.cast(edgeSet)
                # Edit the chord length.
                chordLengthParam = chordLengthEdgeSet.chordLength
                chordLengthParam.value = chordLengthParam.value * .75
                # Edit the tangency weight.
                tangencyWeightParam = chordLengthEdgeSet.tangencyWeight
                tangencyWeightParam.value = tangencyWeightParam.value / 2                   
                # Toggle the continuity type between tangent and curvature.
                if chordLengthEdgeSet.continuity == adsk.fusion.SurfaceContinuityTypes.TangentSurfaceContinuityType:
                    chordLengthEdgeSet.continuity = adsk.fusion.SurfaceContinuityTypes.CurvatureSurfaceContinuityType
                elif chordLengthEdgeSet.continuity == adsk.fusion.SurfaceContinuityTypes.CurvatureSurfaceContinuityType:
                    chordLengthEdgeSet.continuity = adsk.fusion.SurfaceContinuityTypes.TangentSurfaceContinuityType
                # Change which edge is filleted.
                newEdge = adsk.core.ObjectCollection.create()
                newEdge.add(edges[i])
                chordLengthEdgeSet.edges = newEdge
        # Move the timeline back.
        timeline.moveToEnd()
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Fillet Featur e API Sample
Description
Demonstrates creating fillets using the various types of fillets. Create a new design and add a box that is at least 2 cm on each side. The script creates a constant radius, variable radius and
chord length fillets. After creating each one, it deletes it and then creates the next. To see any of the fillets that were deleted, undo to get the fillet back.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Get active design        
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # Get root component in this design
        rootComp = design.rootComponent
        
        # Get fillet features
        fillets = rootComp.features.filletFeatures
        
        # Create constant-radius fillet using the edges of a face of the body.
        edges1 = rootComp.bRepBodies.item(0).faces.item(0).edges
        edgeCollection1 = adsk.core.ObjectCollection.create()
        for edge in edges1:
            edgeCollection1.add(edge);  
        radius1 = adsk.core.ValueInput.createByReal(0.3)
        
        input1 = fillets.createInput()
        input1.isRollingBallCorner = True
        constRadiusInput = input1.edgeSetInputs.addConstantRadiusEdgeSet(edgeCollection1, radius1, True)
        constRadiusInput.continuity = adsk.fusion.SurfaceContinuityTypes.TangentSurfaceContinuityType
        
        fillet1 = fillets.add(input1)
        fillet1.deleteMe()
        
        # Create variable-radius fillet.
        edgeCollection2 = adsk.core.ObjectCollection.create()
        edgeCollection2.add(rootComp.bRepBodies.item(0).faces.item(0).edges.item(0))
        
        input2 = fillets.createInput()
        input2.isRollingBallCorner = False
        startRadius = adsk.core.ValueInput.createByString("1.0 mm")
        endRadius = adsk.core.ValueInput.createByString("5.0 mm")
        varRadiusEdgeSet = input2.edgeSetInputs.addVariableRadiusEdgeSet(edgeCollection2, startRadius, endRadius, True)
        varRadiusEdgeSet.continuity = adsk.fusion.SurfaceContinuityTypes.TangentSurfaceContinuityType       
        positions = [];
        positions.append(adsk.core.ValueInput.createByReal(0.3))
        positions.append(adsk.core.ValueInput.createByReal(0.6))
        radii = [];
        radii.append(adsk.core.ValueInput.createByString("2.0 mm"))
        radii.append(adsk.core.ValueInput.createByString("3.0 mm"))
        varRadiusEdgeSet.setMidRadii(radii, positions)
        fillet2 = fillets.add(input2)   
        fillet2.deleteMe()
        
        # Create chord-length fillet on the edges of a face.
        edges3 = rootComp.bRepBodies.item(0).faces.item(0).edges
        edgeCollection3 = adsk.core.ObjectCollection.create()
        for edge in edges3:
            edgeCollection3.add(edge);  
        chordLength = adsk.core.ValueInput.createByReal(1.0)
        
        input3 = fillets.createInput()
        input3.isRollingBallCorner = True        chordLengthEdgeSet = input3.edgeSetInputs.addChordLengthEdgeSet(edgeCollection3, chordLength, True)
        chordLengthEdgeSet.continuity = adsk.fusion.SurfaceContinuityTypes.TangentSurfaceContinuityType       
        fillets.add(input3)        
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Hole Featur e API Sample
Description
Demonstrates creating a new hole feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 3.0)
        
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        # Create the extrusion.
        ext = extrudes.add(extInput)
        
        # Get the end face of the extrusion
        endFaces = ext.endFaces
        endFace = endFaces.item(0)
        
        # Create a construction plane by offsetting the end face
        planes = rootComp.constructionPlanes
        planeInput = planes.createInput()
        offsetVal = adsk.core.ValueInput.createByString('2 cm')
        planeInput.setByOffset(endFace, offsetVal)
        offsetPlane = planes.add(planeInput)
        
        # Create a sketch on the new construction plane and add four sketch points on it
        offsetSketch = sketches.add(offsetPlane)
        offsetSketchPoints = offsetSketch.sketchPoints
        sPt0 = offsetSketchPoints.add(adsk.core.Point3D.create(1, 0, 0))
        sPt1 = offsetSketchPoints.add(adsk.core.Point3D.create(0, 1, 0))
        sPt2 = offsetSketchPoints.add(adsk.core.Point3D.create(-1, 0, 0))
        sPt3 = offsetSketchPoints.add(adsk.core.Point3D.create(0, -1, 0))
        
        # Add the four sketch points into a collection
        ptColl = adsk.core.ObjectCollection.create()
        ptColl.add(sPt0)
        ptColl.add(sPt1)
        ptColl.add(sPt2)
        ptColl.add(sPt3)
        
        # Create a hole input
        holes = rootComp.features.holeFeatures
        holeInput = holes.createSimpleInput(adsk.core.ValueInput.createByString('2 mm'))        holeInput.setPositionBySketchPoints(ptColl)
        holeInput.setDistanceExtent(distance)
        
        hole = holes.add(holeInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Loft Featur e API Sample
Description
Demonstrates creating a new loft feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
         # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        rootComp = design.rootComponent
        # Create profile 1
        sketchesObj = rootComp.sketches
        sketch0 = sketchesObj.add(rootComp.xZConstructionPlane)
        sketchCirclesObj0 = sketch0.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCirclesObj0.addByCenterRadius(centerPoint, 5.0)
        profile0 = sketch0.profiles.item(0)
        # Create profile 2
        ctorPlanes = rootComp.constructionPlanes
        ctorPlaneInput1 = ctorPlanes.createInput()
        offset = adsk.core.ValueInput.createByString("10 cm")
        ctorPlaneInput1.setByOffset(rootComp.xZConstructionPlane, offset)
        ctorPlane1 = ctorPlanes.add(ctorPlaneInput1)
        sketch1 = sketchesObj.add(ctorPlane1)
        sketchCirclesObj1 = sketch1.sketchCurves.sketchCircles
        sketchCirclesObj1.addByCenterRadius(centerPoint, 2.0)
        profile1 = sketch1.profiles.item(0)
        # Create profile 3
        ctorPlaneInput2 = ctorPlanes.createInput()
        ctorPlaneInput2.setByOffset(ctorPlane1, offset)
        ctorPlane2 = ctorPlanes.add(ctorPlaneInput2)
        sketch2 = sketchesObj.add(ctorPlane2)
        sketchCirclesObj2 = sketch2.sketchCurves.sketchCircles
        sketchCirclesObj2.addByCenterRadius(centerPoint, 10.0)
        profile2 = sketch2.profiles.item(0)
        # Create loft feature input
        loftFeats = rootComp.features.loftFeatures
        loftInput = loftFeats.createInput(adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        loftSectionsObj = loftInput.loftSections
        loftSectionsObj.add(profile0)
        loftSectionsObj.add(profile1)
        loftSectionsObj.add(profile2)
        loftInput.isSolid = False
        loftInput.isClosed = False
        loftInput.isTangentEdgesMerged = True
        # Create loft feature
        loftFeats.add(loftInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))--

Mirr or Featur e API Sample
Description
Demonstrates creating a new mirror feature
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchLines = sketch.sketchCurves.sketchLines
        startPoint = adsk.core.Point3D.create(0, 0, 0)
        endPoint = adsk.core.Point3D.create(5, 5, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        
        # Get the profile defined by the rectangle.
        prof = sketch.profiles.item(0)
        # Create an extrusion input.
        features = rootComp.features
        extrudes = features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        # Create the extrusion.
        ext = extrudes.add(extInput)
        
        # Get the body created by extrusion
        body = ext.bodies.item(0)
        
        # Get a face of the body
        face = body.faces.item(0)
        
        # Create a construction plane by offset
        planes = rootComp.constructionPlanes
        planeInput = planes.createInput()
        offsetDistance = adsk.core.ValueInput.createByString('5 cm')
        planeInput.setByOffset(face, offsetDistance)
        plane = planes.add(planeInput)
        
        # Create input entities for mirror feature
        inputEntites = adsk.core.ObjectCollection.create()
        inputEntites.add(body)
        
        # Create the input for mirror feature
        mirrorFeatures = features.mirrorFeatures
        mirrorInput = mirrorFeatures.createInput(inputEntites, plane)
        
        # Create the mirror feature
        mirrorFeature = mirrorFeatures.add(mirrorInput)    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Move Featur e API SampleDescription
Demonstrates creating a new move feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        features = rootComp.features
        # Create sketch circle on the xz plane.
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 10)
        centerPoint = adsk.core.Point3D.create(15, 5, 0)
        sketchCircles.addByCenterRadius(centerPoint, 4)
        # Create a collection of entities for extrude
        profiles = adsk.core.ObjectCollection.create()
        profiles.add(sketch.profiles.item(0))
        profiles.add(sketch.profiles.item(1))
        # Create a cylinder with ExtrudeFeature using the profile above.
        extrudeFeats = features.extrudeFeatures
        extrudeFeature = extrudeFeats.addSimple(profiles, 
                                                adsk.core.ValueInput.createByReal(2.0),
                                                adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Create a collection of entities for move
        bodies = adsk.core.ObjectCollection.create()
        bodies.add(extrudeFeature.bodies.item(0))
        # Create a transform to do move
        vector = adsk.core.Vector3D.create(0.0, 10.0, 0.0)
        transform = adsk.core.Matrix3D.create()
        transform.translation = vector
        # Create a move feature
        moveFeats = features.moveFeatures
        moveFeatureInput = moveFeats.createInput2(bodies)
        moveFeatureInput.defineAsFreeMove(transform)
        moveFeats.add(moveFeatureInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Offset Featur e API Sample
Description
Demonstrates creating a new of fset feature
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircle = sketchCircles.addByCenterRadius(centerPoint, 3.0)
        
        # Create a open profile for extrusion.
        openProfile = rootComp.createOpenProfile(sketchCircle)
        
        # Create an extrusion input.
        features = rootComp.features
        extrudes = features.extrudeFeatures
        extrudeInput = extrudes.createInput(openProfile, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeInput.isSolid = False
        
        # Define the extent with a distance extent of 3 cm.
        distance = adsk.core.ValueInput.createByReal(3.0)
        extrudeInput.setDistanceExtent(False, distance)
        
        # Create the extrusion.        extrude = extrudes.add(extrudeInput)
        
        # Get the body created by extrusion
        body = extrude.bodies[0]
        
        # Create input entities for offset feature
        inputEntities = adsk.core.ObjectCollection.create()
        inputEntities.add(body)
        
        # Distance for offset feature
        distance = adsk.core.ValueInput.createByString('1 cm')
        
        # Create an input for offset feature
        offsetFeatures = features.offsetFeatures
        offsetInput = offsetFeatures.createInput(inputEntities, distance, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Create the offset feature
        offsetFeatures.add(offsetInput);
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Manage Participant Bodies API Sample
Description
Demonstrates how to manage participant During Cut operation. Same API can be used to manage participants During intersection also.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 3.0)
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        # Create sketch for Cut
        sketchForCut = sketches.add(rootComp.xZConstructionPlane)
        sketchForCutCircles = sketchForCut.sketchCurves.sketchCircles
        sketchForCutCircles.addByCenterRadius(centerPoint, 1.5)
        # Get the profile defined by the circle.
        profForCut = sketchForCut.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Define that the extent is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        # Create the extrusion.
        ext = extrudes.add(extInput)
        # Get the body created by extrusion
        body = ext.bodies.item(0)
        # Create input entities for rectangular pattern
        inputEntites = adsk.core.ObjectCollection.create()
        inputEntites.add(body)
        # Get x and y axes for rectangular pattern
        xAxis = rootComp.xConstructionAxis
        yAxis = rootComp.yConstructionAxis
        # Quantity and distance
        quantityOne = adsk.core.ValueInput.createByString('1')
        distanceOne = adsk.core.ValueInput.createByString('0 cm')
        quantityTwo = adsk.core.ValueInput.createByString('6')
        distanceTwo = adsk.core.ValueInput.createByString('15 cm')
        # Create the input for rectangular pattern
        rectangularPatterns = rootComp.features.rectangularPatternFeatures
        rectangularPatternInput = rectangularPatterns.createInput(inputEntites, xAxis, quantityOne, distanceOne, adsk.fusion.PatternDistanceType.SpacingPatternDistanceType
        # Set the data for second direction
        rectangularPatternInput.setDirectionTwo(yAxis, quantityTwo, distanceTwo)
        # Create the rectangular pattern
        rectangularFeature = rectangularPatterns.add(rectangularPatternInput)
        patBodies = rectangularFeature.bodies
        body0 = patBodies.item(0)
        face0 = body0.faces.item(0)
        extCutInput = extrudes.createInput(profForCut, adsk.fusion.FeatureOperations.CutFeatureOperation)
         # Set the extrude input
        distanceForCut = adsk.core.ValueInput.createByString('90 cm')
        extCutInput.setDistanceExtent(False, distanceForCut)
        #set bodies to participate
        extCutInput.participantBodies = [patBodies.item(0), patBodies.item(2), patBodies.item(4)]
        extrudes.add(extCutInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Patch Featur e API Sample
Description
Demonstrates creating a new patch feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketchesObj = rootComp.sketches
        sketch = sketchesObj.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 3.0)
        sketchCircles.addByCenterRadius(centerPoint, 10.0)
        # Get the profiles defined by the circles.
        profile1 = sketch.profiles.item(0)
        profile2 = sketch.profiles.item(1)
        
        # Get the inner and outer profile
        areaPropertiesOfProfile1 = profile1.areaProperties()
        areaPropertiesOfProfile2 = profile2.areaProperties()
        areaOfProfile1 = areaPropertiesOfProfile1.area
        areaOfProfile2 = areaPropertiesOfProfile2.area
        outerProfile = profile1
        if areaOfProfile1 < areaOfProfile2:
            outerProfile = profile2
        # Create a extrusion based on the outer profile
        extrudes = rootComp.features.extrudeFeatures
        extrudeDistance = adsk.core.ValueInput.createByString("1 cm")
        extrudeFeature = extrudes.addSimple(outerProfile, extrudeDistance, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Get BrepEdge from inner loop on the end face of the extrusion
        extrudeEndFace = extrudeFeature.endFaces.item(0)
        brepLoops = extrudeEndFace.loops
        innerLoop = brepLoops.item(0)
        if innerLoop.isOuter:
            innerLoop = brepLoops.item(1)
        brepEdges = innerLoop.edges
        brepEdge = brepEdges.item(0)
        # Create the patch feature
        patches = rootComp.features.patchFeatures
        patchInput = patches.createInput(brepEdge, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        patches.add(patchInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Path Pattern Featur e API Sample
Description
Demonstrates creating a new path pattern feature.
Code Samples
Python
C++Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 3.0)
        sketchLines = sketch.sketchCurves.sketchLines
        startPoint = adsk.core.Point3D.create(5, 0, 0)
        endPoint = adsk.core.Point3D.create(5, 30, 0)
        sketchLine = sketchLines.addByTwoPoints(startPoint, endPoint)
        
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        features = rootComp.features
        extrudes = features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        # Create the extrusion.
        ext = extrudes.add(extInput)
        
        # Get the body created by extrusion
        body = ext.bodies.item(0)
        
        # Create input entities for rectangular pattern
        inputEntites = adsk.core.ObjectCollection.create()
        inputEntites.add(body)
        
        # Create path for path pattern
        path = features.createPath(sketchLine)
        
        # Quantity and distance
        quantity = adsk.core.ValueInput.createByString('3')
        patternDistance = adsk.core.ValueInput.createByString('8 cm')
        
        # Create the input for path pattern
        pathPatterns = features.pathPatternFeatures
        pathPatternInput = pathPatterns.createInput(inputEntites, path, quantity, patternDistance, adsk.fusion.PatternDistanceType.SpacingPatternDistanceType)
        
        # Create the path pattern
        pathFeature = pathPatterns.add(pathPatternInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

RectangularPattern Featur e
Description
Demonstrates creating a new rectangular pattern feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 3.0)
                # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        # Create the extrusion.
        ext = extrudes.add(extInput)
        
        # Get the body created by extrusion
        body = ext.bodies.item(0)
        
        # Create input entities for rectangular pattern
        inputEntites = adsk.core.ObjectCollection.create()
        inputEntites.add(body)
        
        # Get x and y axes for rectangular pattern
        xAxis = rootComp.xConstructionAxis
        yAxis = rootComp.yConstructionAxis
        
        # Quantity and distance
        quantityOne = adsk.core.ValueInput.createByString('3')
        distanceOne = adsk.core.ValueInput.createByString('8 cm')
        quantityTwo = adsk.core.ValueInput.createByString('3')
        distanceTwo = adsk.core.ValueInput.createByString('8 cm')
        
        # Create the input for rectangular pattern
        rectangularPatterns = rootComp.features.rectangularPatternFeatures
        rectangularPatternInput = rectangularPatterns.createInput(inputEntites, xAxis, quantityOne, distanceOne, adsk.fusion.PatternDistanceType.SpacingPatternDistanceType
        
        # Set the data for second direction
        rectangularPatternInput.setDirectionTwo(yAxis, quantityTwo, distanceTwo)
        
        # Create the rectangular pattern
        rectangularFeature = rectangularPatterns.add(rectangularPatternInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Remove Featur e
Description
Demonstrates creating a new remove feature.
Code Samples
Python
Copy Code
#Author-
#Description-
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Get remove features
        features = rootComp.features
        removeFeatures = features.removeFeatures
        # Create sketch circle on the xz plane.
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 10)
        # Create a collection of entities for extrude
        entities0 = adsk.core.ObjectCollection.create()
        entities0.add(sketch.profiles.item(0))
        # Create a cylinder with ExtrudeFeature using the profile above.
        extrudeFeats = features.extrudeFeatures
        extrudeFeatureInput = extrudeFeats.createInput(entities0, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeFeatureInput.isSolid = True
        extrudeFeatureInput.setDistanceExtent(False, adsk.core.ValueInput.createByReal(2.5))
        extrudeFeature = extrudeFeats.add(extrudeFeatureInput)
        
        # Get created body
        body = extrudeFeature.bodies[0]
        
        # Create remove feature
        removeFeat = removeFeatures.add(body)
        
        # Create an occurrence
        occs = rootComp.occurrences
        occ = occs.addNewComponent(adsk.core.Matrix3D.create())        
        # Create remove feature
        removeFeat2 = removeFeatures.add(occ)
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
ReplaceFace Featur e
Description
Demonstrates creating a new replaceface feature.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        features = rootComp.features
        # Create sketch circle on the xz plane.
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 10)
        # Get the profile from the sketch.
        profile = sketch.profiles.item(0)
        # Create a cylinder with ExtrudeFeature using the profile above.
        extrudeFeats = features.extrudeFeatures
        distance = adsk.core.ValueInput.createByReal(2.5)
        extrudeFeature = extrudeFeats.addSimple(profile, distance, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Create a collection of source faces for replace
        entities1 = adsk.core.ObjectCollection.create()
        sourceFace = extrudeFeature.endFaces.item(0)
        entities1.add(sourceFace)
        # Create a construction plane as the target face
        offset = adsk.core.ValueInput.createByReal(5)
        ctorPlanes = rootComp.constructionPlanes
        ctorPlaneInput = ctorPlanes.createInput()
        ctorPlaneInput.setByOffset(sourceFace, offset)
        ctorPlane = ctorPlanes.add(ctorPlaneInput)
        # Create a replace feature
        replaceFaceFeas = features.replaceFaceFeatures
        isTangentChain = False
        replaceFaceInput = replaceFaceFeas.createInput(entities1, isTangentChain, ctorPlane)
        replaceFaceFeas.add(replaceFaceInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Reverse Normal Featur e
Description
Demonstrates creating a new reverse normal feature.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        features = rootComp.features
        # Create sketch circle on the xz plane.
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 10)
        # Create a collection of entities for extrude
        entities0 = adsk.core.ObjectCollection.create()
        entities0.add(sketch.profiles.item(0))
        # Create a cylinder with ExtrudeFeature using the profile above.
        extrudeFeats = features.extrudeFeatures        extrudeFeatureInput = extrudeFeats.createInput(entities0, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeFeatureInput.isSolid = False
        extrudeFeatureInput.setDistanceExtent(False, adsk.core.ValueInput.createByReal(2.5))
        extrudeFeature = extrudeFeats.add(extrudeFeatureInput)
        # Create a collection of source bodies
        bodies = adsk.core.ObjectCollection.create()
        source = extrudeFeature.bodies.item(0)
        bodies.add(source)
        # Create a reverse normal feature
        reverseFeats = features.reverseNormalFeatures
        reverseFeat = reverseFeats.add(bodies)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Rip Featur e Sample
Description
Demonstrates creating a new sheet metal rip feature.
Code Samples
C++
--
Ruled Surface Featur e API Sample
Description
Demonstrates creating a new ruled surface feature.
Code Samples
C++
Copy Code

Scale Featur e API Sample
Description
Demonstrates creating a new scale feature.
Code Samples
Python
C++--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 5.0)
        
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        # Create the extrusion
        ext = extrudes.add(extInput)
        
        # Get the body created by the extrusion
        body = ext.bodies.item(0)
        
        # Create a scale input
        inputColl = adsk.core.ObjectCollection.create()
        inputColl.add(body)
        
        basePt = sketch.sketchPoints.item(0)
        scaleFactor = adsk.core.ValueInput.createByReal(2)
        
        scales = rootComp.features.scaleFeatures
        scaleInput = scales.createInput(inputColl, basePt, scaleFactor)
        
        # Set the scale to be non-uniform
        xScale = adsk.core.ValueInput.createByReal(1.5)
        yScale = adsk.core.ValueInput.createByReal(3)
        zScale = adsk.core.ValueInput.createByReal(2)
        scaleInput.setToNonUniform(xScale, yScale, zScale)
        
        scale = scales.add(scaleInput)
        
        # Create another sketch
        sketchVertical = sketches.add(rootComp.yZConstructionPlane)
        sketchCirclesVertical = sketchVertical.sketchCurves.sketchCircles
        centerPointVertical = adsk.core.Point3D.create(0, 10, 0)
        cicleVertical = sketchCirclesVertical.addByCenterRadius(centerPointVertical, 5)
        
        # Create an uniformed input for scale feature input
        inputUniformColl = adsk.core.ObjectCollection.create()
        inputUniformColl.add(sketchVertical)
        
        scaleUniformInput = scales.createInput(inputUniformColl, basePt, scaleFactor)
        
        scaleUniform = scales.add(scaleUniformInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Shell Featur e API SampleDescription
Demonstrates creating a new shell feature.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        features = rootComp.features
        # Create sketch circle on the xz plane.
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 10)
        # Get the profile from the sketch.
        profile = sketch.profiles.item(0)
        # Create a cylinder with ExtrudeFeature using the profile above.
        extrudeFeats = features.extrudeFeatures
        distance = adsk.core.ValueInput.createByReal(2.5)
        extrudeFeature = extrudeFeats.addSimple(profile, distance, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Create a collection of entities for shell
        entities1 = adsk.core.ObjectCollection.create()
        entities1.add(extrudeFeature.endFaces.item(0))
        # Create a shell feature
        shellFeats = features.shellFeatures
        isTangentChain = False
        shellFeatureInput = shellFeats.createInput(entities1, isTangentChain)
        thickness = adsk.core.ValueInput.createByReal(0.5)
        shellFeatureInput.insideThickness = thickness
        shellFeats.add(shellFeatureInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Silhouette Split Featur e API Sample
Description
Demonstrates creating a new silhouette split feature.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
         # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 5.0)
        
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        # Create the extrusion
        ext = extrudes.add(extInput)
        # Get the body created by the extrusion
        body = ext.bodies.item(0)
        
        # Create SilhouetteSplitFeatureInput
        silhouetteSplitFeats = rootComp.features.silhouetteSplitFeatures
        silhouetteSplitInput = silhouetteSplitFeats.createInput(rootComp.xZConstructionPlane, body, adsk.fusion.SilhouetteSplitOperations.SilhouetteSplitFacesOnlyOperatio
        
        # Create silhouette split feature
        silhouetteSplitFeats.add(silhouetteSplitInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Simple Extrusion Sample
Description
Creates a new extrusion feature, resulting in a new component.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try: 
        app = adsk.core.Application.get()
        ui = app.userInterface
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a new sketch on the xy plane.
        sketches = rootComp.sketches
        xyPlane = rootComp.xYConstructionPlane
        sketch = sketches.add(xyPlane)
        # Draw a circle.
        circles = sketch.sketchCurves.sketchCircles
        circle1 = circles.addByCenterRadius(adsk.core.Point3D.create(0, 0, 0), 2)
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        # Define that the extent is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        # Create the extrusion.
        extrudes = rootComp.features.extrudeFeatures
        ext = extrudes.addSimple(prof, distance, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Simple Revolve Featur e Sample
Description
Creates a new revolve feature, resulting in a new component.
Code Samples
Python
--
import adsk.core, adsk.fusion, math, traceback
def run(context):
    ui = None
    try: 
        app = adsk.core.Application.get()
        ui = app.userInterface
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        # Create a new sketch on the xy plane.
        sketches = rootComp.sketches;
        xyPlane = rootComp.xYConstructionPlane;
        sketch = sketches.add(xyPlane)
        # Draw a circle.
        circles = sketch.sketchCurves.sketchCircles
        circle1 = circles.addByCenterRadius(adsk.core.Point3D.create(0, 0, 0), 2)
        
        # Draw a line to use as the axis of revolution.
        lines = sketch.sketchCurves.sketchLines
        axisLine = lines.addByTwoPoints(adsk.core.Point3D.create(-1, -5, 0), adsk.core.Point3D.create(1, -5, 0))
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        # Create an revolution input to be able to define the input needed for a revolution
        # while specifying the profile and that a new component is to be created
        revolves = rootComp.features.revolveFeatures
        revInput = revolves.createInput(prof, axisLine, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
        # Define that the extent is an angle of pi to get half of a torus.
        angle = adsk.core.ValueInput.createByReal(math.pi)
        revInput.setAngleExtent(False, angle)
        # Create the extrusion.
        ext = revolves.add(revInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Split Body Featur e API Sample
Description
Demonstrates creating a new split body feature.
Code Samples
Python
C++Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
         # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 5.0)
        
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        # Create the extrusion
        ext = extrudes.add(extInput)
        # Get the body created by the extrusion
        body = ext.bodies.item(0)
        
        # Create SplitBodyFeatureInput
        splitBodyFeats = rootComp.features.splitBodyFeatures
        splitBodyInput = splitBodyFeats.createInput(body, rootComp.xZConstructionPlane, True)
        
        # Create split body feature
        splitBodyFeats.add(splitBodyInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Split Face Featur e API Sample
Description
Demonstrates creating a new split face feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
         # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create a sketch that has a rectangle in it
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchLines = sketch.sketchCurves.sketchLines
        point0 = adsk.core.Point3D.create(0, 0, 0)
        point1 = adsk.core.Point3D.create(10, 10, 0)
        sketchLines.addTwoPointRectangle(point0, point1)
        
        # Get the profile defined by the rectangle
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(True, distance)
        # Create the extrusion
        ext = extrudes.add(extInput)
        # Get one edge of the extrusion body
        face = ext.endFaces.item(0)
        edge = face.edges.item(0)
        
        # Create a slant construction plane with an angle of 45 deg on the xZConstructionPlane
        planeInput = rootComp.constructionPlanes.createInput()
        planeInput.setByAngle(edge, adsk.core.ValueInput.createByString('45 deg'), rootComp.xZConstructionPlane)
        plane = rootComp.constructionPlanes.add(planeInput)
        
        # Create another sketch containing a circle profile on the slant plane
        toolSketch = sketches.add(plane)
        point3 = adsk.core.Point3D.create(-5, 3.5, 0)
        sketchCircles = toolSketch.sketchCurves.sketchCircles
        circle = sketchCircles.addByCenterRadius(point3, 3)
        
        # Get SplitFaceFetures
        splitFaceFeats = rootComp.features.splitFaceFeatures
        
        # Set faces to split
        facesCol = adsk.core.ObjectCollection.create()
        facesCol.add(face)
        
        # Create a split face feature of surface intersection split type
        splitFaceInput = splitFaceFeats.createInput(facesCol, circle, True)
        split = splitFaceFeats.add(splitFaceInput)
        split.deleteMe()
        
        # Create another split face feature of closest point split type   
        splitFaceInput.setClosestPointSplitType()
        split = splitFaceFeats.add(splitFaceInput)
        split.deleteMe()
        
        # Create another split face feature of along vector split type   
        splitFaceInput.setAlongVectorSplitType(face.edges.item(1))
        splitFaceFeats.add(splitFaceInput)
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))--

Stitch Featur e API Sample
Description
Demonstrates creating a new stitch feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Create a document
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create two sketch lines on the xz plane.
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchLines = sketch.sketchCurves.sketchLines
        startPoint = adsk.core.Point3D.create(0, 0, 0)
        endPoint = adsk.core.Point3D.create(1, 0, 0)
        sketchLine = sketchLines.addByTwoPoints(startPoint, endPoint)
        endPoint2 = adsk.core.Point3D.create(0, 1, 0)
        sketchLine2 = sketchLines.addByTwoPoints(startPoint, endPoint2)
        
        # Create surface one with ExtrudeFeature.
        features = rootComp.features
        extrudeFeatures = features.extrudeFeatures
        openProfile = rootComp.createOpenProfile(sketchLine)
        extrudeFeatureInput = extrudeFeatures.createInput(openProfile, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeFeatureInput.isSolid = False
        extrudeFeatureInput.setDistanceExtent(False, adsk.core.ValueInput.createByReal(1.0))
        extrudeFeature = extrudeFeatures.add(extrudeFeatureInput)
        
        # Create surface two with ExtrudeFeature.
        openProfile2 = rootComp.createOpenProfile(sketchLine2)        
        extrudeFeatureInput2 = extrudeFeatures.createInput(openProfile2, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeFeatureInput2.isSolid = False
        extrudeFeatureInput2.setDistanceExtent(False, adsk.core.ValueInput.createByReal(1.0))
        extrudeFeature2 = extrudeFeatures.add(extrudeFeatureInput2)
        
        # Get surface bodies and add them to object collection.
        surface = extrudeFeature.bodies.item(0)
        surface2 = extrudeFeature2.bodies.item(0)
        surfaces = adsk.core.ObjectCollection.create()
        surfaces.add(surface)
        surfaces.add(surface2)
        
        # Define tolerance with 1 cm.
        tolerance = adsk.core.ValueInput.createByReal(1.0)
        
        # Create a stitch input to be able to define the input needed for an stitch.
        stitches = features.stitchFeatures
        stitchInput = stitches.createInput(surfaces, tolerance, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Create a stitch feature.
        stitch = stitches.add(stitchInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Sweep Featur e API Sample
Description
Demonstrates creating a new sweep feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 3.0)
        
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)        
        # Create a vertical sketch and add two lines on it
        sketchVertical = sketches.add(rootComp.yZConstructionPlane)
        sketchLines = sketchVertical.sketchCurves.sketchLines
        startPt = adsk.core.Point3D.create(0, 0, 0)
        midPt = adsk.core.Point3D.create(0, 3, 0)
        endPt = adsk.core.Point3D.create(2, 6, 0)
        line1 = sketchLines.addByTwoPoints(startPt, midPt)
        line2 = sketchLines.addByTwoPoints(midPt, endPt)
        
        # Merge the two lines
        line1.endSketchPoint.merge(line2.startSketchPoint)
        
        # Create a path and let it find connected curves automatically
        path = rootComp.features.createPath(line1)
        # Create a sweep input
        sweeps = rootComp.features.sweepFeatures
        sweepInput = sweeps.createInput(prof, path, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        sweepInput.taperAngle = adsk.core.ValueInput.createByString('5 deg')
        sweepInput.twistAngle = adsk.core.ValueInput.createByString('10 deg')
        # Create the sweep.
        sweep = sweeps.add(sweepInput)
        
        # Get taperAngel and twistAngle from sweep feature
        taperAngle = sweep.taperAngle
        twistAngle = sweep.twistAngle
        print('taper angle: {}'.format(taperAngle.expression))
        print('twist angle: {}'.format(twistAngle.expression))
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Sweep with guide rail Featur e API Sample
Description
Demonstrates creating a new Sweep feature that uses a guide rail along with a profile.
Code Samples
C++
Python
Copy Code

--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch for the profile to sweep
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 1.0)        
        
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)        
        
        # Create a vertical sketch and add a spline (for the sweep path) and a line (for the sweep guide rail)
        sketchVertical = sketches.add(rootComp.yZConstructionPlane)
        sketchSplines = sketchVertical.sketchCurves.sketchFittedSplines
        sketchLines = sketchVertical.sketchCurves.sketchLines
        
        # Create points for the spline definition       
        splineStartPt = adsk.core.Point3D.create(0, 0, 0)
        splineMidPt = adsk.core.Point3D.create(0, 5, 0)
        splineEndPt = adsk.core.Point3D.create(3, 10, 0)
        
        # Create a collection of the points for the input needed to create the spline
        fitPoints = adsk.core.ObjectCollection.create()
        fitPoints.add(splineStartPt)
        fitPoints.add(splineMidPt)
        fitPoints.add(splineEndPt)
        
        # Create the spline
        spline = sketchSplines.add(fitPoints)
        
        # Create points for the line definition       
        lineStartPt = adsk.core.Point3D.create(-2, 0, 0)
        lineEndPt = adsk.core.Point3D.create(-2, 10, 0)
        
        # Create the line
        line = sketchLines.addByTwoPoints(lineStartPt, lineEndPt)
        
        # Create a path for the sweep path and guide rail
        path = rootComp.features.createPath(spline)
        guide = rootComp.features.createPath(line)
        
        # Create a sweep input
        sweeps = rootComp.features.sweepFeatures
        sweepInput = sweeps.createInput(prof, path, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        sweepInput.guideRail = guide
        sweepInput.profileScaling = adsk.fusion.SweepProfileScalingOptions.SweepProfileScaleOption
        # Create the sweep.
        sweep = sweeps.add(sweepInput)
        
        sketchVertical.isVisible = True
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Thicken Featur e API Sample
Description
Demonstrates creating a new thiken feature.
Code Samples
Python
C++
Copy Codeimport adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        
        design = app.activeProduct
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircle = sketchCircles.addByCenterRadius(centerPoint, 3.0)
        
        # Create surface
        openProfile = rootComp.createOpenProfile(sketchCircle)
        features = rootComp.features
        extrudes = features.extrudeFeatures
        extrudeInput = extrudes.createInput(openProfile, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeInput.isSolid = False
        distance = adsk.core.ValueInput.createByReal(3.0)
        extrudeInput.setDistanceExtent(False, distance)
        extrude = extrudes.add(extrudeInput)
        
        # Create thiken feature
        thickenFeatures = features.thickenFeatures
        inputSurfaces = adsk.core.ObjectCollection.create()
        bodies = extrude.bodies
        for body in bodies :
            inputSurfaces.add(body)
        thickness = adsk.core.ValueInput.createByReal(1.0)
        thickenInput = thickenFeatures.createInput(inputSurfaces, thickness, False,  adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        thickenFeatures.add(thickenInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Thread Featur e API SampleDescription
Demonstrates creating a new thread feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        # get the design
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # get the root component of the active design.
        rootComp = design.rootComponent
        
        # create a new sketch on the xy plane.
        sketch = rootComp.sketches.add(rootComp.xYConstructionPlane)
        
        # create a sketch circle
        sketchCircles = sketch.sketchCurves.sketchCircles
        sketchCircle = sketchCircles.addByCenterRadius(adsk.core.Point3D.create(0, 0, 0), 3)
        
        # get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        
        # create extrude input
        extrudes = rootComp.features.extrudeFeatures
        extrudeInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # define that the extent is a distance extent of 7 cm
        extrudeInput.setDistanceExtent(False, adsk.core.ValueInput.createByReal(7))
        
        # extrude the circle to create a cylinder
        extrude = extrudes.add(extrudeInput)
        
        # define all of the thread information.
        threadFeatures = rootComp.features.threadFeatures
        
        # query the thread table to get the thread information
        threadDataQuery = threadFeatures.threadDataQuery
        threadTypes = threadDataQuery.allThreadTypes
        threadType = threadTypes[0]
        
        allsizes = threadDataQuery.allSizes(threadType)
        threadSize = allsizes[0]
        
        allDesignations = threadDataQuery.allDesignations(threadType, threadSize)
        threadDesignation = allDesignations[0]
        
        allClasses = threadDataQuery.allClasses(False, threadType, threadDesignation)
        threadClass = allClasses[0]
        
        # create the threadInfo according to the query result
        threadInfo = threadFeatures.createThreadInfo(False, threadType, threadDesignation, threadClass)
        
        # get the face the thread will be applied to
        sideface = extrude.sideFaces.item(0)
        faces = adsk.core.ObjectCollection.create()
        faces.add(sideface)
        
        # define the thread input with the lenght 3.5 cm
        threadInput = threadFeatures.createInput(faces, threadInfo)
        threadInput.isFullLength = False
        threadInput.threadLength = adsk.core.ValueInput.createByReal(3.5)
        
        # create the final thread
        thread = threadFeatures.add(threadInput)
        
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Trim Featur e API Sample
DescriptionDemonstrates creating a new trim feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircle = sketchCircles.addByCenterRadius(centerPoint, 3.0)
        
        # Create a open profile for extrusion.
        openProfile = rootComp.createOpenProfile(sketchCircle)
        
        # Create an extrusion input.
        features = rootComp.features
        extrudes = features.extrudeFeatures
        extrudeInput = extrudes.createInput(openProfile, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeInput.isSolid = False
        
        # Define the extent with a distance extent of 3 cm.
        distance = adsk.core.ValueInput.createByReal(3.0)
        extrudeInput.setDistanceExtent(False, distance)
        
        # Create the extrusion.
        extrude = extrudes.add(extrudeInput)
        
        # Get the body created by extrusion
        body = extrude.bodies[0]
        
        # Create sketch 2.
        sketch2 = sketches.add(rootComp.xYConstructionPlane);
        sketchLines = sketch2.sketchCurves.sketchLines;
        startPoint = adsk.core.Point3D.create(-5, 0, 0);
        endPoint = adsk.core.Point3D.create(5, 0, 0);
        sketchLine = sketchLines.addByTwoPoints(startPoint, endPoint);
        openProfile2 = rootComp.createOpenProfile(sketchLine);
        
        # Create a open profile for extrusion.
        extrudeInput2 = extrudes.createInput(openProfile2, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeInput2.isSolid = False
        
        # Define the extent
        distance2 = adsk.core.ValueInput.createByReal(5.0)
        extrudeInput2.setDistanceExtent(False, distance2)
        
        # Create the extrusion.
        extrudes.add(extrudeInput2)
        
        # Create trim feature
        trims = features.trimFeatures
        trimInput = trims.createInput(body)
        cells = trimInput.bRepCells
        cells[0].isSelected = True
        trims.add(trimInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Two Rail Sweep Featur e API Sample
Description
Demonstrates creating new two rail sweep feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xYConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        circle = sketchCircles.addByCenterRadius(centerPoint, 3.0)
        
        # Get the profile defined by the circle.
        prof = sketch.profiles.item(0)
        
        # Create a vertical sketch and add two lines on it
        sketchVertical = sketches.add(rootComp.xZConstructionPlane)
        sketchLines = sketchVertical.sketchCurves.sketchLines
        startPtOne = adsk.core.Point3D.create(0, 0, 0)
        endPtOne = adsk.core.Point3D.create(0, 10, 0)
        startPtTwo = adsk.core.Point3D.create(3, 0, 0)
        endPtTwo = adsk.core.Point3D.create(6, 10, 0)
        line1 = sketchLines.addByTwoPoints(startPtOne, endPtOne)
        line2 = sketchLines.addByTwoPoints(startPtTwo, endPtTwo)
        
        # Create a path
        path = rootComp.features.createPath(line1)
        
        # Create guid rail path
        guidRailPath = rootComp.features.createPath(line2)
        
        # Create a sweep input
        sweeps = rootComp.features.sweepFeatures
        sweepInput = sweeps.createInput(prof, path, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        sweepInput.guideRail = guidRailPath
        sweepInput.isDirectionFlipped = False
        sweepInput.profileScaling = adsk.fusion.SweepProfileScalingOptions.SweepProfileScaleOption
        # Create the sweep.
        sweeps.add(sweepInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Unstitch Featur e API Sample
Description
Demonstrates creating a new unstitch feature
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchLines = sketch.sketchCurves.sketchLines
        startPoint = adsk.core.Point3D.create(0, 0, 0)
        endPoint = adsk.core.Point3D.create(5, 5, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        
        # Get the profile defined by the rectangle.
        prof = sketch.profiles.item(0)
        # Create an extrusion input.
        features = rootComp.features
        extrudes = features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm.
        distance = adsk.core.ValueInput.createByReal(5)
        extInput.setDistanceExtent(False, distance)
        # Create the extrusion.
        ext = extrudes.add(extInput)
        
        # Get the body created by extrusion.
        body = ext.bodies.item(0)
        
        # Create unstitch feature.
        unstitchFeatures = features.unstitchFeatures
        entities = adsk.core.ObjectCollection.create()
        entities.add(body)
        unstitch = unstitchFeatures.add(entities)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Untrim Featur e API Sample
Description
Demonstrates creating a new untrim feature.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design.
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircle1 = sketchCircles.addByCenterRadius(centerPoint, 3.0)
        sketchCircle2 = sketchCircles.addByCenterRadius(centerPoint, 10.0)
        
        # Get the profiles defined by the circles
        profile1 = sketch.profiles.item(0)
        profile2 = sketch.profiles.item(1)
 
     # Get the inner and outer profile
        areaPropertiesOfProfile1 = profile1.areaProperties()
        areaPropertiesOfProfile2 = profile2.areaProperties()
        areaOfProfile1 = areaPropertiesOfProfile1.area
        areaOfProfile2 = areaPropertiesOfProfile2.area
        outerProfile = profile1
        if areaOfProfile1 < areaOfProfile2:
            outerProfile = profile2
        # Create a extrusion based on the outer profile
        extrudeFeatures = rootComp.features.extrudeFeatures
        extrudeDistance = adsk.core.ValueInput.createByString("1 cm")
        extrudeFeature = extrudeFeatures.addSimple(outerProfile, extrudeDistance, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
 
        # Get start and end faces of the extrusion
        extrudeStartFaces = extrudeFeature.startFaces
        extrudeEndFaces = extrudeFeature.endFaces
        startFaceToken = extrudeStartFaces.item(0).entityToken        endFaceToken = extrudeEndFaces.item(0).entityToken
        # Create unstitch feature (so there are separate surface bodies)
        unstitchFeatures = rootComp.features.unstitchFeatures
        body = extrudeFeature.bodies.item(0)
        entities = adsk.core.ObjectCollection.create()
        entities.add(body)
        unstitchFeature = unstitchFeatures.add(entities)
        # Create untrim feature on start face (remove external loop and extend face)
        facesToUntrim = [];
        facesToUntrim.append(design.findEntityByToken(startFaceToken)[0])
        untrimFeatures = rootComp.features.untrimFeatures
        extensionDistance = adsk.core.ValueInput.createByReal(1.0)
        untrimFeatureInput = untrimFeatures.createInputFromFaces(facesToUntrim, adsk.fusion.UntrimLoopTypes.ExternalLoopsUntrimType, extensionDistance)
        untrimFeature = untrimFeatures.add(untrimFeatureInput)
 
        # Create untrim feature on the end face (remove internal loop from face)
        brepLoops = design.findEntityByToken(endFaceToken)[0].loops
        innerLoop = brepLoops.item(0)
        if innerLoop.isOuter:
            innerLoop = brepLoops.item(1)
        loopsToRemove = []
        loopsToRemove.append(innerLoop)
        untrimFeatureInput = untrimFeatures.createInputFromLoops(loopsToRemove);
        untrimFeature = untrimFeatures.add(untrimFeatureInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

BRep Body definition Sample
Description
Demonstrates creating BRep bodies by BRepBodyDefinition.
Code Samples
Python
Copy Code
#Author-
#Description-
import adsk.core, adsk.fusion, adsk.cam, traceback
        
def CreateTop1EdgeDefinitionByCurve(brepBodyDef):
    edgeDef = adsk.fusion.BRepEdgeDefinition.cast(None)
    # Create vertex definition
    startVertexDef = brepBodyDef.createVertexDefinition(adsk.core.Point3D.create(-3.519568866597467, 4.0, 1.5488831005318957))
    endVertexDef = brepBodyDef.createVertexDefinition(adsk.core.Point3D.create(-3.519568866597467, 4.0, -2.282227138902387)) 
    
    center = adsk.core.Point3D.create(-2.7379066676103037, 4.0, -0.3666720191852457)
    normal =adsk.core.Vector3D.create(0, 1, 0)
    curve = adsk.core.Circle3D.createByCenter(center, normal, 2.0689)
    # Create edge definition by curve
    edgeDef = brepBodyDef.createEdgeDefinitionByCurve(startVertexDef, endVertexDef, curve)
    
    return edgeDef    
def CreateBottom1EdgeDefinitionByCurve(brepBodyDef):
    edgeDef = adsk.fusion.BRepEdgeDefinition.cast(None)
    # Create vertex definition
    startVertexDef = brepBodyDef.createVertexDefinition(adsk.core.Point3D.create(-3.519568866597467, 0.0, -2.2822271389023863))
    endVertexDef = brepBodyDef.createVertexDefinition(adsk.core.Point3D.create(-3.519568866597467, 0.0, 1.5488831005318966)) 
    
    center = adsk.core.Point3D.create(-2.7379066676103037, 0.0, -0.36667201918524484)    normal =adsk.core.Vector3D.create(0, -1, 0)
    curve = adsk.core.Circle3D.createByCenter(center, normal, 2.0689)
    # Create edge definition by curve
    edgeDef = brepBodyDef.createEdgeDefinitionByCurve(startVertexDef, endVertexDef, curve)
    
    return edgeDef
def CreateLinearEdgeDefinitionByCurve(brepBodyDef, startPoint, endPoint):
    edgeDef = adsk.fusion.BRepEdgeDefinition.cast(None)
    # Create vertex definition
    startVertexDef = brepBodyDef.createVertexDefinition(startPoint)
    endVertexDef = brepBodyDef.createVertexDefinition(endPoint)  
    curve = adsk.core.Line3D.create(startPoint, endPoint)
    # Create edge definition by curve
    edgeDef = brepBodyDef.createEdgeDefinitionByCurve(startVertexDef, endVertexDef, curve)
    
    return edgeDef   
def GetNurbsSurfaceMiddle1():
    surface = adsk.core.NurbsSurface.cast(None)
    
    degreeU = 1
    degreeV = 2
    controlPointCountU = 2
    controlPointcountV = 7
    controlPoints = []
    controlPoints.append(adsk.core.Point3D.create(-3.519568866597467, 0.0, 1.5488831005318966))
    controlPoints.append(adsk.core.Point3D.create(-2.0550441756714655, 0.0, 2.1464976398353937))
    controlPoints.append(adsk.core.Point3D.create(-1.0943307562984703, 0.0, 0.8899128103250742))
    controlPoints.append(adsk.core.Point3D.create(-0.13361733692547517, 0.0, -0.36667201918524484))
    controlPoints.append(adsk.core.Point3D.create(-1.0943307562984705, 0.0, -1.6232568486955643))
    controlPoints.append(adsk.core.Point3D.create(-2.0550441756714664, 0.0, -2.8798416782058833))
    controlPoints.append(adsk.core.Point3D.create(-3.5195688665974676, 0.0, -2.2822271389023863))
    controlPoints.append(adsk.core.Point3D.create(-3.519568866597467, 4.0, 1.5488831005318957))
    controlPoints.append(adsk.core.Point3D.create(-2.0550441756714655, 4.0, 2.1464976398353928))
    controlPoints.append(adsk.core.Point3D.create(-1.0943307562984703, 4.0, 0.8899128103250733))
    controlPoints.append(adsk.core.Point3D.create(-0.13361733692547517, 4.0, -0.3666720191852457))
    controlPoints.append(adsk.core.Point3D.create(-1.0943307562984705, 4.0, -1.6232568486955652))
    controlPoints.append(adsk.core.Point3D.create(-2.0550441756714664, 4.0, -2.879841678205884))
    controlPoints.append(adsk.core.Point3D.create(-3.5195688665974676, 4.0, -2.282227138902387))
    knotsU = (-0.9666972787471603, -0.9666972787471603, 0.9666972787471603, 0.9666972787471603)
    knotsV = (-1.9582319586428225, -1.9582319586428225, -1.9582319586428225, -0.6527439862142743, -0.6527439862142743, 0.6527439862142739, 0.6527439862142739, 1.9582319586
    weights = (1.0, 0.7944201804397665, 1.0, 0.7944201804397665, 1.0, 0.7944201804397665, 1.0, 1.0, 0.7944201804397665, 1.0, 0.7944201804397665, 1.0, 0.7944201804397665, 1
    propertyU = 9
    propertyV = 9
    surface = adsk.core.NurbsSurface.create(degreeU, degreeV, controlPointCountU, controlPointcountV, controlPoints, knotsU, knotsV, weights, propertyU, propertyV)
    return surface
    
def GetNurbsSurfaceMiddle2():
    surface = adsk.core.NurbsSurface.cast(None)
    
    degreeU = 1
    degreeV = 1
    controlPointCountU = 2
    controlPointcountV = 2
    controlPoints = []
    controlPoints.append(adsk.core.Point3D.create(-3.519568866597467, 4.0, -2.282227138902387))
    controlPoints.append(adsk.core.Point3D.create(-3.519568866597467, 0, -2.2822271389023863))
    controlPoints.append(adsk.core.Point3D.create(-3.519568866597467, 4.0, 1.5488831005318957))
    controlPoints.append(adsk.core.Point3D.create(-3.519568866597467, 0, 1.5488831005318966))
    knotsU = (0, 0, 3.831110239434283, 3.831110239434283)
    knotsV = (0, 0, 4.0, 4.0)
    weights = ()
    propertyU = 1
    propertyV = 1
    surface = adsk.core.NurbsSurface.create(degreeU, degreeV, controlPointCountU, controlPointcountV, controlPoints, knotsU, knotsV, weights, propertyU, propertyV)
    
    return surface
    
def GetNurbsSurfaceTop():
    surface = adsk.core.NurbsSurface.cast(None)
    
    degreeU = 1
    degreeV = 1
    controlPointCountU = 2
    controlPointcountV = 2
    controlPoints = []
    controlPoints.append(adsk.core.Point3D.create(-3.519568866597467, 4.0, 1.7441010118322937))
    controlPoints.append(adsk.core.Point3D.create(-3.519568866597467, 4.0, -2.4732150714952117))
    controlPoints.append(adsk.core.Point3D.create(-0.6323626099308138, 4.0, 1.7441010118322937))
    controlPoints.append(adsk.core.Point3D.create(-0.6323626099308138, 4.0, -2.4732150714952117))
    knotsU = (-0.7816621989871636, -0.7816621989871636, 2.1055440576794897, 2.1055440576794897)
    knotsV = (-2.110773031017539, -2.110773031017539, 2.1065430523099655, 2.1065430523099655)
    weights = ()
    propertyU = 1
    propertyV = 1
    surface = adsk.core.NurbsSurface.create(degreeU, degreeV, controlPointCountU, controlPointcountV, controlPoints, knotsU, knotsV, weights, propertyU, propertyV)
    
    return surface
    
def GetNurbsSurfaceBottom():
    surface = adsk.core.NurbsSurface.cast(None)
    
    degreeU = 1
    degreeV = 1
    controlPointCountU = 2
    controlPointcountV = 2
    controlPoints = []
    controlPoints.append(adsk.core.Point3D.create(-0.6323626099308726, 0.0, 1.7398710331248253))
    controlPoints.append(adsk.core.Point3D.create(-0.6323626099308726, 0.0, -2.4774450502028094))
    controlPoints.append(adsk.core.Point3D.create(-3.5195688665974676, 0.0, 1.739871033124825))
    controlPoints.append(adsk.core.Point3D.create(-3.5195688665974676, 0.0, -2.47744505020281))
    knotsU = (-2.105544057679431, -2.105544057679431, 0.7816621989871635, 0.7816621989871635)
    knotsV = (-2.10654305231007, -2.10654305231007, 2.110773031017565, 2.110773031017565)    weights = ()
    propertyU = 1
    propertyV = 1
    surface = adsk.core.NurbsSurface.create(degreeU, degreeV, controlPointCountU, controlPointcountV, controlPoints, knotsU, knotsV, weights, propertyU, propertyV)    
    
    return surface
    
def CreateFaceForBodyDefination(brepBodyDef, surface, edgeDefs):   
    faceDef = adsk.fusion.BRepFaceDefinition.cast(None)
    
    # Create lump definition
    lumpDefs = brepBodyDef.lumpDefinitions
    lumpDef = lumpDefs.add()
    # Create shell definition
    shellDefs = lumpDef.shellDefinitions
    shellDef = shellDefs.add()
    # Create face definition
    faceDefs = shellDef.faceDefinitions
    faceDef = faceDefs.add(surface, True)
    # Create loop definition
    loopDefs = faceDef.loopDefinitions
    loopdef = loopDefs.add()
    
    # Create coEdge definitions
    brepCoEdgeDefs = loopdef.bRepCoEdgeDefinitions   
    for edgeDef in edgeDefs:
        brepCoEdgeDefs.add(edgeDef, True)
    return faceDef   
    
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Create a new document
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # Create a base feature
        rootComp = design.rootComponent
        
        # Create brep body definition     
        brepBodyDef = adsk.fusion.BRepBodyDefinition.create()
        
        # Create edge definition
        top1EdgeDef = CreateTop1EdgeDefinitionByCurve(brepBodyDef)
        bottom1EdgeDef = CreateBottom1EdgeDefinitionByCurve(brepBodyDef)
        
        startPoint = adsk.core.Point3D.create(-3.519568866597467, 4.0, -2.282227138902387)
        endPoint = adsk.core.Point3D.create(-3.519568866597467, 4.0, 1.5488831005318957)
        top2EdgeDef = CreateLinearEdgeDefinitionByCurve(brepBodyDef, startPoint, endPoint)
        
        startPoint = adsk.core.Point3D.create(-3.519568866597467, 0.0, 1.5488831005318966)
        endPoint = adsk.core.Point3D.create(-3.519568866597467, 0.0, -2.2822271389023863)
        bottom2EdgeDef = CreateLinearEdgeDefinitionByCurve(brepBodyDef, startPoint, endPoint)
        
        startPoint = adsk.core.Point3D.create(-3.519568866597467, 0.0, -2.2822271389023863)
        endPoint = adsk.core.Point3D.create(-3.519568866597467, 4.0, -2.282227138902387)
        middle1EdgeDef = CreateLinearEdgeDefinitionByCurve(brepBodyDef, startPoint, endPoint)
        
        startPoint = adsk.core.Point3D.create(-3.519568866597467, 4.0, 1.5488831005318957)
        endPoint = adsk.core.Point3D.create(-3.519568866597467, 0.0, 1.5488831005318966)
        middle2EdgeDef = CreateLinearEdgeDefinitionByCurve(brepBodyDef, startPoint, endPoint)
        # Create the top face for body definition
        topSurface = GetNurbsSurfaceTop() 
        topEdgeDefs = []
        topEdgeDefs.append(top1EdgeDef)
        topEdgeDefs.append(top2EdgeDef)
        CreateFaceForBodyDefination(brepBodyDef, topSurface, topEdgeDefs)
        # Create one middle face for body definition
        middel1Surface = GetNurbsSurfaceMiddle1()
        middel1EdgeDefs = []
        middel1EdgeDefs.append(top1EdgeDef)
        middel1EdgeDefs.append(middle1EdgeDef)
        middel1EdgeDefs.append(bottom1EdgeDef)
        middel1EdgeDefs.append(middle2EdgeDef)
        CreateFaceForBodyDefination(brepBodyDef, middel1Surface, middel1EdgeDefs)
        # Create another middle face for body defination        
        middel2Surface = GetNurbsSurfaceMiddle2()
        middel2EdgeDefs = []
        middel2EdgeDefs.append(top2EdgeDef)
        middel2EdgeDefs.append(middle1EdgeDef)
        middel2EdgeDefs.append(bottom2EdgeDef)
        middel2EdgeDefs.append(middle2EdgeDef)         
        CreateFaceForBodyDefination(brepBodyDef, middel2Surface, middel2EdgeDefs)
        # Create the bottom face for body definition        
        bottomSurface = GetNurbsSurfaceBottom()
        bottomEdgeDefs = []
        bottomEdgeDefs.append(bottom1EdgeDef)
        bottomEdgeDefs.append(bottom2EdgeDef)
        CreateFaceForBodyDefination(brepBodyDef, bottomSurface, bottomEdgeDefs)
        # Create brep body      
        body = brepBodyDef.createBody() 
        outcomeInfo = brepBodyDef.outcomeInfo
        print('The outcome info is :\n{}'.format(outcomeInfo))
        
        # Create wire brep body definition
        wireBrepBodyDef = adsk.fusion.BRepBodyDefinition.create() 
        # Create lump definition        lumpDefs = wireBrepBodyDef.lumpDefinitions
        lumpDef = lumpDefs.add()
        # Create shell definition
        shellDefs = lumpDef.shellDefinitions
        shellDef = shellDefs.add()
        # Create wire edge definitions        
        wireDef = shellDef.wireDefinition
        wireEdgeDefs = wireDef.wireEdgeDefinitions
        
        # Add wire edge definition
        startPoint = adsk.core.Point3D.create(2.499830308814756, 4.786795576310287, 0.0)
        endPoint = adsk.core.Point3D.create(6.000163479757444, 2.0712231354540322, 0.0)
        line = adsk.core.Line3D.create(startPoint, endPoint)
                
        center = adsk.core.Point3D.create(3.3848741924869366, 2.313878842520367, 0.0)
        normal =adsk.core.Vector3D.create(0, 0, 1.0)
        circle = adsk.core.Circle3D.createByCenter(center, normal, 2.626)
        startVertexDef = wireBrepBodyDef.createVertexDefinition(startPoint)
        endVertexDef = wireBrepBodyDef.createVertexDefinition(endPoint) 
        lineWireEdgeDef = wireEdgeDefs.add(startVertexDef, endVertexDef, line)
        circleWireEdgeDef = wireEdgeDefs.add(startVertexDef, endVertexDef, circle)
        
        # Set wire edge associative id
        lineWireEdgeDef.associativeID = 10
        print('The linear wire edge defination associative id is: {}'.format(lineWireEdgeDef.associativeID))
              
        # Create wire brep body 
        wireBrepBodyDef.doFullHealing = False
        wireBrepBody = wireBrepBodyDef.createBody()
        print('The wire brep body defination do full healing is: {}'.format(wireBrepBodyDef.doFullHealing))
        
        # Show the temporary brep bodies
        group = rootComp.customGraphicsGroups.add()
        group.addBRepBody(body)
        
        for edge in wireBrepBody.edges:
            group.addCurve(edge.geometry)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
BRep Body Sample
Description
B-Rep (Boundary Representation) body related functions
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create a sketch
        sketches = rootComp.sketches
        sketch1 = sketches.add(rootComp.yZConstructionPlane)
        # Get sketch lines
        sketchLines = sketch1.sketchCurves.sketchLines
        # Create sketch rectangle
        startPoint = adsk.core.Point3D.create(0, 0, 0)
        endPoint = adsk.core.Point3D.create(5.0, 5.0, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        # Get the profile
        prof = sketch1.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5.0)
        # Set the distance extent        extInput.setDistanceExtent(False, distance)
        # Set the extrude type to be solid
        extInput.isSolid = True
        # Create the extrusion
        ext = extrudes.add(extInput)
        # Get the body with the extrude
        brepBody = ext.bodies.item(0)
        
        # Get the original revision id of the BRep Body
        print(brepBody.revisionId)
        
        # Set the light bulb besides the body node in the browser to off
        brepBody.isLightBulbOn = False
        
        # Get the revision id of the BRep Body after having the body's light bulb off
        print(brepBody.revisionId)
        
        # Verify if the light bulb is on or off
        print(brepBody.isLightBulbOn)
        
        # Verify if the body is visible or not
        print(brepBody.isVisible)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

BrepW ire Sample
Description
BrepW ires and BrepW ire related functions
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, adsk.cam, traceback
def CreateWireBody():
    # Get temproray brep manager
    tempBrepMrg = adsk.fusion.TemporaryBRepManager.get() 
    
    conter = adsk.core.Point3D.create(10.0, 0.0, 5.0)
    normal = adsk.core.Vector3D.create(0.0, 0.0, 1.0)    circle1 = adsk.core.Circle3D.createByCenter(conter, normal, 3.0)
    circle2 = adsk.core.Circle3D.createByCenter(conter, normal, 2.0)
    curves = []
    curves.append(circle1)
    curves.append(circle2)     
    
    # Create wire from curves
    wireBody, edgeMap = tempBrepMrg.createWireFromCurves(curves)
    return wireBody
    
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Create a new document
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        
        # Set the design is a direct modelling design
        design.designType = adsk.fusion.DesignTypes.DirectDesignType
        
        #Get the root component
        rootComp = design.rootComponent
        
        # Create a sub component under root component
        occs = rootComp.occurrences
        transform = adsk.core.Matrix3D.create()
        subOcc = occs.addNewComponent(transform)  
        subComp = subOcc.component
    
        # Create temproray wire body 
        wireBody = CreateWireBody()
        
        # Add wireBody to sub-component
        bodies = subComp.bRepBodies
        bodies.add(wireBody)
        
        # Get the brep wire body
        brepWireBody = bodies.item(0)
        
        # Get brep wires
        brepWires = brepWireBody.wires
        
        # Get brep wires count
        count = brepWires.count
        print("BrepWires count is {}".format(count))
        
        # Get brep wire
        brepWire = brepWires.item(0)
        
        # Get brep edges from brepWire
        brepEdges = brepWire.edges
        
        # Get vertices from brepWire
        vertices = brepWire.vertices
        
        # Get brep coEdges from brepWire
        coEdges = brepWire.coEdges
        
        # Get the brep wire is planar or not
        isPlanar = brepWire.isPlanar
        print("Is the brep wire planar? {}".format(isPlanar))
        
        # Get wire's parent brep body
        parent = brepWire.parent
        
        # offse the planar brep wire
        offsetType = adsk.fusion.OffsetCornerTypes.LinearOffsetCornerType
        planeNormal = adsk.core.Vector3D.create(0.0, 0.0, 1.0)
        offsetBody = brepWire.offsetPlanarWire(planeNormal, 3.0, offsetType)
        # Create brep wire proxy    
        wireProxy = brepWire.createForAssemblyContext(subOcc)
        
        # Get native brep wire
        nativeBrepWire = wireProxy.nativeObject
        
        # Get the assembly occurrence
        occurence = wireProxy.assemblyContext
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Component Sample
Description
Component related functions
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        allOccs = rootComp.occurrences
        transform = adsk.core.Matrix3D.create()
        # Create a component under root component
        occ1 = allOccs.addNewComponent(transform)
        subComp1 = occ1.component
        print(subComp1.revisionId)
        # Create a sketch in sub component 1
        sketches1 = subComp1.sketches
        sketch1 = sketches1.add(rootComp.yZConstructionPlane)
        print(subComp1.revisionId)
        # Get sketch lines
        sketchLines = sketch1.sketchCurves.sketchLines
        # Create sketch rectangle
        startPoint = adsk.core.Point3D.create(-8.0, 0, 0)
        endPoint = adsk.core.Point3D.create(8.0, 8.0, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        print(subComp1.revisionId)
        # Get the profile of the first sketch
        prof1 = sketch1.profiles.item(0)
        # Create an extrusion input
        extrudes1 = subComp1.features.extrudeFeatures
        extInput1 = extrudes1.createInput(prof1, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        # Define that the extent is a distance extent of 2 cm
        distance1 = adsk.core.ValueInput.createByReal(2.0)
        # Set the distance extent
        extInput1.setDistanceExtent(False, distance1)
        # Set the extrude type to be solid
        extInput1.isSolid = True
        # Create the extrusion
        ext1 = extrudes1.add(extInput1)
        print(subComp1.revisionId)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Construction Axis API Sample
Description
Demonstrates creating construction axis in various ways.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
 
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 5.0)
        
        sketchLines = sketch.sketchCurves.sketchLines
        sketchLines.addTwoPointRectangle(adsk.core.Point3D.create(6, 6, 0), adsk.core.Point3D.create(-6, -6, 0))
        
        # Get the profile defined by the circle
        prof = sketch.profiles.item(1)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5)
        # Set the distance extent to be symmetric
        extInput.setDistanceExtent(True, distance)
        # Set the extrude to be a solid one
        extInput.isSolid = True
        # Create the extrusion
        ext = extrudes.add(extInput)
        
        # Get the body created by the extrusion
        body = ext.bodies.item(0)
        
        axes = rootComp.constructionAxes
        axisInput = axes.createInput()
        
        # Add by line
        if design.designType == adsk.fusion.DesignTypes.DirectDesignType:
            axisInput.setByLine(adsk.core.InfiniteLine3D.create(adsk.core.Point3D.create(0), adsk.core.Vector3D.create(1, 0, 0)))
            axes.add(axisInput)
        
        # Prepare reference data
        circularFace = None
        for face in body.faces:
            geom = face.geometry
            if geom.surfaceType == adsk.core.SurfaceTypes.CylinderSurfaceType:
                circularFace = face
                break
        
        linearEdge = None        for edge in body.edges:
            edgeGeom = edge.geometry
            if edgeGeom.curveType == adsk.core.Curve3DTypes.Line3DCurveType:
                linearEdge = edge
                break
        
        faceOne = linearEdge.faces.item(0)
        faceTwo = linearEdge.faces.item(1)
        vertexOne = faceOne.vertices.item(0)
        vertexTwo = faceOne.vertices.item(1)
        
        # Add by circularFace
        axisInput.setByCircularFace(circularFace)
        axes.add(axisInput)
        
        # Add by perpendicular at point
        axisInput.setByPerpendicularAtPoint(faceOne, vertexOne)
        axes.add(axisInput)
        
        # Add by two planes
        axisInput.setByTwoPlanes(faceOne, faceTwo)
        axes.add(axisInput)
        
        # Add by two points
        axisInput.setByTwoPoints(vertexOne, vertexTwo)
        axes.add(axisInput)
        
        # Add by edge
        axisInput.setByEdge(linearEdge)
        axes.add(axisInput)
        
        # Add by normal to face at point
        axisInput.setByNormalToFaceAtPoint(faceTwo, vertexOne)
        axis = axes.add(axisInput)
        
        # Get health state of the axis
        health = axis.healthState
        if health == adsk.fusion.FeatureHealthStates.WarningFeatureHealthState or health == adsk.fusion.FeatureHealthStates.ErrorFeatureHealthState:
            message = axis.errorOrWarningMessage
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Construction Plane API Sample
Description
Demonstrates creating construction plane by dif ferent ways.
Code SamplesPython
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        
        # Create sketch circle
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 5.0)        
        
        # Get the profile defined by the circle
        prof = sketch.profiles.item(0)
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5)
        # Set the distance extent to be symmetric
        extInput.setDistanceExtent(True, distance)
        # Set the extrude to be a solid one
        extInput.isSolid = True
        
        # Create an cylinder
        extrude = extrudes.add(extInput)
        # Create sketch line
        sketchLines = sketch.sketchCurves.sketchLines
        startPoint = adsk.core.Point3D.create(5, 5, 0)
        endPoint = adsk.core.Point3D.create(5, 10, 0)
        sketchLineOne = sketchLines.addByTwoPoints(startPoint, endPoint)
        endPointTwo = adsk.core.Point3D.create(10, 5, 0)
        sketchLineTwo = sketchLines.addByTwoPoints(startPoint, endPointTwo)
        
        # Create three sketch points
        sketchPoints = sketch.sketchPoints
        positionOne = adsk.core.Point3D.create(0, 5.0, 0)
        sketchPointOne = sketchPoints.add(positionOne)
        positionTwo = adsk.core.Point3D.create(5.0, 0, 0)
        sketchPointTwo = sketchPoints.add(positionTwo)
        positionThree = adsk.core.Point3D.create(0, -5.0, 0)
        sketchPointThree = sketchPoints.add(positionThree)
        
        # Get the profile again since the sketch has been edit.
        prof = sketch.profiles.item(0)
        
        # Get construction planes
        planes = rootComp.constructionPlanes
        
        # Create construction plane input
        planeInput = planes.createInput()
        
        # Add construction plane by offset
        offsetValue = adsk.core.ValueInput.createByReal(3.0)
        planeInput.setByOffset(prof, offsetValue)
        planeOne = planes.add(planeInput)
        
        # Get the health state of the plane
        health = planeOne.healthState
        if health == adsk.fusion.FeatureHealthStates.ErrorFeatureHealthState or health == adsk.fusion.FeatureHealthStates.WarningFeatureHealthState:
            message = planeOne.errorOrWarningMessage
        
        # Add construction plane by angle
        angle = adsk.core.ValueInput.createByString('30.0 deg')
        planeInput.setByAngle(sketchLineOne, angle, prof)
        planes.add(planeInput)
        
        # Add construction plane by two planes
        planeInput.setByTwoPlanes(prof, planeOne)
        planes.add(planeInput)
        
        # Add construction plane by tangent
        cylinderFace = extrude.sideFaces.item(0)
        planeInput.setByTangent(cylinderFace, angle, rootComp.xYConstructionPlane)
        planes.add(planeInput)
        
        # Add construction plane by two edges
        planeInput.setByTwoEdges(sketchLineOne, sketchLineTwo)
        planes.add(planeInput)
        
        # Add construction plane by three points
        planeInput.setByThreePoints(sketchPointOne, sketchPointTwo, sketchPointThree)        planes.add(planeInput)
        
        # Add construction plane by tangent at point
        planeInput.setByTangentAtPoint(cylinderFace, sketchPointOne)
        planes.add(planeInput)
        
        # Add construction plane by distance on path
        distance = adsk.core.ValueInput.createByReal(1.0)
        planeInput.setByDistanceOnPath(sketchLineOne, distance)
        planes.add(planeInput)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Construction Point API Sample
Description
Demonstrates creating construction point by dif ferent ways
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        # Get the root component of the active design
        rootComp = design.rootComponent
        # Create sketch
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        
        # Get sketch lines
        sketchLines = sketch.sketchCurves.sketchLines
        
        # Create sketch rectangle
        startPoint = adsk.core.Point3D.create(0, 0, 0)
        endPoint = adsk.core.Point3D.create(5.0, 5.0, 0)
        sketchLines.addTwoPointRectangle(startPoint, endPoint)
        
        # Get two sketch lines
        sketchLineOne = sketchLines.item(0)
        sketchLineTwo = sketchLines.item(1)
        
        # Get the profile
        prof = sketch.profiles.item(0)
        
        # Create an extrusion input
        extrudes = rootComp.features.extrudeFeatures
        extInput = extrudes.createInput(prof, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        
        # Define that the extent is a distance extent of 5 cm
        distance = adsk.core.ValueInput.createByReal(5.0)
        # Set the distance extent
        extInput.setDistanceExtent(False, distance)
        # Set the extrude type to be solid
        extInput.isSolid = True
        
        # Create the extrusion
        ext = extrudes.add(extInput)
        
        # Create a sketch circle
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(8, 8, 0)
        sketchCircle = sketchCircles.addByCenterRadius(centerPoint, 3.0)
        
        # Get the body with the extrude
        body = ext.bodies.item(0)
                # Get a vertex of the body
        vertex = body.vertices.item(0)
        
        # Get three intersect faces
        faceOne = vertex.faces.item(0)
        faceTwo = vertex.faces.item(1)
        faceThree = vertex.faces.item(2)
        
        # Create perpendicular construction axis
        axes = rootComp.constructionAxes
        axisInput = axes.createInput()
        axisInput.setByPerpendicularAtPoint(faceOne, vertex)
        axis = axes.add(axisInput)
        
        # Get construction points
        constructionPoints = rootComp.constructionPoints
        
        # Create construction point input
        pointInput = constructionPoints.createInput()
        
        # Create construction point by two points
        pointInput.setByTwoEdges(sketchLineOne, sketchLineTwo)
        constructionPoints.add(pointInput)
        # Create construction point by three planes
        pointInput.setByThreePlanes(faceOne, faceTwo, faceThree)
        constructionPoints.add(pointInput)
        
        # Create construction point by edge and plane
        pointInput.setByEdgePlane(axis, faceOne)
        constructionPoints.add(pointInput)
        
        # Create construction point by center
        pointInput.setByCenter(sketchCircle)
        constructionPoints.add(pointInput)
        
        # Create construction point by point
        pointInput.setByPoint(vertex)
        point = constructionPoints.add(pointInput)
        
        # Get the health state of the construction point
        health = point.healthState
        if health == adsk.fusion.FeatureHealthStates.ErrorFeatureHealthState or health == adsk.fusion.FeatureHealthStates.WarningFeatureHealthState:
            message = point.errorOrWarningMessage
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Interfer ence API Sample
Description
Demonstrates Interference APIs.
Code Samples
Python
C++
--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        design.designType = adsk.fusion.DesignTypes.DirectDesignType
        # Get the root component of the active design.
        rootComp = design.rootComponent
        features = rootComp.features
        # Create sketch circle on the xz plane.
        sketches = rootComp.sketches        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(0, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 10)
        # Create a collection of entities for extrude
        entities0 = adsk.core.ObjectCollection.create()
        entities0.add(sketch.profiles.item(0))
        # Create a cylinder with ExtrudeFeature using the profile above.
        extrudeFeats = features.extrudeFeatures
        extrudeFeatureInput = extrudeFeats.createInput(entities0, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeFeatureInput.isSolid = True
        extrudeFeatureInput.setDistanceExtent(False, adsk.core.ValueInput.createByReal(2.5))
        extrudeFeature = extrudeFeats.add(extrudeFeatureInput)
        
        # Create second body to do interference
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPoint = adsk.core.Point3D.create(5, 0, 0)
        sketchCircles.addByCenterRadius(centerPoint, 10)
        entities0.clear()
        entities0.add(sketch.profiles.item(0))
        # Create a cylinder with ExtrudeFeature using the profile above.
        extrudeFeatureInput = extrudeFeats.createInput(entities0, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
        extrudeFeatureInput.isSolid = True
        extrudeFeatureInput.setDistanceExtent(False, adsk.core.ValueInput.createByReal(2.5))
        extrudeFeature = extrudeFeats.add(extrudeFeatureInput)
        # Create a collection of bodies
        bodies = adsk.core.ObjectCollection.create()
        for body in rootComp.bRepBodies:
            bodies.add(body)
        # Create InterferenceInput
        input = design.createInterferenceInput(bodies)
        # Analyze interference
        results = design.analyzeInterference(input)
        # Create bodies
        results.createBodies(True)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

Mesh Body Sample
Description
Mesh body related functions
Code Samples
Python
C++
--
#Author-
#Description-
import adsk.core, adsk.fusion, traceback
import os.path
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Create a document
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
         
        # Get the root component
        rootComp = design.rootComponent
        
        # Create a sub component under root component
        occs = rootComp.occurrences
        transform = adsk.core.Matrix3D.create()
        subOcc = occs.addNewComponent(transform)
        
        # Insert a stl mesh body in the sub component
        subComp = subOcc.component
        meshBodies = subComp.meshBodies
        scriptDir = os.path.dirname(os.path.realpath(__file__))
        stlFilePath = os.path.join(scriptDir, 'APIMeshFacetColors.stl')
        meshBodies.add(stlFilePath, adsk.fusion.MeshUnits.InchMeshUnit)
        stlMeshBody = meshBodies.item(0)        meshBodyPorxy = stlMeshBody.createForAssemblyContext(subOcc)
        
        # Get and set mesh body name
        print("Get and set mesh body name.")
        print(stlMeshBody.name)
        stlMeshBody.name = "NewName"
        print(stlMeshBody.name)
        
        # Get and set mesh body selectable
        print("Get and set mesh body selectable.")
        print(stlMeshBody.isSelectable)
        stlMeshBody.isSelectable = False
        print(stlMeshBody.isSelectable)
        stlMeshBody.isSelectable = True
        print(stlMeshBody.isSelectable)
        
        # Get and set Mesh body bulb light and visibility
        print("Get and set Mesh body bulb light and visibility.")
        print(stlMeshBody.isLightBulbOn)
        stlMeshBody.isLightBulbOn = False
        print(stlMeshBody.isLightBulbOn)
        print(stlMeshBody.isVisible)
        stlMeshBody.isLightBulbOn = True
        print(stlMeshBody.isLightBulbOn)
        print(stlMeshBody.isVisible) 
        
        # Get and set mesh body Opacity
        print("Get and set mesh body Opacity.")
        print(stlMeshBody.opacity)
        subComp.opacity = 0.5
        stlMeshBody.opacity = 0.6
        print(stlMeshBody.opacity)
        print(meshBodyPorxy.visibleOpacity)
        
        # Get and set mesh body material
        print('Get and set meshbody material.')
        print(stlMeshBody.material.name)
        MaterialLib = app.materialLibraries.itemByName('Fusion 360 Material Library')
        material = MaterialLib.materials.itemByName("Glass, Bronze Glazing, Low E")
        stlMeshBody.material = material
        print(stlMeshBody.material.name)
        
        # Get and set mesh body appearance
        print('Get and set meshbody appearance.')
        print(stlMeshBody.appearance.name)
        appearanceLib = app.materialLibraries.itemByName('Fusion 360 Appearance Library')
        appearance = appearanceLib.appearances.itemByName('Glass - Window')
        stlMeshBody.appearance = appearance
        print(stlMeshBody.appearance.name)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

std::string getDllPath()
{
#if defined(_WINDOWS) || defined(_WIN32) || defined(_WIN64)
HMODULE hModule = NULL;
if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
(LPCSTR)&getDllPath,
&hModule))
return "";
char winTempPath[2048];
::GetModuleFileNameA(hModule, winTempPath, 2048);
std::string strPath = winTempPath;
size_t stPos = strPath.rfind('\\');
return strPath.substr(0, stPos);
#else
Dl_info info;
dladdr((void*)getDllPath, &info);
std::string strPath = info.dli_fname;
int stPos = (int)strPath.rfind('/');
if (stPos != -1)
return strPath.substr(0, stPos);
else
return "";;
#endif
}
TemporaryBRepManager  API Sample
Description
TemporaryBRepManager related functions
Code Samples
Python
C++
--
#Author-
#Description-
import adsk.core, adsk.fusion, adsk.cam, traceback
import os
def CreateBox():  
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get()    centerPoint = adsk.core.Point3D.create(0.0, 10.0, 0.0);
    lengthDir = adsk.core.Vector3D.create(1.0, 0.0, 0.0)
    widthDir = adsk.core.Vector3D.create(0.0, 1.0, 0.0)
    orientedBoundingBox3D = adsk.core.OrientedBoundingBox3D.create(centerPoint, 
                                                                   lengthDir,
                                                                   widthDir,
                                                                   5.0,
                                                                   6.0,
                                                                   2.0
                                                                   )
    # Create box                                                              
    box = tempBrepMgr.createBox(orientedBoundingBox3D)
    return box
def CreateCylinderOrCone(radius1, radius2):
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get()  
    
    point1 = adsk.core.Point3D.create(3.0, 3.0, 3.0)
    point2 = adsk.core.Point3D.create(-3.0, -3.0, -3.0)   
    
    # Create Cylinder Or Cone
    cylinderOrCone = tempBrepMgr.createCylinderOrCone(point1, 
                                                      radius1, 
                                                      point2, 
                                                      radius2
                                                      )   
    return cylinderOrCone
        
def CreateEllipticalCylinderOrCone(majorRadius1, minorRadius1, majorRadius2):
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get()  
    
    pointOne = adsk.core.Point3D.create(8.0, 3.0, 0.0)
    pointTwo = adsk.core.Point3D.create(8.0, -3.0, -3.0) 
    majorAxisDirection = adsk.core.Vector3D.create(1.0, 1.0, 1.0)
    
    # Create EllipticalCylinder Or Cone
    ellipicalCylinderOrCone = tempBrepMgr.createEllipticalCylinderOrCone(pointOne,
                                                                   majorRadius1,
                                                                   minorRadius1,
                                                                   pointTwo,
                                                                   majorRadius2,
                                                                   majorAxisDirection
                                                                  )      
    return ellipicalCylinderOrCone
   
def CreateSphere(radius):
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get()  
    
    sphereCenter = adsk.core.Point3D.create(0.0, 8.0, 8.0)
    # Create sphere
    sphere = tempBrepMgr.createSphere(sphereCenter, radius)
    
    return sphere
    
def CreateTorus(majorRadius, minorRadius):
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get()  
    
    axis = adsk.core.Vector3D.create(0.0, 0.0, 10.0)
    torusCenter = adsk.core.Point3D.create(0.0, 2.0, 8.0)
    # Create torus
    torus = tempBrepMgr.createTorus(torusCenter, 
                                    axis,
                                    majorRadius,
                                    minorRadius
                                    )
    return torus  
def PlaneIntersection(body):  
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get()  
    planeOrigin = adsk.core.Point3D.create(0.0, 0.0, 0.0)
    planeNormal = adsk.core.Vector3D.create(0.0, 0.0, 1.0)
    plane =  adsk.core.Plane.create(planeOrigin, planeNormal)
    
    # creates a brep body by the intersection between the input body and plane
    intersectionBody = tempBrepMgr.planeIntersection(body, plane) 
    return intersectionBody        
    
def TransformBody(body):
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get() 
    
    transform = adsk.core.Matrix3D.create()
    transform.translation = adsk.core.Vector3D.create(0.0, 0.0, -5.0)
    
    # Transforms the brep body using the specified transformation matrix
    isSuccess = tempBrepMgr.transform(body, transform)
    return isSuccess
    
def GetWireFromBody(body, index):
    brepWires = body.wires;
    brepWire = brepWires.item(index)
    return brepWire
    
def DeleteFacesOnBody(body, indexes, isDeleteSpecifiedFaces):
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get() 
    
    brepFaces = []    faces = body.faces
    for index in indexes:
        face = faces.item(index)
        brepFaces.append(face)
    
    # Delete faces on body
    isSuccess = tempBrepMgr.deleteFaces(brepFaces, isDeleteSpecifiedFaces)
    return isSuccess
    
def CreateSilhouette(face):
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get() 
    
    viewDirection = adsk.core.Vector3D.create(0.0, 0.0, 1.0)
    silhouetteBody = tempBrepMgr.createSilhouetteCurves(face, viewDirection, True)
    
    # Create silhouette body
    return silhouetteBody
    
def CreateWireFromCurves():
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get() 
    
    center = adsk.core.Point3D.create(10.0, 0.0, 5.0)
    normal = adsk.core.Vector3D.create(0.0, 0.0, 1.0)
    circle1 = adsk.core.Circle3D.createByCenter(center, normal, 3.0)
    circle2 = adsk.core.Circle3D.createByCenter(center, normal, 2.0)
    curves = []
    curves.append(circle1)
    curves.append(circle2)
    
    # Create wire from curves
    wireBody, edgeMap = tempBrepMgr.createWireFromCurves(curves)
    return wireBody, edgeMap
    
def CreateHelixBody():
    # Get TemporaryBRepManager
    tempBrepMgr = adsk.fusion.TemporaryBRepManager.get() 
    
    axisPoint = adsk.core.Point3D.create(10.0, 10.0, 10.0)
    axisVector = adsk.core.Vector3D.create(0.0, 1.0, 0.0)
    startPoint = adsk.core.Point3D.create(8.0, 2.0, 10.0)
    pitch = 1.0
    turns = 10
    taperAngle = 0.3
    
    # Create helix body
    helixBody = tempBrepMgr.createHelixWire(axisPoint,
                                axisVector,
                                startPoint,
                                pitch,
                                turns,
                                taperAngle
                                )
    return helixBody
    
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Create a new document with parametric design
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        product = app.activeProduct
        design = adsk.fusion.Design.cast(product)
        design.designType = adsk.fusion.DesignTypes.DirectDesignType
        
        # Get the root component of active design
        rootComp = design.rootComponent
        # Get bodies in root component
        bodies = rootComp.bRepBodies
        
        # Get TemporaryBRepManager
        tempBrepMgr = adsk.fusion.TemporaryBRepManager.get()
           
        # Create a temporary solid box
        box = CreateBox()
        
        # Check the temporary box property
        isTemporary = box.isTemporary
        print(("Is the Box temporary? {}").format(isTemporary))
        
        # Creates a temporary solid cylinder and cone BRepBody
        cylinder = CreateCylinderOrCone(3.0, 3.0)
        cone =  CreateCylinderOrCone(2.0, 4.0)
        
        # Creates a temporary elliptical solid cylinder and cone BrepBody
        ellipicalCylinder = CreateEllipticalCylinderOrCone(4.0, 2.0, 4.0)
        ellipicalCone = CreateEllipticalCylinderOrCone(3.0, 2.0, 4.5)
                      
        # Creates a temporary spherical BRepBody
        sphere = CreateSphere(3.0)
        
        # Creates a temporary toroidal BRepBody
        torus = CreateTorus(2.0, 1.0) 
        # creates a brep body by the intersection between the input body and plane
        intersectionBody = PlaneIntersection(box) 
        
        # Creates a temporary copy of the input BRepBody
        copiedBody = tempBrepMgr.copy(intersectionBody)
        
        # Transforms the brep body using the specified transformation matrix        isSuccess = TransformBody(copiedBody)
        print(("Is the transformation of the copied body successed? {}").format(isSuccess))
  
        # Get brep wires 
        brepWire = GetWireFromBody(intersectionBody, 0)
        copiedWire = GetWireFromBody(copiedBody, 0)
        
        #  Creates a new body by creating a ruled surface between the two input wire bodies. 
        surfaceBody = tempBrepMgr.createRuledSurface(brepWire, copiedWire)
        
        # Performs the specified Boolean operation between the two input bodies
        intersection = adsk.fusion.BooleanTypes.IntersectionBooleanType
        isSuccess = tempBrepMgr.booleanOperation(cylinder, cone, intersection)
        print(("Is the intersection boolean operation successed? {}").format(isSuccess))
        
        union = adsk.fusion.BooleanTypes.UnionBooleanType 
        isSuccess = tempBrepMgr.booleanOperation(ellipicalCylinder, ellipicalCone, union)        
        print(("Is the union boolean operation successed? {}").format(isSuccess))
        
        # Delete face from a temporary BRepBody
        indexes = [0,2]
        isSuccess = DeleteFacesOnBody(ellipicalCylinder, indexes, True)
        print(("Is faces deletion successed? {}").format(isSuccess))
        
        # Calculates the silhouette curve geometry for a given face as viewed from a given direction. 
        face = torus.faces.item(0)
        silhouetteBody = CreateSilhouette(face)
 
        # Create wire from curves
        wireBody, edgeMap = CreateWireFromCurves()
        
        # Creates a body from multiple wires that all lie within the same plane
        wireBodies = []
        wireBodies.append(wireBody)
        planerBody = tempBrepMgr.createFaceFromPlanarWires(wireBodies)
        
        # Create helix wire body    
        helixBody = CreateHelixBody()
        # Display the helix edges
        group = rootComp.customGraphicsGroups.add()
        for edge in helixBody.edges:
            group.addCurve(edge.geometry)
        # Add the temprary bodies to direct modeling design, 
        # then the temprary bodies will be displayed
        bodies.add(box)
        bodies.add(cylinder)
        bodies.add(cone)
        bodies.add(ellipicalCylinder)
        bodies.add(ellipicalCone)
        bodies.add(sphere)
        bodies.add(torus)
        bodies.add(intersectionBody)
        bodies.add(surfaceBody)
        bodies.add(silhouetteBody)
        bodies.add(planerBody)
        
        #Exports the input bodies to the specified file.
        brepBodies = []
        brepBodies.append(box)
        brepBodies.append(surfaceBody)
        
        scriptDir = os.path.dirname(os.path.realpath(__file__))
        exportPath = os.path.join(scriptDir, "sampleFile.smt")
        
        isSuccess = tempBrepMgr.exportToFile(brepBodies, exportPath)
        print(("Is the export to file success? {}").format(isSuccess))
        
        #Creates new BRepBody objects based on the contents of the specified file
        filePath = os.path.join(scriptDir, "sampleFile.smt")
        newBodies = tempBrepMgr.createFromFile(filePath);
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Copy Code

std::string getDllPath()
{
#if defined(_WINDOWS) || defined(_WIN32) || defined(_WIN64)
HMODULE hModule = NULL;
if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
(LPCSTR)&getDllPath,
&hModule))
return "";
char winTempPath[2048];
::GetModuleFileNameA(hModule, winTempPath, 2048);
std::string strPath = winTempPath;
size_t stPos = strPath.rfind('\\');
return strPath.substr(0, stPos);
#else
Dl_info info;
dladdr((void*)getDllPath, &info);
std::string strPath = info.dli_fname;
int stPos = (int)strPath.rfind('/');
if (stPos != -1)
return strPath.substr(0, stPos);
else
return "";;
#endif
}
Command Inputs API Sample
Description
Creates a command dialog that demonstrates all of the available command inputs.
To use the sample, create a new Python or C++ script and copy and paste this code, replacing the default code. You also need to unpack this zip file which contains a resource folder  into the
same folder where the source code file (.py or .cpp) is.
Code Samples
C++
Python
--

Copy Code
#Author-Autodesk Inc.
#Description-Demo command input examples
import adsk.core, adsk.fusion, traceback
_app = None
_ui  = None
_rowNumber = 0
# Global set of event handlers to keep them referenced for the duration of the command
_handlers = []
# Adds a new row to the table.
def addRowToTable(tableInput):
    global _rowNumber    # Get the CommandInputs object associated with the parent command.
    cmdInputs = adsk.core.CommandInputs.cast(tableInput.commandInputs)
    
    # Create three new command inputs.
    valueInput = cmdInputs.addValueInput('TableInput_value{}'.format(_rowNumber), 'Value', 'cm', adsk.core.ValueInput.createByReal(_rowNumber))
    stringInput =  cmdInputs.addStringValueInput('TableInput_string{}'.format(_rowNumber), 'String', str(_rowNumber))
    spinnerInput = cmdInputs.addIntegerSpinnerCommandInput('spinnerInt{}'.format(_rowNumber), 'Integer Spinner', 0 , 100 , 2, int(_rowNumber))
    
    # Add the inputs to the table.
    row = tableInput.rowCount
    tableInput.addCommandInput(valueInput, row, 0)
    tableInput.addCommandInput(stringInput, row, 1)
    tableInput.addCommandInput(spinnerInput, row, 2)
    
    # Increment a counter used to make each row unique.
    _rowNumber = _rowNumber + 1
def updateSliders(sliderInputs):
    """
    Populate 'slider_configuration' group with as many sliders as set in 'slider_controller'.
    Delete previous ones and create new sliders.
    """
    spinner = sliderInputs.itemById("slider_controller")
    value = spinner.value
    # check ranges
    if value > spinner.maximumValue or value < spinner.minimumValue:
        return
    # delete all sliders we have
    toRemove = []
    for i in range(sliderInputs.count):
        input = sliderInputs.item(i)
        if input.objectType == adsk.core.FloatSliderCommandInput.classType():
            toRemove.append(input)
    
    for input in toRemove:
        input.deleteMe()
    # create new ones with range depending on total number
    for i in range(1, value+1):
        id = str(i)
        sliderInputs.addFloatSliderCommandInput("slider_configuration_" + id, "slider_" + id, "cm", 0, 10.0*value)
# Event handler that reacts to any changes the user makes to any of the command inputs.
class MyCommandInputChangedHandler(adsk.core.InputChangedEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            eventArgs = adsk.core.InputChangedEventArgs.cast(args)
            inputs = eventArgs.inputs
            cmdInput = eventArgs.input
            # onInputChange for slider controller
            if cmdInput.id == "slider_controller":
                sliderGroup = adsk.core.GroupCommandInput.cast(cmdInput.parentCommandInput)
                sliderInputs = sliderGroup.children
                updateSliders(sliderInputs)
            else:
                tableInput = inputs.itemById('table')
                if cmdInput.id == 'tableAdd':
                    addRowToTable(tableInput)
                elif cmdInput.id == 'tableDelete':
                    if tableInput.selectedRow == -1:
                        _ui.messageBox('Select one row to delete.')
                    else:
                        tableInput.deleteRow(tableInput.selectedRow)
          
        except:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
# Event handler that reacts to when the command is destroyed. This terminates the script.            
class MyCommandDestroyHandler(adsk.core.CommandEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            # When the command is done, terminate the script
            # This will release all globals which will remove all event handlers
            adsk.terminate()
        except:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
# Event handler that reacts when the command definitio is executed which
# results in the command being created and this event being fired.
class MyCommandCreatedHandler(adsk.core.CommandCreatedEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            # Get the command that was created.
            cmd = adsk.core.Command.cast(args.command)
            # Connect to the command destroyed event.
            onDestroy = MyCommandDestroyHandler()
            cmd.destroy.add(onDestroy)
            _handlers.append(onDestroy)
            # Connect to the input changed event.           
            onInputChanged = MyCommandInputChangedHandler()
            cmd.inputChanged.add(onInputChanged)
            _handlers.append(onInputChanged)    
            # Get the CommandInputs collection associated with the command.            inputs = cmd.commandInputs
            # Create a tab input.
            tabCmdInput1 = inputs.addTabCommandInput('tab_1', 'Tab 1')
            tab1ChildInputs = tabCmdInput1.children
            # Create a read only textbox input.
            tab1ChildInputs.addTextBoxCommandInput('readonly_textBox', 'Text Box 1', 'This is an example of a read-only text box.', 2, True)
            # Create an editable textbox input.
            tab1ChildInputs.addTextBoxCommandInput('writable_textBox', 'Text Box 2', 'This is an example of an editable text box.', 2, False)
            
            # Create a message that spans the entire width of the dialog by leaving out the "name" argument.
            message = '<div align="center">A "full width" message using <a href="http:fusion360.autodesk.com">html.</a></div>'
            tab1ChildInputs.addTextBoxCommandInput('fullWidth_textBox', '', message, 1, True)            
            # Create a selection input.
            selectionInput = tab1ChildInputs.addSelectionInput('selection', 'Select', 'Basic select command input')
            selectionInput.setSelectionLimits(0)
            # Create a string value input.
            strInput = tab1ChildInputs.addStringValueInput('string', 'Text', 'Basic string command input')
            # Create value input.
            tab1ChildInputs.addValueInput('value', 'Value', 'cm', adsk.core.ValueInput.createByReal(0.0))
            # Create bool value input with checkbox style.
            tab1ChildInputs.addBoolValueInput('checkbox', 'Checkbox', True, '', False)
            # Create bool value input with button style that can be clicked.
            tab1ChildInputs.addBoolValueInput('buttonClick', 'Click Button', False, 'resources/button', True)
            # Create bool value input with button style that has a state.
            tab1ChildInputs.addBoolValueInput('buttonState', 'State Button', True, 'resources/button', True)
            # Create float slider input with two sliders.
            tab1ChildInputs.addFloatSliderCommandInput('floatSlider', 'Float Slider', 'cm', 0, 10.0, True)
            # Create float slider input with two sliders and a value list.
            floatValueList = [1.0, 3.0, 4.0, 7.0]
            tab1ChildInputs.addFloatSliderListCommandInput('floatSlider2', 'Float Slider 2', 'cm', floatValueList)
            # Create float slider input with two sliders and visible texts.
            floatSlider3 = tab1ChildInputs.addFloatSliderCommandInput('floatSlider3', 'Float Slider 3', '', 0, 50.0, False)
            floatSlider3.setText('Min', 'Max')
            # Create integer slider input with one slider.
            tab1ChildInputs.addIntegerSliderCommandInput('intSlider', 'Integer Slider', 0, 10);
            valueList = [1, 3, 4, 7, 11]
            # Create integer slider input with two sliders and a value list.
            tab1ChildInputs.addIntegerSliderListCommandInput('intSlider2', 'Integer Slider 2', valueList)
            # Create float spinner input.
            tab1ChildInputs.addFloatSpinnerCommandInput('spinnerFloat', 'Float Spinner', 'cm', 0.2 , 9.0 , 2.2, 1)
            # Create integer spinner input.
            tab1ChildInputs.addIntegerSpinnerCommandInput('spinnerInt', 'Integer Spinner', 2 , 9 , 2, 3)
            # Create dropdown input with checkbox style.
            dropdownInput = tab1ChildInputs.addDropDownCommandInput('dropdown', 'Dropdown 1', adsk.core.DropDownStyles.CheckBoxDropDownStyle)
            dropdownItems = dropdownInput.listItems
            dropdownItems.add('Item 1', False, 'resources/One')
            dropdownItems.add('Item 2', False, 'resources/Two')
            # Create dropdown input with icon style.
            dropdownInput2 = tab1ChildInputs.addDropDownCommandInput('dropdown2', 'Dropdown 2', adsk.core.DropDownStyles.LabeledIconDropDownStyle);
            dropdown2Items = dropdownInput2.listItems
            dropdown2Items.add('Item 1', True, 'resources/One')
            dropdown2Items.add('Item 2', False, 'resources/Two')
            # Create dropdown input with radio style.
            dropdownInput3 = tab1ChildInputs.addDropDownCommandInput('dropdown3', 'Dropdown 3', adsk.core.DropDownStyles.LabeledIconDropDownStyle);
            dropdown3Items = dropdownInput3.listItems
            dropdown3Items.add('Item 1', True, '')
            dropdown3Items.add('Item 2', False, '')
            # Create dropdown input with test list style.
            dropdownInput4 = tab1ChildInputs.addDropDownCommandInput('dropdown4', 'Dropdown 4', adsk.core.DropDownStyles.TextListDropDownStyle);
            dropdown4Items = dropdownInput4.listItems
            dropdown4Items.add('Item 1', True, '')
            dropdown4Items.add('Item 2', False, '')
            # Create single selectable button row input.
            buttonRowInput = tab1ChildInputs.addButtonRowCommandInput('buttonRow', 'Single Select Buttons', False)
            buttonRowInput.listItems.add('Item 1', False, 'resources/One')
            buttonRowInput.listItems.add('Item 2', False, 'resources/Two')
            # Create multi selectable button row input.
            buttonRowInput2 = tab1ChildInputs.addButtonRowCommandInput('buttonRow2', 'Multi-select Buttons', True)
            buttonRowInput2.listItems.add('Item 1', False, 'resources/One')
            buttonRowInput2.listItems.add('Item 2', False, 'resources/Two')
            # Create tab input 2
            tabCmdInput2 = inputs.addTabCommandInput('tab_2', 'Tab 2')
            tab2ChildInputs = tabCmdInput2.children
            # Create group input.
            groupCmdInput = tab2ChildInputs.addGroupCommandInput('group', 'Group')
            groupCmdInput.isExpanded = True
            groupCmdInput.isEnabledCheckBoxDisplayed = True
            groupChildInputs = groupCmdInput.children
            
            # Create radio button group input.
            radioButtonGroup = groupChildInputs.addRadioButtonGroupCommandInput('radioButtonGroup', 'Radio button group')            radioButtonItems = radioButtonGroup.listItems
            radioButtonItems.add("Item 1", False)
            radioButtonItems.add("Item 2", False)
            radioButtonItems.add("Item 3", False)
            
            # Create image input.
            groupChildInputs.addImageCommandInput('image', 'Image', "resources/image.png")
            
            # Create direction input 1.
            directionCmdInput = tab2ChildInputs.addDirectionCommandInput('direction', 'Direction1')
            directionCmdInput.setManipulator(adsk.core.Point3D.create(0, 0, 0), adsk.core.Vector3D.create(1, 0, 0))
            
            # Create direction input 2.
            directionCmdInput2 = tab2ChildInputs.addDirectionCommandInput('direction2', 'Direction 2', 'resources/One')
            directionCmdInput2.setManipulator(adsk.core.Point3D.create(0, 0, 0), adsk.core.Vector3D.create(0, 1, 0)) 
            directionCmdInput2.isDirectionFlipped = True
            
            # Create distance value input 1.
            distanceValueInput = tab2ChildInputs.addDistanceValueCommandInput('distanceValue', 'DistanceValue', adsk.core.ValueInput.createByReal(2))
            distanceValueInput.setManipulator(adsk.core.Point3D.create(0, 0, 0), adsk.core.Vector3D.create(1, 0, 0))
            distanceValueInput.minimumValue = 0
            distanceValueInput.isMinimumValueInclusive = True
            distanceValueInput.maximumValue = 10
            distanceValueInput.isMaximumValueInclusive = True
            
            # Create distance value input 2.
            distanceValueInput2 = tab2ChildInputs.addDistanceValueCommandInput('distanceValue2', 'DistanceValue 2', adsk.core.ValueInput.createByReal(1))
            distanceValueInput2.setManipulator(adsk.core.Point3D.create(0, 0, 0), adsk.core.Vector3D.create(0, 1, 0))
            distanceValueInput2.expression = '1 in'
            distanceValueInput2.hasMinimumValue = False
            distanceValueInput2.hasMaximumValue = False
            
            # Create table input
            tableInput = tab2ChildInputs.addTableCommandInput('table', 'Table', 3, '1:1:1')
            addRowToTable(tableInput)
            # Add inputs into the table.            
            addButtonInput = tab2ChildInputs.addBoolValueInput('tableAdd', 'Add', False, '', True)
            tableInput.addToolbarCommandInput(addButtonInput)
            deleteButtonInput = tab2ChildInputs.addBoolValueInput('tableDelete', 'Delete', False, '', True)
            tableInput.addToolbarCommandInput(deleteButtonInput)
            
            # Create angle value input.
            angleValueInput = tab2ChildInputs.addAngleValueCommandInput('angleValue', 'AngleValue', adsk.core.ValueInput.createByString('30 degree'))
            angleValueInput.setManipulator(adsk.core.Point3D.create(0, 0, 0), adsk.core.Vector3D.create(1, 0, 0), adsk.core.Vector3D.create(0, 0, 1))
            angleValueInput.hasMinimumValue = False
            angleValueInput.hasMaximumValue = False
            # Create tab input 3
            tabCmdInput3 = inputs.addTabCommandInput('tab_3', 'Tab 3')
            tab3ChildInputs = tabCmdInput3.children
            # Create group
            sliderGroup = tab3ChildInputs.addGroupCommandInput("slider_configuration", "Configuration")
            sliderInputs = sliderGroup.children
            # Create integer spinner input
            sliderInputs.addIntegerSpinnerCommandInput("slider_controller", "Num sliders", 1, 5, 1, 1)
            updateSliders(sliderInputs)
        except:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
def run(context):
    try:
        global _app, _ui
        _app = adsk.core.Application.get()
        _ui = _app.userInterface
        # Get the existing command definition or create it if it doesn't already exist.
        cmdDef = _ui.commandDefinitions.itemById('cmdInputsSample')
        if not cmdDef:
            cmdDef = _ui.commandDefinitions.addButtonDefinition('cmdInputsSample', 'Command Inputs Sample', 'Sample to demonstrate various command inputs.')
        # Connect to the command created event.
        onCommandCreated = MyCommandCreatedHandler()
        cmdDef.commandCreated.add(onCommandCreated)
        _handlers.append(onCommandCreated)
        # Execute the command definition.
        cmdDef.execute()
        # Prevent this module from being terminated when the script returns, because we are waiting for event handlers to fire.
        adsk.autoTerminate(False)
    except:
        if _ui:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
File Dialog Sample
Description
Demonstrating how to pop up a file dialog and a folder dialog.
Code Samples
C++
Python--

Copy Code
import adsk.core, adsk.fusion, traceback
import os.path
def run(context):
    ui = None    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
            
        msg = ''
        # Set styles of file dialog.
        fileDlg = ui.createFileDialog()
        fileDlg.isMultiSelectEnabled = True
        fileDlg.title = 'Fusion Open File Dialog'
        fileDlg.filter = '*.*'
        
        # Show file open dialog
        dlgResult = fileDlg.showOpen()
        if dlgResult == adsk.core.DialogResults.DialogOK:
            msg += '\nFiles to Open:'
            for filename in fileDlg.filenames:
                msg += '\n\t{}'.format(filename)
        else:
            return       
        
        # Show file save dialog
        fileDlg.title = 'Fusion Save File Dialog'
        dlgResult = fileDlg.showSave()
        if dlgResult == adsk.core.DialogResults.DialogOK:
            msg += '\nFile to Save: {}'.format(fileDlg.filename)
        else:
            return
            
        # Set styles of file dialog.
        folderDlg = ui.createFolderDialog()
        folderDlg.title = 'Fusion Choose Folder Dialog' 
        
        # Show folder dialog
        dlgResult = folderDlg.showDialog()
        if dlgResult == adsk.core.DialogResults.DialogOK:
            msg += '\nSelected Folder: {}'.format(folderDlg.folder)
        else:
            return
        
        ui.messageBox(msg)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Marking Menu API Sample
Description
Demonstrates how to customize marking menu and context menu. This sample is an add-in. To use it, create a new add-in using the "Scrips and Add-Ins" command. Use any name you
would like for the add-in. In the folder where the add-in was created edit the add-in name .py file and replace it's entire contents with the sample code below . You can also delete all the
other files that were created for the add-in except for add-in name .manifiest. Start the add-in from the "Scripts and Add-Ins" dialog. Now , with the add-in running, whenever you right-click
in the Fusion window , you'll get an entirely customized context menu. The default marking menu has been modified by the add-in by removing the existing commands and adding some
custom commands.
Code Samples
C++
Python
--

Copy Code
#Author-
#Description-
import adsk.core, adsk.fusion, adsk.cam, traceback
# global mapping list of event handlers to keep them referenced for the duration of the command
#handlers = {}
handlers = []
cmdDefs = []entities = []
def run(context):
    ui = None
    handlers.clear()
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        def setLinearMarkingMenu(args):
            try:
                menuArgs = adsk.core.MarkingMenuEventArgs.cast(args)
                cmdDefSelectedEntities = ui.commandDefinitions.itemById('PrintSelectedEntities')
                cmdDef = ui.commandDefinitions.itemById('TestCommand')
                
                commands = []
                commands.append(cmdDefSelectedEntities)
                commands.append(cmdDef)
                    
                linearMenu = menuArgs.linearMarkingMenu                                        
                # linear
                linearMenu.clear()
                linearMenu.controls.addCommand(cmdDef)
                linearMenu.controls.addCommand(cmdDefSelectedEntities)
                linearMenu.controls.addSeparator('LinearSeparator')
                dropdown = linearMenu.controls.addDropDown('Linear Sub Menu', '', 'LinearSubMenu')
                subDropDown = dropdown.controls.addDropDown('sub sub', '', 'Sub Sub')
                for cmd in commands:
                    dropdown.controls.addCommand(cmd)
                    subDropDown.controls.addCommand(cmd)
                
                if args.selectedEntities:
                    sel0 = args.selectedEntities[0]
                    # special command if brep entities selected
                    body = adsk.fusion.BRepBody.cast(sel0)
                    face = adsk.fusion.BRepFace.cast(sel0)
                    edge = adsk.fusion.BRepEdge.cast(sel0)
                    vertex = adsk.fusion.BRepVertex.cast(sel0)
                    if body or face or edge or vertex:
                        cmdDefSpecial = ui.commandDefinitions.itemById('BrepCommand')
                        linearMenu.controls.addCommand(cmdDefSpecial)
                    
                    # special command if sketch entities selected
                    sketch = adsk.fusion.Sketch.cast(sel0)
                    prof = adsk.fusion.Profile.cast(sel0)
                    sketchEntity = adsk.fusion.SketchEntity.cast(sel0)
                    if sketch or sketchEntity or prof:
                        cmdDefSpecial = ui.commandDefinitions.itemById('SketchCommand')
                        linearMenu.controls.addCommand(cmdDefSpecial)        
            except:
                if ui:
                    ui.messageBox('setting linear menu failed: {}').format(traceback.format_exc())
        def setRadialMarkingMenu(args):
            try:
                menuArgs = adsk.core.MarkingMenuEventArgs.cast(args)    
                cmdDefSelectedEntities = ui.commandDefinitions.itemById('PrintSelectedEntities')
                cmdDef = ui.commandDefinitions.itemById('TestCommand')
                    
                radialMenu = menuArgs.radialMarkingMenu            
                # radial
                radialMenu.clear()
                
                subRadial = radialMenu.create("test")
                subRadial.text = "sub"
                
                subsubRadial = subRadial.create('sub sub')
                # sub sub
                subsubRadial.westCommand = cmdDef
                subsubRadial.northCommand = cmdDef
                subsubRadial.southCommand = cmdDefSelectedEntities
                subsubRadial.eastCommand = cmdDef
                
                # sub radial menu
                subRadial.northwestCommand = subsubRadial
                subRadial.southeastCommand = cmdDef
                subRadial.southwestCommand = cmdDef
                subRadial.northeastCommand = cmdDefSelectedEntities
                
                # root radial menu
                radialMenu.eastCommand = cmdDef
                radialMenu.westCommand = cmdDef
                radialMenu.northCommand = cmdDef
                radialMenu.southCommand = cmdDef
                radialMenu.northeastCommand = subRadial
                radialMenu.northwestCommand = cmdDefSelectedEntities
                radialMenu.southeastCommand = cmdDef
                radialMenu.southwestCommand = cmdDef
                
            except:
                if ui:
                    ui.messageBox('setting radial menu failed: {}').format(traceback.format_exc())
        class MyCommandCreatedEventHandler(adsk.core.CommandCreatedEventHandler):
            def __init__(self):
                super().__init__()
            def notify(self, args):
                try:
                    command = args.command                                     
                    onCommandExcute = MyCommandExecuteHandler()
                    handlers.append(onCommandExcute)
                    command.execute.add(onCommandExcute)
                except:
                    ui.messageBox('command created failed: {}').format(traceback.format_exc())
                class MyCommandExecuteHandler(adsk.core.CommandEventHandler):
            def __init__(self):
                super().__init__()
            def notify(self, args):
                try:
                    command = args.firingEvent.sender
                    cmdDef = command.parentCommandDefinition
                    if cmdDef:
                        if cmdDef.id == 'PrintSelectedEntities':
                            if entities:
                                entityList = 'selected entities:'
                                for e in entities:
                                    entityList += '\n' + str(e)
                                ui.messageBox(entityList)
                            else:
                                ui.messageBox('No selected entity.')                                    
                        else:
                            ui.messageBox('command {} triggered.'.format(cmdDef.id))
                    else:
                        ui.messageBox('No CommandDefinition')
                except:
                    if ui:
                        ui.messageBox('command executed failed: {}').format(traceback.format_exc())
                        
        class MyMarkingMenuHandler(adsk.core.MarkingMenuEventHandler):
            def __init__(self):
                super().__init__()
            def notify(self, args):
                try:                    
                    setLinearMarkingMenu(args)
                    setRadialMarkingMenu(args)
                    
                    # selected entities
                    global entities
                    entities.clear()
                    entities = args.selectedEntities
                except:
                    if ui:
                        ui.messageBox('Marking Menu Displaying event failed: {}'.format(traceback.format_exc()))
        
        # Add customized handler for marking menu displaying
        onMarkingMenuDisplaying = MyMarkingMenuHandler()                   
        handlers.append(onMarkingMenuDisplaying)                     
        ui.markingMenuDisplaying.add(onMarkingMenuDisplaying)
        
        # Add customized handler for commands creating
        onCommandCreated = MyCommandCreatedEventHandler()        
        handlers.append(onCommandCreated)
        # Create a command to print selected entities
        cmdDefSelectedEntities = ui.commandDefinitions.itemById('PrintSelectedEntities')
        if not cmdDefSelectedEntities:
            cmdDefSelectedEntities = ui.commandDefinitions.addButtonDefinition('PrintSelectedEntities', 'Print Entities', 'Print selected entities.')     
            cmdDefSelectedEntities.commandCreated.add(onCommandCreated) 
            cmdDefs.append(cmdDefSelectedEntities)
            
        # Create a test command
        cmdDef = ui.commandDefinitions.itemById('TestCommand')
        if not cmdDef:
            cmdDef = ui.commandDefinitions.addButtonDefinition('TestCommand', 'Test Command', 'Test Command')            
            cmdDef.commandCreated.add(onCommandCreated)  
            cmdDefs.append(cmdDef)         
        # Create special command for brep entities
        cmdDefBRepSpecial = ui.commandDefinitions.itemById('BrepCommand')
        if not cmdDefBRepSpecial:
            cmdDefBRepSpecial = ui.commandDefinitions.addButtonDefinition('BrepCommand', 'Brep Command', 'This is a command for brep entities.')            
            cmdDefBRepSpecial.commandCreated.add(onCommandCreated)  
            cmdDefs.append(cmdDefBRepSpecial)
            
        # Create special command for sketch entities
        cmdDefSketchSpecial = ui.commandDefinitions.itemById('SketchCommand')
        if not cmdDefSketchSpecial:
            cmdDefSketchSpecial = ui.commandDefinitions.addButtonDefinition('SketchCommand', 'Sketch Command', 'This is a command for sketch entities.')            
            cmdDefSketchSpecial.commandCreated.add(onCommandCreated)  
            cmdDefs.append(cmdDefSketchSpecial)
            
        
        ui.messageBox('Right click to see the customized marking menu.')        
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
def stop(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        for obj in cmdDefs:
            if obj.isValid:
                obj.deleteMe()
            else:
                ui.messageBox(str(obj) + ' is not a valid object')
        handlers.clear()
        
        ui.messageBox('Stop addin')
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))Palette Sample
Description
Demonstrates how to create a palette, how to dock and snap palettes and how Fusion communicates with the palette HTML. The sample is an add-in. To use it, create a new Python add-in
and replace the code with the code below . You also need to create an html file using the name and code below . The html file needs to be in the same folder as the py file.
When you load the add-in, you'll see two new commands under the ADD-INS panel of the TOOLS tab. The "Show Custom Palette" command will cause the custom palette to be displayed.
It will remain displayed until you click its Close button. Clicking the "Click to send info to Fusion" button on the palette, will send information to your add-in, which uses the API to
display that information in a message box. Running the "Send Info to HTML" command to send data to the javascript running in the palette, which uses it to update the content of a
paragraph.
palette.html
<!DOCTYPE html>
<html>
    <head>
    </head>
    <body>
        <p>Click the button below to send data to Fusion.</p>
        <button type='button' onclick='sendInfoToFusion()'>Click to send info to Fusion</button> 
        <p id='p1'>Run the "Send Info to HTML" command in the ADD-INS panel to update this text.</p>
        <br /><br />
    </body>
    <script>
        function sendInfoToFusion(){
            var today = new Date();
            var dd = String(today.getDate()).padStart(2, '0');
            var mm = String(today.getMonth() + 1).padStart(2, '0');
            var yyyy = today.getFullYear();
            var hours = String(today.getHours()).padStart(2, '0');
            var minutes = String(today.getMinutes()).padStart(2, '0');
            var seconds = String(today.getSeconds()).padStart(2, '0');
            var date = dd + '/' + mm + '/' + yyyy;
            var time = hours + ':' + minutes + ':' + seconds;
            var args = {
                arg1 : "Sample argument 1",
                arg2 : "Sample argument 2"
            };
            adsk.fusionSendData('send', JSON.stringify(args));
        }
        
        window.fusionJavaScriptHandler = {handle: function(action, data){
            try {
                if (action == 'send') {
// Update a paragraph with the data passed in.
document.getElementById('p1').innerHTML = data;
}
else if (action == 'debugger') {
                    debugger;
}
else {
return 'Unexpected command type: ' + action;
                }
            } catch (e) {
                console.log(e);
                console.log('exception caught with command: ' + action + ', data: ' + data);
            }
            return 'OK';
        }};
    </script>
</html>
Code Samples
Python
--
import adsk.core, adsk.fusion, adsk.cam, traceback
import json
# global set of event handlers to keep them referenced for the duration of the command
handlers = []
_app = adsk.core.Application.cast(None)
_ui = adsk.core.UserInterface.cast(None)
num = 0
# Event handler for the commandExecuted event.
class ShowPaletteCommandExecuteHandler(adsk.core.CommandEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            # Create and display the palette.
            palette = _ui.palettes.itemById('myPalette')
            if not palette:
                palette = _ui.palettes.add('myPalette', 'My Palette', 'palette.html', True, True, True, 300, 200)
                # Dock the palette to the right side of Fusion window.                palette.dockingState = adsk.core.PaletteDockingStates.PaletteDockStateRight
    
                # Add handler to HTMLEvent of the palette.
                onHTMLEvent = MyHTMLEventHandler()
                palette.incomingFromHTML.add(onHTMLEvent)   
                handlers.append(onHTMLEvent)
    
                # Add handler to CloseEvent of the palette.
                onClosed = MyCloseEventHandler()
                palette.closed.add(onClosed)
                handlers.append(onClosed)   
            else:
                palette.isVisible = True                               
        except:
            _ui.messageBox('Command executed failed: {}'.format(traceback.format_exc()))
# Event handler for the commandCreated event.
class ShowPaletteCommandCreatedHandler(adsk.core.CommandCreatedEventHandler):
    def __init__(self):
        super().__init__()              
    def notify(self, args):
        try:
            command = args.command
            onExecute = ShowPaletteCommandExecuteHandler()
            command.execute.add(onExecute)
            handlers.append(onExecute)                                     
        except:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))     
# Event handler for the commandExecuted event.
class SendInfoCommandExecuteHandler(adsk.core.CommandEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            # Send information to the palette. This will trigger an event in the javascript
            # within the html so that it can be handled.
            palette = _ui.palettes.itemById('myPalette')
            if palette:
                global num
                num += 1
                palette.sendInfoToHTML('send', 'This is a message sent to the palette from Fusion. It has been sent {} times.'.format(num))                        
        except:
            _ui.messageBox('Command executed failed: {}'.format(traceback.format_exc()))
# Event handler for the commandCreated event.
class SendInfoCommandCreatedHandler(adsk.core.CommandCreatedEventHandler):
    def __init__(self):
        super().__init__()              
    def notify(self, args):
        try:
            command = args.command
            onExecute = SendInfoCommandExecuteHandler()
            command.execute.add(onExecute)
            handlers.append(onExecute)                                     
        except:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))     
# Event handler for the palette close event.
class MyCloseEventHandler(adsk.core.UserInterfaceGeneralEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            _ui.messageBox('Close button is clicked.') 
        except:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
# Event handler for the palette HTML event.                
class MyHTMLEventHandler(adsk.core.HTMLEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            htmlArgs = adsk.core.HTMLEventArgs.cast(args)            
            data = json.loads(htmlArgs.data)
            msg = "An event has been fired from the html to Fusion with the following data:\n"
            msg += '    Command: {}\n    arg1: {}\n    arg2: {}'.format(htmlArgs.action, data['arg1'], data['arg2'])
            _ui.messageBox(msg)
        except:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))           
                
def run(context):
    try:
        global _ui, _app
        _app = adsk.core.Application.get()
        _ui  = _app.userInterface
        
        # Add a command that displays the panel.
        showPaletteCmdDef = _ui.commandDefinitions.itemById('showPalette')
        if not showPaletteCmdDef:
            showPaletteCmdDef = _ui.commandDefinitions.addButtonDefinition('showPalette', 'Show Custom Palette', 'Show the custom palette', '')
            # Connect to Command Created event.
            onCommandCreated = ShowPaletteCommandCreatedHandler()
            showPaletteCmdDef.commandCreated.add(onCommandCreated)
            handlers.append(onCommandCreated)
        
                 # Add a command under ADD-INS panel which sends information from Fusion to the palette's HTML.
        sendInfoCmdDef = _ui.commandDefinitions.itemById('sendInfoToHTML')
        if not sendInfoCmdDef:
            sendInfoCmdDef = _ui.commandDefinitions.addButtonDefinition('sendInfoToHTML', 'Send Info to Palette', 'Send Info to Palette HTML', '')
            # Connect to Command Created event.
            onCommandCreated = SendInfoCommandCreatedHandler()
            sendInfoCmdDef.commandCreated.add(onCommandCreated)
            handlers.append(onCommandCreated)
        # Add the command to the toolbar.
        panel = _ui.allToolbarPanels.itemById('SolidScriptsAddinsPanel')
        cntrl = panel.controls.itemById('showPalette')
        if not cntrl:
            panel.controls.addCommand(showPaletteCmdDef)
        cntrl = panel.controls.itemById('sendInfoToHTML')
        if not cntrl:
            panel.controls.addCommand(sendInfoCmdDef)
    except:
        if _ui:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
def stop(context):
    try:        
        # Delete the palette created by this add-in.
        palette = _ui.palettes.itemById('myPalette')
        if palette:
            palette.deleteMe()
            
        # Delete controls and associated command definitions created by this add-ins
        panel = _ui.allToolbarPanels.itemById('SolidScriptsAddinsPanel')
        cmd = panel.controls.itemById('showPalette')
        if cmd:
            cmd.deleteMe()
        cmdDef = _ui.commandDefinitions.itemById('showPalette')
        if cmdDef:
            cmdDef.deleteMe() 
        cmd = panel.controls.itemById('sendInfoToHTML')
        if cmd:
            cmd.deleteMe()
        cmdDef = _ui.commandDefinitions.itemById('sendInfoToHTML')
        if cmdDef:
            cmdDef.deleteMe() 
            
        _ui.messageBox('Stop addin')
    except:
        if _ui:
            _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Progress Dialog API Sample
Description
Demonstrates how to use progress dialog
Code Samples
C++
Python
Copy Code

--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # Create a document.
        doc = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)        
        
        # Set styles of progress dialog.
        progressDialog = ui.createProgressDialog()
        progressDialog.cancelButtonText = 'Cancel'
        progressDialog.isBackgroundTranslucent = False
        progressDialog.isCancelButtonShown = True
        
        # Show dialog
        progressDialog.show('Progress Dialog', 'Percentage: %p, Current Value: %v, Total steps: %m', 0, 50, 1)        
        # Draw sketches and update status.
        design = app.activeProduct
        rootComp = design.rootComponent
        sketches = rootComp.sketches
        sketch = sketches.add(rootComp.xZConstructionPlane)
        sketchCircles = sketch.sketchCurves.sketchCircles
        centerPt = adsk.core.Point3D.create(0, 0, 0)
        for i in range(50):
            # If progress dialog is cancelled, stop drawing.
            if progressDialog.wasCancelled:
                break
            sketchCircles.addByCenterRadius(centerPt, i+1)
            # Update progress value of progress dialog
            progressDialog.progressValue = i+1
        
        # Hide the progress dialog at the end.
        progressDialog.hide()
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Selection Events API Sample
Description
The sample demos how to use selection events of a command.
Code Samples
C++
Python
Copy Code

--
#Author-Autodesk
#Description-Demo how to use selection events of a command.
import adsk.core, adsk.fusion, adsk.cam, traceback
ui = adsk.core.UserInterface.cast(None)
handlers = []
selectedEdges = []
class MyCommandCreatedHandler(adsk.core.CommandCreatedEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            cmd = args.command
            cmd.isExecutedWhenPreEmpted = False
            inputs = cmd.commandInputs
            
            selectInput = inputs.addSelectionInput('SelectionEventsSample', 'Edges', 'Please select edges')
            selectInput.addSelectionFilter(adsk.core.SelectionCommandInput.Edges)
            selectInput.setSelectionLimits(1)
            
            # Connect to the command related events.
            onExecutePreview = MyCommandExecutePreviewHandler()
            cmd.executePreview.add(onExecutePreview)
            handlers.append(onExecutePreview)        
            onDestroy = MyCommandDestroyHandler()
            cmd.destroy.add(onDestroy)
            handlers.append(onDestroy)  
            
            onPreSelect = MyPreSelectHandler()
            cmd.preSelect.add(onPreSelect)
            handlers.append(onPreSelect)
            
            onPreSelectMouseMove = MyPreSelectMouseMoveHandler()
            cmd.preSelectMouseMove.add(onPreSelectMouseMove)
            handlers.append(onPreSelectMouseMove)
            onPreSelectEnd = MyPreSelectEndHandler()
            cmd.preSelectEnd.add(onPreSelectEnd)
            handlers.append(onPreSelectEnd)
            onSelect = MySelectHandler()
            cmd.select.add(onSelect)
            handlers.append(onSelect) 
            
            onUnSelect = MyUnSelectHandler()
            cmd.unselect.add(onUnSelect)            
            handlers.append(onUnSelect) 
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
                
class MyCommandExecutePreviewHandler(adsk.core.CommandEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            app = adsk.core.Application.get()            design = adsk.fusion.Design.cast(app.activeProduct)
            if design:
                cggroup = design.rootComponent.customGraphicsGroups.add()
                for i in range(0, len(selectedEdges)):
                    edge = adsk.fusion.BRepEdge.cast(selectedEdges[i])
                    transform = adsk.core.Matrix3D.create()
                    transform.translation = edge.pointOnEdge.asVector()
                    cgtext = cggroup.addText(str(i+1), 'Arial Black', 1, transform)
                    cgtext.color = adsk.fusion.CustomGraphicsSolidColorEffect.create(adsk.core.Color.create(0,255,0,255))
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))                
class MyCommandDestroyHandler(adsk.core.CommandEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            # when the command is done, terminate the script
            # this will release all globals which will remove all event handlers
            adsk.terminate()
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
                
class MyPreSelectHandler(adsk.core.SelectionEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            selectedEdge = adsk.fusion.BRepEdge.cast(args.selection.entity)
            if selectedEdge:
                args.additionalEntities = selectedEdge.tangentiallyConnectedEdges        
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc())) 
                
class MyPreSelectMouseMoveHandler(adsk.core.SelectionEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            app = adsk.core.Application.get()
            design = adsk.fusion.Design.cast(app.activeProduct)
            selectedEdge = adsk.fusion.BRepEdge.cast(args.selection.entity) 
            if design and selectedEdge:
                group = design.rootComponent.customGraphicsGroups.add()
                group.id = str(selectedEdge.tempId)
                cgcurve = group.addCurve(selectedEdge.geometry)
                cgcurve.color = adsk.fusion.CustomGraphicsSolidColorEffect.create(adsk.core.Color.create(255,0,0,255))
                cgcurve.weight = 10      
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
                
class MyPreSelectEndHandler(adsk.core.SelectionEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            app = adsk.core.Application.get()
            design = adsk.fusion.Design.cast(app.activeProduct)
            selectedEdge = adsk.fusion.BRepEdge.cast(args.selection.entity) 
            if design and selectedEdge:
                for group in design.rootComponent.customGraphicsGroups:
                    if group.id == str(selectedEdge.tempId):
                        group.deleteMe()
                        break       
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
                
class MySelectHandler(adsk.core.SelectionEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            selectedEdge = adsk.fusion.BRepEdge.cast(args.selection.entity) 
            if selectedEdge:
                selectedEdges.append(selectedEdge)
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
                
class MyUnSelectHandler(adsk.core.SelectionEventHandler):
    def __init__(self):
        super().__init__()
    def notify(self, args):
        try:
            selectedEdge = adsk.fusion.BRepEdge.cast(args.selection.entity) 
            if selectedEdge:
                selectedEdges.remove(selectedEdge)
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
def run(context):
    global ui
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        myCmdDef = ui.commandDefinitions.itemById('SelectionEventsSample_Python')
        if myCmdDef is None:            myCmdDef = ui.commandDefinitions.addButtonDefinition('SelectionEventsSample_Python', 'Selection Events Sample', '', '')
        
        # Connect to the command created event.
        onCommandCreated = MyCommandCreatedHandler()
        myCmdDef.commandCreated.add(onCommandCreated)
        handlers.append(onCommandCreated)
        
        # Execute the command.
        myCmdDef.execute()
        # prevent this module from being terminate when the script returns, because we are waiting for event handlers to fire
        adsk.autoTerminate(False)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Tabbed Toolbar  API Sample
Description
Demonstrates how to work with the tabbed toolbar API.
Code Samples
C++
Python
Copy Code

--
import adsk.core, adsk.fusion, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        # For this example, we are adding the already exisiting 'Extrude' command into a new panel:
        cmdDefinitions = ui.commandDefinitions
        anotherExtrudeCmd = cmdDefinitions.itemById('Extrude')
                
        # For a few months, the customer might run either classic UI or tabbed toolbar UI.
        # Find out what is being used:
        runningTabbedToolbar = ui.isTabbedToolbarUI
        if runningTabbedToolbar:
            # Get all workspaces:
            allWorkspaces = ui.workspaces
            # Get the Render workspace:
            renderWorkspace = allWorkspaces.itemById('FusionRenderEnvironment')
            # Get the Design workspace:
            designWorkspace = allWorkspaces.itemById('FusionSolidEnvironment')
            if (renderWorkspace and designWorkspace):
                # Get all the tabs for the Render and Design workspaces:
                allRenderTabs = renderWorkspace.toolbarTabs
                allDesignTabs = designWorkspace.toolbarTabs
                if ((allRenderTabs.count > 0) and (allDesignTabs.count > 0)):
                    # Add a new tab to the Render and Design workspaces:
                    newRenderTab = allRenderTabs.add('NewRenderTabHere', 'New Render Tab')
                    newDesignTab = allDesignTabs.add('NewDesignTabHere', 'New Design Tab')
                    if (newRenderTab and newDesignTab):
                        # Get all of the toolbar panels for the NewRender and NewDesign tab:
                        allNewRenderTabPanels = newRenderTab.toolbarPanels
                        allNewDesignTabPanels = newDesignTab.toolbarPanels
                        # Has the panel been added already?
                        # You'll get an error if you try to add this more than once to the tab.
                        #Activate the Render Workspace before activating the newly added Tab
                        renderWorkspace.activate()
                            
                        brandNewRenderPanel = None
                        brandNewRenderPanel = allNewRenderTabPanels.itemById('bestRenderPanelEverId')
                        if brandNewRenderPanel is None:
                            # We have not added the panel already.  Go ahead and add it.
                            brandNewRenderPanel = allNewRenderTabPanels.add('bestRenderPanelEverId', 'Best Render Panel')
                        if brandNewRenderPanel:
                            # Access the controls that belong to the panel:
                            newPanelControls = brandNewRenderPanel.controls
                            # Do we already have this command in the controls?  
                            # You'll get an error if you try to add it more than once to the panel:
                            extrudeCmdControl =  None
                            extrudeCmdControl = newPanelControls.itemById('Extrude')
                            if extrudeCmdControl is None:                        
                                # Activate the newly added Tab in Render Workspace before adding command to the Panel
                                if renderWorkspace.isActive: 
                                    renderTab = allRenderTabs.itemById('NewRenderTabHere')
                                    if not renderTab.isActive :
                                        activationState = renderTab.activate()
                                        if activationState:
                                            if anotherExtrudeCmd:
                                                # Go ahead and add the command to the panel:
                                                extrudeCmdControl = newPanelControls.addCommand(anotherExtrudeCmd)
                                                if extrudeCmdControl:
                                                    extrudeCmdControl.isVisible = True
                                                    extrudeCmdControl.isPromoted = True
                                                    extrudeCmdControl.isPromotedByDefault = True
                                                    ui.messageBox('Do you see Best Render Panel now?')
                                            
                            else:
                                # If the command is already added to the Panel check if it is visible and display a message
                                if renderWorkspace.isActive: 
                                    renderTab = allRenderTabs.itemById('NewRenderTabHere')
                                    if not renderTab.isActive :
                                        activationState = renderTab.activate()
                                        if activationState :
                                            if brandNewRenderPanel.isVisible:
                                                ui.messageBox('Do you see Best Render Panel now?')     
                                            else:
                                                totalControlsInPanel = newPanelControls.count
                                                if (totalControlsInPanel == 1):
                                                    if extrudeCmdControl.isVisible:
                                                        ui.messageBox('Not visible control')
                        #Activate the Design workspace before activating the newly added Tab
                        designWorkspace.activate()
                                
                        brandNewDesignPanel = None
                        brandNewDesignPanel = allNewDesignTabPanels.itemById('bestDesignPanelEverId')
                        if brandNewDesignPanel is None:
                            # We have not added the panel already.  Go ahead and add it.
                            brandNewDesignPanel = allNewDesignTabPanels.add('bestDesignPanelEverId', 'Best Design Panel')
                        if brandNewDesignPanel:                            # Access the controls that belong to the panel:
                            newPanelControls = brandNewDesignPanel.controls
                            # Do we already have this command in the controls?  
                            # You'll get an error if you try to add it more than once to the panel:
                            extrudeCmdControl =  None
                            extrudeCmdControl = newPanelControls.itemById('Extrude')
                            if extrudeCmdControl is None:
                            
                            # Activate the newly added Tab in Design workspace before adding Command to the Panel
                                 if designWorkspace.isActive: 
                                    designTab = allDesignTabs.itemById('NewDesignTabHere')
                                    if not designTab.isActive :
                                        activationState = designTab.activate()
                                        if activationState :
                                            if anotherExtrudeCmd:
                                                # Go ahead and add the command to the panel:
                                                extrudeCmdControl = newPanelControls.addCommand(anotherExtrudeCmd)
                                                if extrudeCmdControl:
                                                    extrudeCmdControl.isVisible = True
                                                    extrudeCmdControl.isPromoted = True
                                                    extrudeCmdControl.isPromotedByDefault = True
                                                    ui.messageBox('Do you see Best Design Panel now?')
                                            
                            else:
                                # If the command is already added to the Panel check if it is visible and display a message
                                if designWorkspace.isActive:
                                    designTab = allDesignTabs.itemById('NewDesignTabHere')
                                    if not designTab.isActive :
                                        activationState = designTab.activate()
                                        if activationState :
                                            if brandNewDesignPanel.isVisible:
                                                ui.messageBox('Do you see Best Design Panel now?')     
                                            else:
                                                totalControlsInPanel = newPanelControls.count
                                                if (totalControlsInPanel == 1):
                                                    if extrudeCmdControl.isVisible:
                                                        ui.messageBox('Not visible control')
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
# When the addin stops we need to clean up the ui
def stop(context):
    app = adsk.core.Application.get()
    ui = app.userInterface
    try:
        # Get all the toolbar panels
        allToolbarPanels = ui.allToolbarPanels
        # See if our design panel still exists
        brandNewDesignPanel = allToolbarPanels.itemById('bestDesignPanelEverId')
        if brandNewDesignPanel:
            # Remove the controls we added to our panel
            for control in brandNewDesignPanel.controls:
                if control.isValid:
                    control.deleteMe()
            # Remove our panel
            brandNewDesignPanel.deleteMe()
        # See if our render panel still exists
        brandNewRenderPanel = allToolbarPanels.itemById('bestRenderPanelEverId')
        if brandNewRenderPanel:
            # Remove the controls we added to our panel
            for control in brandNewRenderPanel.controls:
                if control.isValid:
                    control.deleteMe()
            # Remove our panel
            brandNewRenderPanel.deleteMe()
        # Get all of the toolbar tabs
        allToolbarTabs = ui.allToolbarTabs
        # See if our render tab still exists
        newRenderTab = allToolbarTabs.itemById('NewRenderTabHere')
        if brandNewDesignPanel:
            if newRenderTab.isValid:
                newRenderTab.deleteMe()
        # See if our design tab still exists
        newDesignTab = allToolbarTabs.itemById('NewDesignTabHere')
        if brandNewDesignPanel:
            if newDesignTab.isValid:
                newDesignTab.deleteMe()
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Write user  interface to a file API Sample
Description
Writes out the full structure of the Fusion user interface. This information is useful when editing the user -interface, as discussed in the usre manual topic User-Interface Customization with
Fusion 360's APICode Samples
Python
Copy Code
import adsk.core, traceback
import codecs
def run(context):
    ui = None
    try:
        app: adsk.core.Application = adsk.core.Application.get()
        ui  = app.userInterface
        fileDialog = ui.createFileDialog()
        fileDialog.isMultiSelectEnabled = False
        fileDialog.title = "Specify result filename"
        fileDialog.filter = 'XML files (*.xml)'
        fileDialog.filterIndex = 0
        dialogResult = fileDialog.showSave()
        if dialogResult == adsk.core.DialogResults.DialogOK:
            filename = fileDialog.filename
        else:
            return
        result = '<UserInterface>\n'
        result += f'{TabSpace(1)}<Workspaces count="{ui.workspaces.count}">\n'
        for wsIndex in range(ui.workspaces.count):
            try:
                ws: adsk.core.Workspace = ui.workspaces.item(wsIndex)
            except:
                ws = None
            if ws:
                result += f'{TabSpace(2)}<Workspace name="{ws.name}" id="{ws.id}">\n'
                try:
                    tabs = ws.toolbarTabs
                except:
                    tabs = None
                if tabs:
                    result += f'{TabSpace(3)}<ToolbarTabs count="{tabs.count}">\n'
                    for tab in tabs:
                        result += f'{TabSpace(4)}<ToolbarTab name="{tab.name}" id="{tab.id}">\n'
                        result += GetPanelsXML(tab.toolbarPanels, 5)
                        result += f'{TabSpace(4)}</ToolbarTab>\n'
                    result += f'{TabSpace(3)}</ToolbarTabs>\n'
                else:
                    result += f'{TabSpace(3)}<ToolbarTabs error="Failed to get toolbar tabs.">\n'
                    result += f'{TabSpace(3)}</ToolbarTabs>\n'
                result += f'{TabSpace(2)}</Workspace>\n'
        result += f'{TabSpace(1)}</Workspaces>\n'
        result += f'{TabSpace(1)}<Toolbars count="{ui.toolbars.count}">\n'
        toolbar: adsk.core.Toolbar
        for toolbar in ui.toolbars:
            result += f'{TabSpace(2)}<Toolbar id="{toolbar.id}">\n'
            result += f'{TabSpace(3)}<ToolbarControls count="{toolbar.controls.count}">\n'
            result += GetControls(toolbar.controls, 1, False)
            result += f'{TabSpace(3)}</ToolbarControls>\n'
            result += f'{TabSpace(2)}</Toolbar>\n'
        result += f'{TabSpace(1)}</Toolbars>\n'
        result += '</UserInterface>'
        f = open(filename, 'w', -1, 'utf-8-sig')
        f.write(result)
        f.close()
        ui.messageBox(f'Finished writing to:\n{filename}')
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
# Builds XML data for all of the panel information from the ToolbarPanels collection passed in.
def GetPanelsXML(panels: adsk.core.ToolbarPanels, tabs: int) -> str:
    result = f'{TabSpace(tabs)}<ToolbarPanels count="{panels.count}">\n'
    for panelIndex in range(panels.count):
        try:
            panel: adsk.core.ToolbarPanel = panels.item(panelIndex)
        except:
            panel = None
        if panel:
            result += f'{TabSpace(tabs + 1)}<ToolbarPanel name="{panel.name}" id="{panel.id}">\n'
            result += f'{TabSpace(tabs + 2)}<ToolbarControls count="{panel.controls.count}">\n'
            result += GetControls(panel.controls, tabs, True)
            result += f'{TabSpace(tabs + 2)}</ToolbarControls>\n'
            result += f'{TabSpace(tabs + 1)}</ToolbarPanel>\n'
    result += f'{TabSpace(tabs + 1)}</ToolbarPanels>\n'
    return result
# Builds XML data for all of the controls in the ToolbarControls collection passed in.
def GetControls(controls: adsk.core.ToolbarControls, tabs: int, isPanel: bool) -> str:
    result = ''
    for control in controls:        if control.objectType == adsk.core.DropDownControl.classType():
            dropControl: adsk.core.DropDownControl = control
            if isPanel:
                try:
                    dropName = dropControl.name
                except:
                    dropName = "**** Error getting name."
                result += f'{TabSpace(tabs + 3)}<DropDownControl name="{dropName}" id="{dropControl.id}" count="{dropControl.controls.count}">\n'
            else:
                result += f'{TabSpace(tabs + 3)}<DropDownControl id="{dropControl.id}" count="{dropControl.controls.count}">\n'
            result += GetControls(dropControl.controls, tabs + 1, isPanel)
            result += f'{TabSpace(tabs + 3)}</DropDownControl>\n'
        elif control.objectType == adsk.core.SplitButtonControl.classType():
            splitControl: adsk.core.SplitButtonControl = control
            result += f'{TabSpace(tabs + 3)}<SplitButtonControl>\n'
            try:
                defaultCmdDef = splitControl.defaultCommandDefinition
            except:
                defaultCmdDef = None
            
            if defaultCmdDef:
                result += f'{TabSpace(tabs + 4)}<defaultCommandDefinition name="{defaultCmdDef.name}" id="{defaultCmdDef.id}"/>\n'
                additionalDefs = splitControl.additionalDefinitions
                result += f'{TabSpace(tabs + 4)}<additionalDefinitions count="{len(additionalDefs)}">\n'
                for additionalDef in additionalDefs:
                    result += f'{TabSpace(tabs + 5)}<{ObjectName(additionalDef)} name="{additionalDef.name}" id="{additionalDef.id}"/>\n'
                result += f'{TabSpace(tabs + 4)}</additionalDefinitions>\n'
            else:
                result += f'{TabSpace(tabs + 4)}<defaultCommandDefinition error="**** Failed to get CommandDefinition"/>\n'
            result += f'{TabSpace(tabs + 3)}</SplitButtonControl>\n'
        else:
            if control.objectType == adsk.core.SeparatorControl.classType():
                result += f'{TabSpace(tabs + 3)}<SeparatorControl id="{control.id}" />\n'
            else:
                cmdDef: adsk.core.CommandDefinition = None
                try:                 
                    cmdDef = control.commandDefinition
                except:
                    cmdDef = None
                if cmdDef:
                    try:
                        commandType = ObjectName(cmdDef.controlDefinition)
                    except:
                        commandType = '**** Failed to get associated control.'
                    isPromotedOK = True
                    try:
                        isPromoted = control.isPromoted
                    except:
                        isPromotedOK = False
                    if isPanel and isPromotedOK:
                        result += f'{TabSpace(tabs + 3)}<{ObjectName(control)} name="{cmdDef.name}" id="{cmdDef.id}" commandType="{commandType}" isPromoted="{isPromoted}" 
                    else:
                        result += f'{TabSpace(tabs + 3)}<{ObjectName(control)} name="{cmdDef.name}" id="{cmdDef.id}" commandType="{commandType}" />\n'
                else:
                    result += f'{TabSpace(tabs + 3)}<{ObjectName(control)} error="**** Failed to get CommandDefinition for {control.id}" />\n'
    return result
# Return a string of spaces that can be used to prepend to a string to
# represent the specified number of tabs. 
def TabSpace(tabs: int) -> str:
    spacesPerTab = 4
    return ' ' * (spacesPerTab * tabs)
# Splits out the object name from the full object name passed in.
def ObjectName(object: adsk.core.Base) -> str:
    parts = object.objectType.split('::')
    return parts[len(parts)-1]
Basic Milling Workflow Sample
Description
Demonstrates the creation of a basic milling workflow from script
Demonstrates creating a setup, searching tool library to retrieve a tool, create a couple of machining operations and a NC program, ready for post processing.
Use the 2D Strategies model from the Fusion CAM Samples folder as your CAD model.
Code Samples
Python--
import adsk.core, adsk.fusion, adsk.cam, traceback
import os
def run(context):
    ui = None
    try:
        #################### initialisation #####################
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # use existing document, load 2D Strategies model from the Fusion CAM Samples folder
        doc = app.activeDocument
        # switch to manufacturing space
        camWS = ui.workspaces.itemById('CAMEnvironment') 
        camWS.activate()
        # get the CAM product
        products = doc.products
        #################### Find tools in sample tool library ####################
        # get the tool libraries from the library manager
        camManager = adsk.cam.CAMManager.get()
        libraryManager = camManager.libraryManager
        toolLibraries = libraryManager.toolLibraries
        # we can use a library URl directly if we know its address (here we use Fusion's Metric sample library)
        url = adsk.core.URL.create('systemlibraryroot://Samples/Milling Tools (Metric).json')
        
        # load tool library
        toolLibrary = toolLibraries.toolLibraryAtURL(url)
        # create some variables for the milling tools which will be used in the operations
        faceTool = None
        adaptiveTool = None
       
        # searching the face mill and the bull nose using a loop for the roughing operations
        for tool in toolLibrary:
            # read the tool type
            toolType = tool.parameters.itemByName('tool_type').value.value 
            
            # select the first face tool found
            if toolType == 'face mill' and not faceTool:
                faceTool = tool  
            
            # search the roughing tool
            elif toolType == 'bull nose end mill' and not adaptiveTool:
                # we look for a bull nose end mill tool larger or equal to 10mm but less than 14mm
                diameter = tool.parameters.itemByName('tool_diameter').value.value
                if diameter >= 1.0 and diameter < 1.4: 
                    adaptiveTool = tool
            # exit when the 2 tools are found
            if faceTool and adaptiveTool:
                break
      
        #################### create setup ####################
        cam = adsk.cam.CAM.cast(products.itemByProductType("CAMProductType"))
        setups = cam.setups
        setupInput = setups.createInput(adsk.cam.OperationTypes.MillingOperation)
        # create a list for the models to add to the setup Input
        models = [] 
        part = cam.designRootOccurrence.bRepBodies.item(0)
        # add the part to the model list
        models.append(part) 
        # pass the model list to the setup input
        setupInput.models = models 
        # create the setup
        setup = setups.add(setupInput) 
        # change some properties of the setup
        setup.name = 'CAM Basic Script Sample'  
        setup.stockMode = adsk.cam.SetupStockModes.RelativeBoxStock
        # set offset mode
        setup.parameters.itemByName('job_stockOffsetMode').expression = "'simple'"
        # set offset stock side
        setup.parameters.itemByName('job_stockOffsetSides').expression = '0 mm'
        # set offset stock top
        setup.parameters.itemByName('job_stockOffsetTop').expression = '2 mm'
        # set setup origin
        setup.parameters.itemByName('wcs_origin_boxPoint').value.value = 'top 1'
        
        #################### face operation ####################
        # create a face operation input
        input = setup.operations.createInput('face')
        input.tool = faceTool
        input.displayName = 'Face Operation'       
        input.parameters.itemByName('tolerance').expression = '0.01 mm'
        input.parameters.itemByName('stepover').expression = '0.75 * tool_diameter'
        input.parameters.itemByName('direction').expression = "'climb'"
        # add the operation to the setup
        faceOp = setup.operations.add(input)
        #################### adaptive operation ####################
        input = setup.operations.createInput('adaptive')
        input.tool = adaptiveTool
        input.displayName = 'Adaptive Roughing'        input.parameters.itemByName('tolerance').expression = '0.1 mm' 
        input.parameters.itemByName('maximumStepdown').expression = '5 mm' 
        input.parameters.itemByName('fineStepdown').expression = '0.25 * maximumStepdown'
        input.parameters.itemByName('flatAreaMachining').expression = 'false'
        # add the operation to the setup
        adaptiveOp = setup.operations.add(input)
        ##################### generate operations ####################
        cam.generateToolpath(faceOp)
        cam.generateToolpath(adaptiveOp)
            
        #################### ncProgram and post-processing ####################
        # get the post library from library manager
        postLibrary = libraryManager.postLibrary
        # query post library to get postprocessor list
        postQuery = postLibrary.createQuery(adsk.cam.LibraryLocations.Fusion360LibraryLocation)
        postQuery.vendor = "Autodesk"
        postQuery.capability = adsk.cam.PostCapabilities.Milling
        postConfigs = postQuery.execute()
        # find the "XYZ" post in the post library and import it to local library
        for config in postConfigs:
            if config.description == 'XYZ':
                url = adsk.core.URL.create("user://")
                importedURL = postLibrary.importPostConfiguration(config, url, "NCProgramSamplePost.cps")
        # get the imported local post config
        postConfig = postLibrary.postConfigurationAtURL(importedURL)
       
        # create NCProgramInput object
        ncInput = cam.ncPrograms.createInput()
        ncInput.displayName = 'NC Program Sample'
        # change some nc program parameters...
        ncParameters = ncInput.parameters
        ncParameters.itemByName('nc_program_filename').value.value = 'NCProgramSample'
        ncParameters.itemByName('nc_program_openInEditor').value.value = True
        # set user desktop as output directory (Windows and Mac)
        # make the path valid for Fusion360 by replacing \\ to / in the path
        desktopDirectory = os.path.expanduser("~/Desktop").replace('\\', '/') 
        ncParameters.itemByName('nc_program_output_folder').value.value = desktopDirectory
        
        # select the operations to generate (we skip steep_and_shallow here)
        ncInput.operations = [faceOp, adaptiveOp]
        # add a new ncprogram from the ncprogram input
        newProgram = cam.ncPrograms.add(ncInput)
        # set post processor
        newProgram.postConfiguration = postConfig
        # change some post parameter
        postParameters = newProgram.postParameters
        postParameters.itemByName('builtin_tolerance').value.value = 0.01  # NcProgram parameters is pass as it is to the postprocessor (it has no units)
        postParameters.itemByName('builtin_minimumChordLength').value.value = 0.33  # NcProgram parameters is pass as it is to the postprocessor (it has no units)
        # update/apply post parameters
        newProgram.updatePostParameters(postParameters)
        # post-process
        # uncomment next lines to automatically postprocess operations (requires them to be calculated!)
        # 
        # set post options, by default post process only valid operations containing toolpath data
        # postOptions = adsk.cam.NCProgramPostProcessOptions.create()
        # newProgram.postProcess(postOptions)
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
CAM Parameter  Modification API Sample
Description
Demonstrates changing parameters of existing toolpaths.
Code Samples
Python
C++
Copy Code
import adsk.core, adsk.cam, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        doc = app.activeDocument
        products = doc.products        
        # Get the CAM product
        cam = adsk.cam.CAM.cast(products.itemByProductType("CAMProductType"))
        # List of all setups
        setups = cam.setups
        
        for setup in setups:
            # Change the program name of each setup to 1234
            programNameParam = setup.parameters.itemByName('job_programName')
            programNameParam.expression = "1234"
            
            for operation in setup.operations:
                # Change tolerance in all operations
                toleranceParam = operation.parameters.itemByName('tolerance')
                toleranceParam.expression = "0.1mm"
        
        # Generate all toolpaths, skipping any that are already valid
        cam.generateAllToolpaths(True)
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
--

Copy Code
# For this sample script to run, the active Fusion document must contain at least one CAM operation.
import adsk.core, adsk.fusion, adsk.cam, traceback, os
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        doc = app.activeDocument
        products = doc.products
        product = products.itemByProductType('CAMProductType')
        # check if the document has a CAMProductType.  It will not if there are no CAM operations in it.
        if not product:
            ui.messageBox('There are no CAM operations in the active document.  This script requires the active document to contain at least one CAM operation.',
                            'No CAM Operations Exist',
                            adsk.core.MessageBoxButtonTypes.OKButtonType,
                            adsk.core.MessageBoxIconTypes.CriticalIconType)
            return
        cam = adsk.cam.CAM.cast(product)
        # specify the output folder and format for the setup sheets
        outputFolder = cam.temporaryFolder
        sheetFormat = adsk.cam.SetupSheetFormats.HTMLFormat
        #sheetFormat = adsk.cam.SetupSheetFormats.ExcelFormat (not currently supported on Mac)
        # prompt the user with an option to view the resulting setup sheets.
        viewResults = ui.messageBox('View setup sheets when done?', 'Generate Setup Sheets',
                                    adsk.core.MessageBoxButtonTypes.YesNoButtonType,
                                    adsk.core.MessageBoxIconTypes.QuestionIconType)
        if viewResults == adsk.core.DialogResults.DialogNo:
            viewResult = False
        else:
            viewResult = True
        # set the value of scenario to 1, 2 or 3 to generate setup sheets for all, for the first setup, or for the first operation of the first setup.
        scenario = 1
        if scenario == 1:
            ui.messageBox('Setup sheets for all operations will be generated.')
            cam.generateAllSetupSheets(sheetFormat, outputFolder, viewResult)
        elif scenario == 2:
            ui.messageBox('Setup sheets for operations in the first setup will be generated.')
            setup = cam.setups.item(0)
            cam.generateSetupSheet(setup, sheetFormat, outputFolder, viewResult)
        elif scenario == 3:
            ui.messageBox('A setup sheet for the first operation in the first setup will be generated.')
            setup = cam.setups.item(0)
            operations = setup.allOperations
            operation = operations.item(0)
            if operation.hasToolpath:
                cam.generateSetupSheet(operation, sheetFormat, outputFolder, viewResult)
            else:
                ui.messageBox('This operation has no toolpath.  A valid toolpath must exist in order for a setup sheet to be generated.')
                return
        ui.messageBox('Setup Sheets have been generated in:\n' + outputFolder)
        # open the output folder in Finder on Mac or in Explorer on Windows
        if (os.name == 'posix'):
            os.system('open "%s"' % outputFolder)
        elif (os.name == 'nt'):
            os.startfile(outputFolder)
        # Prompt user with an option to switch to the CAM workspace if it's not already active
        if ui.activeWorkspace.name != 'CAM':
            activateCAMWorkspace = ui.messageBox('Activate the CAM Workspace?','CAM Workspace Activate',
                                                 adsk.core.MessageBoxButtonTypes.YesNoButtonType,
                                                 adsk.core.MessageBoxIconTypes.QuestionIconType)
            if activateCAMWorkspace == adsk.core.DialogResults.DialogYes:
                workspaces = ui.workspaces
                camWorkspace = workspaces.itemById("CAMEnvironment")
                camWorkspace.activate()
    except:        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Generate Toolpaths API Sample
Description
Demonstrates generating the toolpaths in the active document.
Code Samples
C++
Python
--

Copy Code
import adsk.core, adsk.fusion, traceback, time
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        
        # Get the CAM product.
        doc = app.activeDocument        products = doc.products
        product = products.itemByProductType('CAMProductType')
        cam = adsk.cam.CAM.cast(product)
        if not cam:
            ui.messageBox('No CAM data exists in the active document.')
            return
            
        # Verify that there are any setups.
        if cam.allOperations.count == 0:
            ui.messageBox('No CAM operations exist in the active document.')
            return
            
        #set the value of scenario to 1, 2 or 3 to generate all, the first setup, or the first operation of the first setup.
        scenario = 1
        if scenario == 1:
            future = cam.generateAllToolpaths(False)
            message = 'The toolpaths for all operations in the document have been generated.'
        elif scenario == 2:
            setup = cam.setups.item(0)
            future = cam.generateToolpath(setup)
            message = 'The toolpaths for the operations of the first setup in the document have been generated.'
        elif scenario == 3:
            setup = cam.setups.item(0)
            operations = setup.operations
            operation = operations.item(0)
            future = cam.generateToolpath(operation)
            message = 'The toolpath for the first operation of the first setup in the document have been generated.'
        numOps = future.numberOfOperations
        #  create and show the progress dialog while the toolpaths are being generated.
        progress = ui.createProgressDialog()
        progress.isCancelButtonShown = False
        progress.show('Toolpath Generation Progress', 'Generating Toolpaths', 0, 10)
        # Enter a loop to wait while the toolpaths are being generated and update
        # the progress dialog.
        while not future.isGenerationCompleted:
            # since toolpaths are calculated in parallel, loop the progress bar while the toolpaths 
            # are being generated but none are yet complete.
            n = 0
            start = time.time()
            while future.numberOfCompleted == 0:
                if time.time() - start > .125: # increment the progess value every .125 seconds.
                    start = time.time()
                    n +=1
                    progress.progressValue = n
                    adsk.doEvents()
                if n > 10:
                    n = 0
            # The first toolpath has finished computing so now display better
            # information in the progress dialog.
            # set the progress bar value to the number of completed toolpaths
            progress.progressValue = future.numberOfCompleted
            # set the progress bar max to the number of operations to be completed.
            progress.maximumValue = numOps
            # set the message for the progress dialog to track the progress value and the total number of operations to be completed.
            progress.message = 'Generating %v of %m' + ' Toolpaths'
            adsk.doEvents()
        progress.hide()
        ui.messageBox(message)
        # Prompt user with an option to switch to the CAM workspace if it's not already active
        if ui.activeWorkspace.id != 'CAMEnvironment':
            dialogResult = ui.messageBox('Activate the CAM Workspace?','CAM Workspace Activate',
                                                 adsk.core.MessageBoxButtonTypes.YesNoButtonType,
                                                 adsk.core.MessageBoxIconTypes.QuestionIconType)
            if dialogResult == adsk.core.DialogResults.DialogYes:
                ws = ui.workspaces.itemById('CAMEnvironment')
                ws.activate()
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Hole and Pocket Recognition API Sample
Description
This sample script demonstrates three dif ferent methods for feature recognition: one for holes and two for pockets.
The script starts by creating a simple component which is then used to demonstrate the three methods. After the features are recognised they are coloured and milling and drilling operations
are created for each feature.
RecognizedHoleGroup returns a list of BRepFaces that can be used as selections for the drilling operation. RecognizedPocket and PocketRecognitionSelection do not return BRepFaces,
and their output needs additional processing before the output can be used for creating machining operations.
The sample script demonstrates a couple of dif ferent methods, including finding the pocket BRepFaces and creating sketches from the recognized pockets.
Code SamplesPython
--
import adsk.core, adsk.fusion, adsk.cam, traceback
import math
from enum import Enum
#################### Some constants and enumerators used in the script ####################
# Milling & drilling tool libraries to get tools from
MILLING_TOOL_LIBRARY_URL  = adsk.core.URL.create('systemlibraryroot://Samples/Milling Tools (Metric).json')
DRILLING_TOOL_LIBRARY_URL = adsk.core.URL.create('systemlibraryroot://Samples/Hole Making Tools (Metric).json')
# Colors
POCKET_WALL_FACES_COLOR   = adsk.core.Color.create(0, 255, 255, 255)
POCKET_BOTTOM_FACES_COLOR = adsk.core.Color.create(0, 145, 230, 255)
HOLE_SIMPLE_COLOR         = adsk.core.Color.create(130, 225, 10, 255)
HOLE_COUNTERBORE_COLOR    = adsk.core.Color.create(180, 120, 255, 255)
# BRep Search
PROXIMITY_TOLERANCE = -1 # define BRep Search proximity tolerance
# Some tool types used in this script (enumerator)
class ToolType(Enum):
    BULL_NOSE_END_MILL = 'bull nose end mill'
    DRILL              = 'drill'
    FLAT_END_MILL      = 'flat end mill'
    SPOT_DRILL         = 'spot drill'
# Some variables
_app = adsk.core.Application.get()
_ui  = _app.userInterface
#################### ENTRY POINT #####################
def run(context):
    try:       
        # create a new empty document
        doc = _app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        # switch to manufacturing space
        camWS = _ui.workspaces.itemById('CAMEnvironment') 
        camWS.activate()
        # get the CAM product
        products = doc.products
        cam: adsk.cam.CAM = products.itemByProductType("CAMProductType")
        # get the CAD product
        design: adsk.fusion.Design = products.itemByProductType('DesignProductType')
        # Get the root component of the active design as we will need to create sketches later on...
        rootComponent = design.rootComponent
        sketches = rootComponent.sketches
        #################### CREATE SAMPLE PART ####################
        body = createSampleBody(rootComponent)
        #################### TOOL LIBRARIES ####################
        # get the tool libraries from the library manager
        camManager = adsk.cam.CAMManager.get()
        libraryManager = camManager.libraryManager
        toolLibraries = libraryManager.toolLibraries
        
        # load tool libraries
        millingToolLibrary = toolLibraries.toolLibraryAtURL(MILLING_TOOL_LIBRARY_URL)
        drillingToolLibrary = toolLibraries.toolLibraryAtURL(DRILLING_TOOL_LIBRARY_URL)
        ####################### HOLE & POCKETS RECOGNITION - SAMPLE SCRIPT MAIN LOGIC STARTS #######################
        # create setups
        holeRecognitionSetup = createSetup('Holes (using "RecognizedHoleGroup")', body) 
        pocketRecognitionSetup = createSetup('Pockets (using "RecognizedPocket")', body)
        pocketSelectionSetup = createSetup('Pockets (using "PocketRecognitionSelection")', body)
        # get body parent component
        pocketComponent = body.parentComponent
        # get a tool to machine the pockets
        tools = getToolsFromLibraryByTypeDiameterRangeAndMinFluteLength(millingToolLibrary, ToolType.FLAT_END_MILL.value, 1, 1, 2)
        roughingTool = tools[0] # use the first tool found
        ########## MAKE POCKETS USING POCKET RECOGNITION API ##########
        # pocket search vector: only look for pockets from top view: visible and machinable from Z+
        pocketSearchVector = adsk.core.Vector3D.create(0, 0, -1)
        # recognize pockets
        pockets = adsk.cam.RecognizedPocket.recognizePockets(body, pocketSearchVector)
        # get boundary key points to find bottom faces (if any) and create roughing operation
        for pocket in pockets:
            # check if the pocket is circular (if it's basically a simple hole) since we will deal with those using drilling
            if isCircularPocket(pocket):
                continue
            # pocket boundaries
            boundaries = pocket.boundaries
            # get pocket boundary key points (used later on to find and color faces)
            points: list[adsk.core.Point3D] = []            for boundary in boundaries:
                boundaryPoints = getBoundaryKeyPoints(boundary)
                points.extend(boundaryPoints)
            # create pocket operations
            if pocket.isThrough:
                # THROUGH POCKETS: searching side faces for coloring. Bottom faces are missing so we will draw sketch to define pocket bottom boundary.
                
                # search the walls face breps using the points of the boundary
                pocketWallFaces = getPocketWallFaces(pocketComponent, points)
                
                # color pocket walls
                colorFaces(design, pocketWallFaces, 'pocketWallFacesColor', POCKET_WALL_FACES_COLOR)
                # Create a sketch on XY plane since there are no bottom face to use here
                sketch = sketches.add(rootComponent.xYConstructionPlane)
                sketch.name = 'Through pocket sketch'
                drawSketchCurves(sketch, boundary)
                # create operation using that sketch
                op = createClosedThroughPocketOperation(pocketRecognitionSetup, 'Closed through pocket', sketch, pocket, roughingTool)
                
            else:
                # BLIND POCKETS: searching the pocket bottom face to use in the operation and side faces for coloring.
                # search the bottom face breps using the points of the boundary
                pocketBottomFaces = getPocketBottomFaces(pocketComponent, points)
                # search the walls face breps using the points of the boundary
                pocketWallFaces = getPocketWallFaces(pocketComponent, points)
                # color pocket bottom faces
                colorFaces(design, pocketBottomFaces, 'pocketBottomFaces', POCKET_BOTTOM_FACES_COLOR)
                # color pocket walls
                colorFaces(design, pocketWallFaces, 'pocketWallFacesColor', POCKET_WALL_FACES_COLOR)
                # define pocket name
                if pocket.isClosed: 
                    name = 'Closed blind pocket'
                else: 
                    name = 'Open blind pocket'
                op = createBlindPocketOperation(pocketRecognitionSetup, name, pocketBottomFaces, pocket, roughingTool)
            # Give control back to Fusion so it can update the graphics.
            adsk.doEvents()
        ########## MAKE POCKETS USING POCKET RECOGNITION SELECTION (FROM UI) ##########
        # create basic roughing operations
        # the distinction between the pockets is done by filtering the pocket heights, within the functions below...
        op = createClosedThroughPocketSelectionOperation(pocketSelectionSetup, 'Closed through pocket (PocketSelection)', roughingTool)
        op = createClosedBlindPocketSelectionOperation(pocketSelectionSetup, 'Closed blind pocket (PocketSelection)', roughingTool)
        
        ########## MAKE HOLES USING HOLE GROUP RECOGNITION API ##########
        # hole groups recognition using "adsk.cam.RecognizedHoleGroup()" is grouping holes of the same type  
        # you could also use "adsk.cam.RecognizedHole()": this will give you all holes but ungrouped...
        holeGroups = adsk.cam.RecognizedHoleGroup.recognizeHoleGroups([body])
        
        # loop through the hole groups found
        for holeGroup in holeGroups:
            
            # analyse a hole from the group to understand their geometry (hole from a group are all the same)
            holeToCheck = holeGroup.item(0)
            
            # check the number of segment and the geometry that make the hole to identify the hole type
            if holeToCheck.segmentCount == 1:
                firstSegment = holeToCheck.segment(0)
                if firstSegment.holeSegmentType == adsk.cam.HoleSegmentType.HoleSegmentTypeCylinder:
                    # this is a simple hole made of one cylinder so let's drill that hole group
                    
                    # color faces
                    for hole in holeGroup:
                        simpleHoleFaces :list[adsk.fusion.BRepFace] = []
                        simpleHoleFaces.extend(hole.segment(0).faces)
                        colorFaces(design, simpleHoleFaces, 'simpleHoleColor', HOLE_SIMPLE_COLOR)
                    # tool
                    drillDiameter = firstSegment.bottomDiameter # check hole diameter to select the right drill
                    drillDepth = firstSegment.height + 0.5 # check the hole length to make sure the drill is long enough... and adding a bit of clearance of 5mm
                    drillTools = getToolsFromLibraryByTypeDiameterRangeAndMinFluteLength(drillingToolLibrary, ToolType.DRILL.value, drillDiameter, drillDiameter, drillDept
                    drillTool = drillTools[0] # pick first tool found
                    
                    # operation
                    createSimpleDrillOperation('Simple drill', holeRecognitionSetup, drillTool, holeGroup)
            elif holeToCheck.segmentCount == 4:
                # a hole with 4 segments might be a counterbore through model with a top chamfer... so let's check the geometry...
                firstSegment = holeToCheck.segment(0)
                secondSegment = holeToCheck.segment(1)
                thirdSegment = holeToCheck.segment(2)
                fourthSegment = holeToCheck.segment(3)
                if firstSegment.holeSegmentType == adsk.cam.HoleSegmentType.HoleSegmentTypeCone:
                    if secondSegment.holeSegmentType == adsk.cam.HoleSegmentType.HoleSegmentTypeCylinder:
                        if thirdSegment.holeSegmentType == adsk.cam.HoleSegmentType.HoleSegmentTypeFlat:
                            if fourthSegment.holeSegmentType == adsk.cam.HoleSegmentType.HoleSegmentTypeCylinder:
                                # a hole made by a cone, a cylinder, a flat and finally a cylinder is our definition of a coulterbore through model with a top chamfer, in 
                                # we will ignore other types of holes made by 4 segments here if any...
                                # color faces                                for hole in holeGroup:
                                    couterboreHoleFaces :list[adsk.fusion.BRepFace] = []
                                    couterboreHoleFaces.extend(hole.segment(0).faces)
                                    couterboreHoleFaces.extend(hole.segment(1).faces)
                                    couterboreHoleFaces.extend(hole.segment(2).faces)
                                    couterboreHoleFaces.extend(hole.segment(3).faces)
                                    colorFaces(design, couterboreHoleFaces, 'counterboreHoleColor', HOLE_COUNTERBORE_COLOR)
                                # pick tool
                                drillDiameter = fourthSegment.bottomDiameter # check hole diameter to select the right drill
                                # check the hole length to make sure the drill is long enough... and adding a bit of clearance of 5mm
                                drillDepth = firstSegment.height + secondSegment.height + fourthSegment.height + 0.5 # no need to using the third segment height since it'
                                drillTools = getToolsFromLibraryByTypeDiameterRangeAndMinFluteLength(drillingToolLibrary, ToolType.DRILL.value, drillDiameter, drillDiamete
                                drillTool = drillTools[0] # pick first tool found
                                
                                # drill
                                createCounterboreDrillOperation('Counterbore drill', holeRecognitionSetup, drillTool, holeGroup)
                                # check counterbopre diameter to select the right flat end mill
                                # we will drill the hole first meaning we don't need to take this into account...
                                # pick a flat end mill for the counterbore
                                minCounterboreToolDiameter = secondSegment.bottomDiameter - fourthSegment.bottomDiameter
                                maxCounterboreToolDiameter = secondSegment.bottomDiameter * 0.75
                                counterboreToolMinFluteLength =  firstSegment.height + secondSegment.height + 0.5 # adding 5mm clearance
                                counterboreTools = getToolsFromLibraryByTypeDiameterRangeAndMinFluteLength(millingToolLibrary, ToolType.FLAT_END_MILL.value, minCounterbore
                                counterboreTool = counterboreTools[0] # pick first tool found
                                
                                # counterbore
                                createCounterboreMillOperation('Counterbore mill', holeRecognitionSetup, counterboreTool, holeGroup)
                                # select tools
                                # pick a spot drill tool for the top chamfer (we will roll over the chamfer so no need for a very large tool)
                                minChamferToolDiameter = 1
                                maxChamferToolDiameter = 1.4
                                chamferTools = getToolsFromLibraryByTypeDiameterRangeAndMinFluteLength(drillingToolLibrary, ToolType.SPOT_DRILL.value, minChamferToolDiamet
                                chamferTool = chamferTools[0] # pick first tool found
                                # chamfer
                                createCounterboreChamferOperation('Counterbore chamfer', holeRecognitionSetup, chamferTool, holeGroup)
            # Give control back to Fusion so it can update the graphics.
            adsk.doEvents()
        # compute all
        cam.generateAllToolpaths(True)
    except:
        _ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
####################### SAMPLE SCRIPT MAIN LOGIC ENDS #######################
#############################################################################
####################### TOOLS #######################
def getToolsFromLibraryByTypeDiameterRangeAndMinFluteLength(toolLibrary: adsk.cam.ToolLibrary, tooltype: str, minDiameter: float, maxDiameter: float, minimumFluteLength: f
    ''' Return a list of tools that fits the search '''
    # set the search critera
    query = toolLibrary.createQuery()
    query.criteria.add('tool_type', adsk.core.ValueInput.createByString(tooltype))
    query.criteria.add('tool_diameter.min', adsk.core.ValueInput.createByReal(minDiameter))
    query.criteria.add('tool_diameter.max', adsk.core.ValueInput.createByReal(maxDiameter))
    if minimumFluteLength:
        query.criteria.add('tool_fluteLength.min', adsk.core.ValueInput.createByReal(minimumFluteLength))
    # get query results
    results = query.execute()
    # get the tools from the query
    tools: list[adsk.cam.Tool] = []
    for result in results:
        # a result has a tool, url, toolLibrary and the index of the tool in that library: we just return the tool here
        tools.append(result.tool)
    return tools
####################### SETUPS #######################
def createSetup(name: str, body: adsk.fusion.BRepBody): 
    ''' Create a setup '''
    app = adsk.core.Application.get()
    doc = app.activeDocument
    products = doc.products
    cam = adsk.cam.CAM.cast(products.itemByProductType("CAMProductType"))
    setups = cam.setups
    # create setup input and set parameters
    input = setups.createInput(adsk.cam.OperationTypes.MillingOperation)
    input.models = [body] 
    input.name = name  
    input.stockMode = adsk.cam.SetupStockModes.RelativeBoxStock
    input.parameters.itemByName('job_stockOffsetMode').expression = "'keep'"
    # create the setup
    setup = setups.add(input) 
    return setup
####################### POCKETS (USING API) #######################
def createClosedThroughPocketOperation(setup: adsk.cam.Setup, name: str, sketch: adsk.fusion.Sketch, pocket: adsk.cam.RecognizedPocket, tool: adsk.cam.Tool) -> adsk.cam.O
    ''' Produce the toolpath for the closed through pocket using API '''
    input = setup.operations.createInput('adaptive2d')
    input.displayName = name
    input.tool = tool
    input.parameters.itemByName('doMultipleDepths').expression = 'true'    pocketHeightIncludingBottomOffsetInMM = round((pocket.depth  * 10) + 2, 3)  # convert cm to mm and add 2 mm from bottomHeight_offset
    input.parameters.itemByName('maximumStepdown').expression = str(pocketHeightIncludingBottomOffsetInMM / 2) + ' mm' # divide total height by 2 to get 2 passes
    input.parameters.itemByName('topHeight_mode').expression = "'from contour'"
    input.parameters.itemByName('topHeight_offset').expression = str(pocket.depth * 10) + ' mm'
    input.parameters.itemByName('bottomHeight_offset').expression = str(-2) + 'mm' # set bottom to be 2 mm below pocket bottom
    # apply the shetch boundary to the operation input
    pocketSelection: adsk.cam.CadContours2dParameterValue = input.parameters.itemByName('pockets').value
    chains = pocketSelection.getCurveSelections()
    chain = chains.createNewSketchSelection()
    chain.inputGeometry = [sketch]
    chain.loopType = adsk.cam.LoopTypes.OnlyOutsideLoops
    chain.sideType = adsk.cam.SideTypes.AlwaysInsideSideType
    pocketSelection.applyCurveSelections(chains)
    # add to the setup
    op = setup.operations.add(input)   
    return op
def createBlindPocketOperation(setup: adsk.cam.Setup, name: str, pocketBottomFaces: list[adsk.fusion.BRepFace], pocket: adsk.cam.RecognizedPocket, tool: adsk.cam.Tool) -> 
    ''' Produce the toolpath for the closed blind pocket using API '''
    input = setup.operations.createInput('adaptive2d')
    input.displayName = name
    input.tool = tool
    input.parameters.itemByName('doMultipleDepths').expression = 'true'
    input.parameters.itemByName('maximumStepdown').expression = str(round(pocket.depth / 2, 3) * 10) + ' mm' # divide total height by 2 to get 2 passes
    input.parameters.itemByName('topHeight_mode').expression = "'from contour'"
    input.parameters.itemByName('topHeight_offset').expression = str(pocket.depth * 10) + ' mm'
    # add to the setup
    op = setup.operations.add(input)
    # apply the limits edge to the operation
    pocketSelection: adsk.cam.CadContours2dParameterValue = op.parameters.itemByName('pockets').value
    chains = pocketSelection.getCurveSelections()
    chain = chains.createNewPocketSelection()
    chain.inputGeometry = pocketBottomFaces
    pocketSelection.applyCurveSelections(chains) 
    return op
####################### POCKETS (USING UI) #######################
def createClosedThroughPocketSelectionOperation(setup: adsk.cam.Setup, name: str, tool: adsk.cam.Tool):
    ''' Produce the toolpath for the closed through pocket using UI '''
    input = setup.operations.createInput('adaptive2d')
    input.displayName = name
    input.tool = tool
    input.parameters.itemByName('doMultipleDepths').expression = 'true'
    input.parameters.itemByName('maximumStepdown').expression = '12 mm' # just dividiung the pocket height by 2 to have 2 steps
    input.parameters.itemByName('bottomHeight_offset').expression = str(-2) + ' mm' # bottom height = 2 mm below pocket bottom
    # add to the setup
    op = setup.operations.add(input)
    # apply the shetch boundary to the operation
    pocketSelection: adsk.cam.CadContours2dParameterValue = op.parameters.itemByName('pockets').value
    chains = pocketSelection.getCurveSelections()
    chain = chains.createNewPocketRecognitionSelection()
    chain.maximumPocketDepth = 2.5 # (cm) define some pocket recognition settings to filter pockets by height (measured from UI)
    chain.minimumPocketDepth = 1.5 # (cm)
    pocketSelection.applyCurveSelections(chains)
    return op
def createClosedBlindPocketSelectionOperation(setup: adsk.cam.Setup, name: str, tool: adsk.cam.Tool):
    ''' Produce the toolpath for the closed blind pocket using UI '''
    input = setup.operations.createInput('adaptive2d')
    input.displayName = name
    input.tool = tool
    input.parameters.itemByName('doMultipleDepths').expression = 'true'
    input.parameters.itemByName('maximumStepdown').expression = '6 mm'
    # add to the setup
    op = setup.operations.add(input)
    # apply the shetch boundary to the operation
    pocketSelection: adsk.cam.CadContours2dParameterValue = op.parameters.itemByName('pockets').value
    chains = pocketSelection.getCurveSelections()
    chain = chains.createNewPocketRecognitionSelection()
    chain.maximumPocketDepth = 1.5 # (cm) define some pocket recognition settings to filter pockets by height (measured from UI)
    chain.minimumPocketDepth = 0   # (cm)
    pocketSelection.applyCurveSelections(chains)
    return op
####################### POCKET HELPER FUNCTION #######################
def isCircularPocket(pocket: adsk.cam.RecognizedPocket) -> bool:
    ''' Returns true if this is a circular pocket (= a hole) made of boundaries with circular segments only '''
    isCircleFound = False
    boundaries = pocket.boundaries
    for i in range(len(boundaries)):
        boundary = boundaries[i]
        for j in range(boundary.count):
            segment = boundary.item(j)
            if segment.classType() == adsk.core.Circle3D.classType(): 
                isCircleFound = True
            else:
                return False
                return isCircleFound
def getBoundaryKeyPoints(boundary: list[adsk.core.Curve3DPath]) -> list[adsk.core.Point3D]:
    ''' Get some key points on the pocket boundary '''
    points: list[adsk.core.Point3D] = []
    for segment in boundary:
        # cast to get the actual segment type (casting returns None if the wrong object is passed)
        line3D = adsk.core.Line3D.cast(segment)
        arc3D = adsk.core.Arc3D.cast(segment)
        if line3D:
            points.append(line3D.startPoint)
            points.append(line3D.endPoint)
        elif arc3D:
            points.append(arc3D.startPoint)
            points.append(arc3D.endPoint)
        else:
            classType = segment.classType()
            raise Exception('Unsupported pocket curve type for this sample script: ' + classType)
    
    return points
def getPocketBottomFaces(component: adsk.fusion.Component, points: list[adsk.core.Point3D]) -> list[adsk.fusion.BRepFace]:
    ''' Search the pocket bottom faces using the provided points '''
    # search the bottom face breps using the provided points of the boundary
    pocketBottomFaces: list[adsk.fusion.BRepFace] = []
    # define the Z value of the pocket bottom using a recognized boundary point
    pocketBottomZ = points[0].z
    for point in points:
        breps = component.findBRepUsingPoint(point, adsk.fusion.BRepEntityTypes.BRepFaceEntityType, PROXIMITY_TOLERANCE, True)
        for brep in breps:
            # cast so we have a nice typed variable
            brep = adsk.fusion.BRepFace.cast(brep)
            # filter to only find the flat faces (not the pocket walls)
            if brep.boundingBox.minPoint.z == pocketBottomZ and brep.boundingBox.maxPoint.z == pocketBottomZ:
                if not brep in pocketBottomFaces:
                    pocketBottomFaces.append(brep)
    return pocketBottomFaces
def getPocketWallFaces(component: adsk.fusion.Component, points: list[adsk.core.Point3D]) -> list[adsk.fusion.BRepFace]:
    ''' Search the pocket wall faces using the provided points '''
    # search the walls face breps using the points of the boundary
    pocketWallFaces: list[adsk.fusion.BRepFace] = []
    # define the Z value of the pocket bottom using a recognized boundary point
    pocketBottomZ = points[0].z
    for point in points:
        breps = component.findBRepUsingPoint(point, adsk.fusion.BRepEntityTypes.BRepFaceEntityType, PROXIMITY_TOLERANCE, True)
        for brep in breps:
            # cast so we have a nice typed variable
            brep = adsk.fusion.BRepFace.cast(brep)
            # filter to only find the wall faces (not the pocket bottom faces)
            if brep.boundingBox.minPoint.z == pocketBottomZ and brep.boundingBox.maxPoint.z > pocketBottomZ:
                if not brep in pocketWallFaces:
                    pocketWallFaces.append(brep)
    return pocketWallFaces
####################### DRILLING #######################
def createSimpleDrillOperation(name: str, setup: adsk.cam.Setup, tool: adsk.cam.Tool, holeGroup: adsk.cam.RecognizedHoleGroup):
    ''' Create simple drilling operation '''
    input = setup.operations.createInput('drill')
    input.displayName = name
    input.tool = tool
    input.parameters.itemByName('drillTipThroughBottom').expression = 'true'
    input.parameters.itemByName('breakThroughDepth').expression = '2 mm'
    # select the holes faces to drill
    faces: list[adsk.fusion.BRepFace] = []
    for i in range(holeGroup.count):
        hole = holeGroup.item(i)
        firstSegment = hole.segment(0)
        faces.extend(firstSegment.faces)
    holeSelection: adsk.cam.CadObjectParameterValue = input.parameters.itemByName('holeFaces').value
    holeSelection.value = faces
    # add to setup
    setup.operations.add(input)
def createCounterboreDrillOperation(name: str, setup: adsk.cam.Setup, tool: adsk.cam.Tool, holeGroup: adsk.cam.RecognizedHoleGroup):
    ''' Create drilling operation for the counterbore hole '''
    input = setup.operations.createInput('drill')
    input.displayName = name
    input.tool = tool
    input.parameters.itemByName('drillTipThroughBottom').expression = 'true'
    input.parameters.itemByName('breakThroughDepth').expression = '2 mm'
    # select the holes faces to drill
    faces: list[adsk.fusion.BRepFace] = []
    for i in range(holeGroup.count):
        hole = holeGroup.item(i)
        firstSegment = hole.segment(0)
        secondSegment = hole.segment(1)
        fourthSegment = hole.segment(3)
        faces.extend(firstSegment.faces)        faces.extend(secondSegment.faces)
        faces.extend(fourthSegment.faces)
    holeSelection: adsk.cam.CadObjectParameterValue = input.parameters.itemByName('holeFaces').value
    holeSelection.value = faces
    # add to setup
    setup.operations.add(input)
def createCounterboreMillOperation(name: str, setup: adsk.cam.Setup, tool: adsk.cam.Tool, holeGroup: adsk.cam.RecognizedHoleGroup):
    ''' Create milling operation for the counterbore part of the hole '''
    input = setup.operations.createInput('contour2d')
    input.displayName = name
    input.tool = tool
    input.parameters.itemByName('doLeadIn').expression = 'false'
    input.parameters.itemByName('doRamp').expression = 'true'
    input.parameters.itemByName('rampAngle').expression = '2 deg'
    input.parameters.itemByName('exit_verticalRadius').expression = '0 mm'
    input.parameters.itemByName('exit_radius').expression = '0 mm'
    # select the counterbore bottom edge to mill
    edges: list[adsk.fusion.BRepEdge] = []
    for i in range(holeGroup.count):
        hole = holeGroup.item(i)
        secondSegment = hole.segment(1) # counterbore segment
        edge = getHoleSegmentBottomEdge(secondSegment)
        edges.append(edge)
    holeSelection: adsk.cam.CadContours2dParameterValue = input.parameters.itemByName('contours').value
    chains = holeSelection.getCurveSelections()
    # each edge is a separate chain selection since it's own by separate holes
    for edge in edges:
        chain = chains.createNewChainSelection()
        chain.isReverted = True
        chain.inputGeometry = [edge]
    holeSelection.applyCurveSelections(chains) 
    # add to setup
    setup.operations.add(input)
def createCounterboreChamferOperation(name: str, setup: adsk.cam.Setup, tool: adsk.cam.Tool, holeGroup: adsk.cam.RecognizedHoleGroup):
    ''' Create an operation for the top chamfer of the counterbore '''
    input = setup.operations.createInput('chamfer2d')
    input.displayName = name
    input.tool = tool
    input.parameters.itemByName('chamferClearance').expression = '0 mm'
    input.parameters.itemByName('entry_distance').expression = '5 mm'
    input.parameters.itemByName('chamferTipOffset').expression = '1 mm'
    # select the counterbore chamfers bottom edge to mill
    edges: list[adsk.fusion.BRepEdge] = []
    for i in range(holeGroup.count):
        hole = holeGroup.item(i)
        firstSegment = hole.segment(0) # chamfer segment
        edge = getHoleSegmentBottomEdge(firstSegment)
        edges.append(edge)
    holeSelection: adsk.cam.CadContours2dParameterValue = input.parameters.itemByName('contours').value
    chains = holeSelection.getCurveSelections()
    for edge in edges:
        # each edge is a separate chain selection since it's own by separate holes
        chain = chains.createNewChainSelection()
        chain.isReverted = True
        chain.inputGeometry = [edge] 
    holeSelection.applyCurveSelections(chains) 
    # add to setup
    setup.operations.add(input)
def getHoleSegmentBottomEdge(segment: adsk.cam.RecognizedHoleSegment) -> adsk.fusion.BRepEdge:
    ''' Get the bottom edge of a given hole segment (assuming the hole is algned on Z+) '''
    # we assume:
    #  - the segment is made by one face
    #  - the hole is aligned with Z+ (bounding box checking)
    if len(segment.faces) != 1:
        raise Exception('A hole segment with a single face is expected!')
    face = adsk.fusion.BRepFace.cast(segment.faces[0]) 
    faceEdges = face.edges
    if len(faceEdges) != 2:
        raise Exception('A hole segment with a single face made of 2 edges is expected!')
    if faceEdges[0].boundingBox.maxPoint.z < faceEdges[1].boundingBox.maxPoint.z:
        edge = faceEdges[0]
    else:
        edge = faceEdges[1]
    return edge
####################### SKETCHING #######################
def drawSketchCurves(sketch: adsk.fusion.Sketch, boundary: list[adsk.core.Curve3D]):
    ''' Create a sketch from given pocket boundary or island '''
    for segment in boundary:
        # cast to get the actual segment type (casting returns None if the wrong object is passed)
        line3D = adsk.core.Line3D.cast(segment)
        arc3D = adsk.core.Arc3D.cast(segment)
        circle3D = adsk.core.Circle3D.cast(segment)
        if line3D:
            startPoint = line3D.startPoint
            endPoint = line3D.endPoint
            sketchLine(sketch, startPoint, endPoint)        elif arc3D:
            startPoint = arc3D.startPoint
            centerPoint = arc3D.center
            sweepAngle = arc3D.endAngle
            normal = arc3D.normal
            sketchTwoPointArc(sketch, centerPoint, startPoint, sweepAngle, normal)           
        elif circle3D:
            centerPoint = circle3D.center
            radius = circle3D.radius
            sketchCircles(sketch, centerPoint, radius)
        else:
            classType = segment.classType()
            raise Exception('Unsupported pocket curve type for this sample script: ' + classType)
    mergeCoincidentPoints(sketch)
    # Give control back to Fusion so it can update the graphics.
    adsk.doEvents()
def mergeCoincidentPoints(sketch: adsk.fusion.Sketch):
    ''' Merge sketchpoints that are coincident. '''
    endPoints: list[adsk.fusion.SketchPoint] = []
    # Get the end points of all lines and arcs.
    for skLine in sketch.sketchCurves.sketchLines:
        endPoints.append(skLine.startSketchPoint)
        endPoints.append(skLine.endSketchPoint)
    for skArc in sketch.sketchCurves.sketchArcs:
        endPoints.append(skArc.startSketchPoint)
        endPoints.append(skArc.endSketchPoint)
    # Check if the points are at the same location and add a constraint.
    for i in range(len(endPoints)):
        point1 = endPoints[i]
        if not point1 is None:
            for j in range(i+ 1, len(endPoints)):
                point2 = endPoints[j]
                if not point2 is None:
                    if point1.geometry.isEqualTo(point2.geometry):
                        point1.merge(point2)
                        endPoints[i] = None
                        endPoints[j] = None
def sketchCircles(sketch: adsk.fusion.Sketch, centerPoint: adsk.core.Point3D, radius: float) -> adsk.fusion.SketchCircle:
    ''' Create a circle based on the points  '''
    circles = sketch.sketchCurves.sketchCircles
    circle = circles.addByCenterRadius(centerPoint, radius)
    return circle
def sketchTwoPointArc(sketch: adsk.fusion.Sketch, centerPoint: adsk.core.Point3D, startPoint: adsk.core.Point3D, sweepAngle: float, normal: adsk.core.Vector3D) -> adsk.fu
    ''' Sketch a arc based on center, radius and sweepangle '''
    arcs = sketch.sketchCurves.sketchArcs
    arc = arcs.addByCenterStartSweep(centerPoint, startPoint, sweepAngle)
    arcNormal = arc.geometry.normal
    # check whether the arc is drawn in the right direction
    if not arcNormal.z - normal.z < 0.000001 and arcNormal.y - normal.y < 0.000001 and arcNormal.x - normal.x < 0.000001:  
        arc.deleteMe()
        arc = arcs.addByCenterStartSweep(centerPoint, startPoint, -sweepAngle)
    return arc
        
def sketchLine(sketch: adsk.fusion.Sketch, startPoint: adsk.core.Point3D, endPoint: adsk.core.Point3D) -> adsk.fusion.SketchLine:
    ''' Sketch a straight line based on the starting and ending points '''
    lines = sketch.sketchCurves.sketchLines
    line = lines.addByTwoPoints(startPoint, endPoint)
    return line
####################### COLORING #######################
def colorFaces(design: adsk.fusion.Design, faces: list[adsk.fusion.BRepFace], colorName: str, color: adsk.core.Color):
    ''' Color given BRepFaces '''
    app = adsk.core.Application.get()
    # look for the color
    fusionMaterials = app.materialLibraries.itemByName('Fusion 360 Appearance Library')
    newColor = design.appearances.itemByName(colorName)
    if not newColor:
        # Get the existing Red appearance.            
        redColor = fusionMaterials.appearances.itemByName('Paint - Enamel Glossy (Red)')
        # Copy it to the design, giving it a new name.
        newColor = design.appearances.addByCopy(redColor, colorName)                    
        # Change the color of the default appearance to the provided one.
        theColor: adsk.core.ColorProperty = newColor.appearanceProperties.itemByName('Color')
        theColor.value = color
    # color given faces
    for face in faces:
        face.appearance = newColor
    # Give control back to Fusion so it can update the graphics.
    adsk.doEvents()
####################### CREATE SAMPLE PART #######################
def createSampleBody(component: adsk.fusion.Component) -> adsk.fusion.BRepBody:
    ''' Create a sample part for the script '''
    # Get reference to the sketchs
    sketches = component.sketches    # Get the extrude features Collection for the component
    extrudes = component.features.extrudeFeatures
    chamfers = component.features.chamferFeatures
    
    # create a cuiboid
    rectangle = sketches.add(component.xYConstructionPlane)
    rectangle.sketchCurves.sketchLines.addTwoPointRectangle(adsk.core.Point3D.create(0, 0, 0), adsk.core.Point3D.create(22.0, 15.0, 0))
    blockExtrude = createExtrudeFeature(extrudes, rectangle, 2, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
    # create a simple hole
    holeOne = sketches.add(component.xYConstructionPlane)
    circleOne = [adsk.core.Circle3D.createByCenter(adsk.core.Point3D.create(3, 11.5, 2), adsk.core.Vector3D.create(0, 0, 1), 0.5)]
    drawSketchCurves(holeOne, circleOne)
    createExtrudeFeature(extrudes, holeOne, -2, adsk.fusion.FeatureOperations.CutFeatureOperation)
    # create another simple hole
    holeTwo = sketches.add(component.xYConstructionPlane)
    circleTwo = [adsk.core.Circle3D.createByCenter(adsk.core.Point3D.create(5, 11.5, 2), adsk.core.Vector3D.create(0, 0, 1), 0.5)]
    drawSketchCurves(holeTwo, circleTwo)
    createExtrudeFeature(extrudes, holeTwo, -2, adsk.fusion.FeatureOperations.CutFeatureOperation)
    # Give control back to Fusion so it can update the graphics.
    adsk.doEvents()
    # Create six counterbore holes
    sk = sketches.add(blockExtrude.endFaces[0])
    skPoints = adsk.core.ObjectCollection.create()
    for i in range(1, 3):
        for j in range(1, 4):
            pstn = adsk.core.Point3D.create(3 * j, 3 * i, 0)
            skPoint = sk.sketchPoints.add(pstn)
            skPoints.add(skPoint)
    holes = component.features.holeFeatures
    counterBoreDiam = adsk.core.ValueInput.createByReal(2)
    counterBoreDepth = adsk.core.ValueInput.createByReal(1)
    holeDiam = adsk.core.ValueInput.createByReal(1)
    holeInput = holes.createCounterboreInput(holeDiam, counterBoreDiam, counterBoreDepth)
    holeInput.setAllExtent(adsk.fusion.ExtentDirections.PositiveExtentDirection)
    holeInput.setPositionBySketchPoints(skPoints)
    holeFeature = holes.add(holeInput)
    # Give control back to Fusion so it can update the graphics.
    adsk.doEvents()
    # Find the top edges of the holes to add a chamfer.
    topFace = blockExtrude.endFaces[0]
    chamferEdges = adsk.core.ObjectCollection.create()
    for cylinderFace in holeFeature.faces:
        if isinstance(cylinderFace.geometry, adsk.core.Cylinder):
            commonEdge = findCommonEdge(cylinderFace, topFace)
            if commonEdge:
                chamferEdges.add(commonEdge)
    # create the chamfer
    chamferInput = chamfers.createInput2()
    offset = adsk.core.ValueInput.createByReal(0.3)
    chamferInput.chamferEdgeSets.addEqualDistanceChamferEdgeSet(chamferEdges, offset, False)
    chamfers.add(chamferInput)
    # Give control back to Fusion so it can update the graphics.
    adsk.doEvents()
    # create a closed pocket
    pocketOne =  sketches.add(component.xYConstructionPlane)
    geometries: list[adsk.core.Curve3D] = []
    geometries.append(adsk.core.Line3D.create(adsk.core.Point3D.create(12, 1.5, 2),adsk.core.Point3D.create(13, 1.5, 2)))
    geometries.append(adsk.core.Line3D.create(adsk.core.Point3D.create(14, 2.5, 2),adsk.core.Point3D.create(14, 4.5, 2)))
    geometries.append(adsk.core.Line3D.create(adsk.core.Point3D.create(13, 5.5, 2),adsk.core.Point3D.create(12, 5.5, 2)))
    geometries.append(adsk.core.Line3D.create(adsk.core.Point3D.create(11, 4.5, 2),adsk.core.Point3D.create(11, 2.5, 2)))
    geometries.append(adsk.core.Arc3D.createByCenter(adsk.core.Point3D.create(12, 2.5, 2), adsk.core.Vector3D.create(0, 0, 1), adsk.core.Vector3D.create(-1, 0, 0), 1, 0, m
    geometries.append(adsk.core.Arc3D.createByCenter(adsk.core.Point3D.create(13, 2.5, 2), adsk.core.Vector3D.create(0, 0, 1), adsk.core.Vector3D.create(0, -1, 0), 1, 0, m
    geometries.append(adsk.core.Arc3D.createByCenter(adsk.core.Point3D.create(13, 4.5, 2), adsk.core.Vector3D.create(0, 0, 1), adsk.core.Vector3D.create(1, 0, 0), 1, 0, ma
    geometries.append(adsk.core.Arc3D.createByCenter(adsk.core.Point3D.create(12, 4.5, 2), adsk.core.Vector3D.create(0, 0, 1), adsk.core.Vector3D.create(0, 1, 0), 1, 0, ma
    drawSketchCurves(pocketOne, geometries)
    createExtrudeFeature(extrudes, pocketOne, -1, adsk.fusion.FeatureOperations.CutFeatureOperation)
    # create a open pocket
    pocketTwo = sketches.add(component.xYConstructionPlane)
    pocketTwoOutline: list[adsk.core.Curve3D] = []
    pocketTwoOutline.append(adsk.core.Line3D.create(adsk.core.Point3D.create(12, 7.5, 2),adsk.core.Point3D.create(18, 7.5, 2)))
    pocketTwoOutline.append(adsk.core.Line3D.create(adsk.core.Point3D.create(19, 8.5, 2),adsk.core.Point3D.create(19, 11.5, 2)))
    pocketTwoOutline.append(adsk.core.Line3D.create(adsk.core.Point3D.create(18, 12.5, 2),adsk.core.Point3D.create(12, 12.5, 2)))
    pocketTwoOutline.append(adsk.core.Line3D.create(adsk.core.Point3D.create(11, 11.5, 2),adsk.core.Point3D.create(11, 8.5, 2)))
    pocketTwoOutline.append(adsk.core.Arc3D.createByCenter(adsk.core.Point3D.create(12, 8.5, 2), adsk.core.Vector3D.create(0, 0, 1), adsk.core.Vector3D.create(-1,0,0), 1, 
    pocketTwoOutline.append(adsk.core.Arc3D.createByCenter(adsk.core.Point3D.create(18, 8.5, 2), adsk.core.Vector3D.create(0, 0, 1), adsk.core.Vector3D.create(0,-1,0), 1, 
    pocketTwoOutline.append(adsk.core.Arc3D.createByCenter(adsk.core.Point3D.create(18, 11.5, 2), adsk.core.Vector3D.create(0, 0, 1), adsk.core.Vector3D.create(1,0,0), 1, 
    pocketTwoOutline.append(adsk.core.Arc3D.createByCenter(adsk.core.Point3D.create(12, 11.5, 2), adsk.core.Vector3D.create(0, 0, 1), adsk.core.Vector3D.create(0,1,0), 1, 
    drawSketchCurves(pocketTwo, pocketTwoOutline)
    createExtrudeFeature(extrudes, pocketTwo, -2, adsk.fusion.FeatureOperations.CutFeatureOperation)
    # create a pocket on the side
    pocketThree =  sketches.add(component.xYConstructionPlane)
    pocketThreeOutline: list[adsk.core.Curve3D] = []
    pocketThreeOutline.append(adsk.core.Line3D.create(adsk.core.Point3D.create(18, 0, 2),adsk.core.Point3D.create(22, 0, 2)))
    pocketThreeOutline.append(adsk.core.Line3D.create(adsk.core.Point3D.create(22, 0, 2),adsk.core.Point3D.create(22, 4.5, 2)))
    pocketThreeOutline.append(adsk.core.Line3D.create(adsk.core.Point3D.create(22, 4.5, 2),adsk.core.Point3D.create(19, 4.5, 2)))
    pocketThreeOutline.append(adsk.core.Line3D.create(adsk.core.Point3D.create(18, 3.5, 2),adsk.core.Point3D.create(18, 0, 2)))
    pocketThreeOutline.append(adsk.core.Arc3D.createByCenter(adsk.core.Point3D.create(19, 3.5, 2), adsk.core.Vector3D.create(0,0,1), adsk.core.Vector3D.create(0, 1, 0), 1
    drawSketchCurves(pocketThree, pocketThreeOutline)
    createExtrudeFeature(extrudes, pocketThree, -1.5, adsk.fusion.FeatureOperations.CutFeatureOperation)
    # Give control back to Fusion so it can update the graphics.
    adsk.doEvents()    # return the created body
    part = component.bRepBodies.item(0)
    return part
def createExtrudeFeature(extrudeFeatures: adsk.fusion.ExtrudeFeatures, sketch: adsk.fusion.Sketch, height: float, operation: adsk.fusion.FeatureOperations) -> adsk.fusion
    ''' Create an extrude feature '''
    # Get the profile defined by the circle
    shape = sketch.profiles.item(0)
    # Define that the extent is a distance extent of 1 cm
    distance = adsk.core.ValueInput.createByReal(height)
    # Create the extrusion
    return extrudeFeatures.addSimple(shape, distance, operation)
# Find the edge that connects to the input faces.
def findCommonEdge(face1: adsk.fusion.BRepFace, face2: adsk.fusion.BRepFace) -> adsk.fusion.BRepEdge:
    # Checks to see if any of the edges of face1 connect to face2.
    edge: adsk.fusion.BRepEdge = None
    for edge in face1.edges:
        for face in edge.faces:
            if face == face2:
                return edge
            
    return None
Manufacturing Workflow API Sample
Description
Manufacturing Workflow API Sample
This sample script starts by creating a simple component which is then used to describe a milling workflow . It creates a setup, a few operations, pick some tools from a Fusion 360 sample
tool library using loops and queries and ends up post-processing the operations out using an NC Program.
Code Samples
Python
Copy Code
import adsk.core, adsk.fusion, adsk.cam, traceback
import math
import os
from enum import Enum
#################### Some constants used in the script ####################
# We assume we are cutting Aluminum here...
# Milling tool library to get tools from
MILLING_TOOL_LIBRARY = 'Milling Tools (Metric)'
# Some material properties for feed and speed calculation
ALUMINUM_CUTTING_SPEED = 300  # mm/min
ALUMINUM_FEED_PER_TOOTH = 0.1 # mm/tooth
# some tool preset name (which we know exists for the selected tools)
ALUMINUM_PRESET_ROUGHING = 'alu* rou*'
ALUMINUM_PRESET_FINISHING = 'Aluminum - Finishing'
#################### Some useful enumerators ####################
# Some tool types used in this script (enumerator)
class ToolType(Enum):
    BULL_NOSE_END_MILL = 'bull nose end mill'
    BALL_END_MILL = 'ball end mill'
    FACE_MILL = 'face mill'
# Setup work coordinate system (WCS) location (enumerator)
class SetupWCSPoint(Enum):
    TOP_CENTER = 'top center'
    TOP_XMIN_YMIN = 'top 1'
    TOP_XMAX_YMIN = 'top 2'
    TOP_XMIN_YMAX = 'top 3'
    TOP_XMAX_YMAX = 'top 4'
    TOP_SIDE_YMIN = 'top side 1'
    TOP_SIDE_XMAX = 'top side 2'
    TOP_SIDE_YMAX = 'top side 3'
    TOP_SIDE_XMIN = 'top side 4'
    CENTER = 'center'
    MIDDLE_XMIN_YMIN = 'middle 1'
    MIDDLE_XMAX_YMIN = 'middle 2'
    MIDDLE_XMIN_YMAX = 'middle 3'
    MIDDLE_XMAX_YMAX = 'middle 4'
    MIDDLE_SIDE_YMIN = 'middle side 1'
    MIDDLE_SIDE_XMAX = 'middle side 2'
    MIDDLE_SIDE_YMAX = 'middle side 3'
    MIDDLE_SIDE_XMIN = 'middle side 4'
    BOTTOM_CENTER = 'bottom center'
    BOTTOM_XMIN_YMIN = 'bottom 1'
    BOTTOM_XMAX_YMIN = 'bottom 2'
    BOTTOM_XMIN_YMAX = 'bottom 3'    BOTTOM_XMAX_YMAX = 'bottom 4'
    BOTTOM_SIDE_YMIN = 'bottom side 1'
    BOTTOM_SIDE_XMAX = 'bottom side 2'
    BOTTOM_SIDE_YMAX = 'bottom side 3'
    BOTTOM_SIDE_XMIN = 'bottom side 4'
#################### Script entry point ####################
def run(context):
    ui = None
    try:
        #################### initialisation #####################
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # create a new empty document
        doc: adsk.core.Document = app.documents.add(adsk.core.DocumentTypes.FusionDesignDocumentType)
        # get the design document used to create the sample part
        design = app.activeProduct
        # switch to manufacturing space
        camWS = ui.workspaces.itemById('CAMEnvironment') 
        camWS.activate()
        # get the CAM product
        products = doc.products
        #################### create sample part ####################
        part = createSamplePart(design)
        #################### select cutting tools ####################
        # get the tool libraries from the library manager
        camManager = adsk.cam.CAMManager.get()
        libraryManager = camManager.libraryManager
        toolLibraries = libraryManager.toolLibraries
        url = None
        useHardCodedUrl = False
        if useHardCodedUrl:
            # we could use a library URl directly if we know its address
            libUrl = 'systemlibraryroot://Samples/Milling Tools (Metric).json'
            url = adsk.core.URL.create(libUrl)
        else:
            # or we can use the tool library objects
            # fusion360 folder in the tool library
            fusion360Folder = toolLibraries.urlByLocation(adsk.cam.LibraryLocations.Fusion360LibraryLocation)
            fusion360Libs = getLibrariesURLs(toolLibraries, fusion360Folder)
            # search the required library url in the libraries
            for libUrl in fusion360Libs:
                if MILLING_TOOL_LIBRARY in libUrl:
                    url = adsk.core.URL.create(libUrl)
                    break
        
        # load tool library
        toolLibrary = toolLibraries.toolLibraryAtURL(url)
        # create some variables to host the milling tools which will be used in the operations
        faceTool = None
        adaptiveTool = None
        finishingTool = None
        # searchig the face mill and the bull nose using a loop for the roughing operations
        for tool in toolLibrary:
            # read the tool type
            toolType = tool.parameters.itemByName('tool_type').value.value 
            
            # select the first face tool found
            if toolType == ToolType.FACE_MILL.value and not faceTool:
                faceTool = tool  
            
            # search the roughing tool
            elif toolType == ToolType.BULL_NOSE_END_MILL.value and not adaptiveTool:
                # we look for a buul nose end mill tool larger or equal to 12mm but less than 14mm
                diameter = tool.parameters.itemByName('tool_diameter').value.value
                if diameter >= 1.2 and diameter < 1.4: 
                    adaptiveTool = tool
            # exit when the 2 tools are found
            if faceTool and adaptiveTool:
                break
        # searching a ball end mill tool with diameter between 6 mm and 10 mm with a minimum flute length of 20.001mm, using a query
        finishingTools = getToolsFromLibraryByTypeDiameterRangeAndMinFluteLength(toolLibrary, ToolType.BALL_END_MILL.value, 0.6, 1, 2.0001)
        # for this example, we select the first tool found as our finishing tool
        finishingTool = finishingTools[0]
        #################### create setup ####################
        cam = adsk.cam.CAM.cast(products.itemByProductType("CAMProductType"))
        setups = cam.setups
        setupInput = setups.createInput(adsk.cam.OperationTypes.MillingOperation)
        # create a list for the models to add to the setup Input
        models = [] 
        # add the part to the model list
        models.append(part)
        # pass the model list to the setup input
        setupInput.models = models
        # create the setup and set some properties        setup = setups.add(setupInput)
        setup.name = 'CAM Automation Script Sample'
        setup.stockMode = adsk.cam.SetupStockModes.RelativeBoxStock
        # set offset mode
        setup.parameters.itemByName('job_stockOffsetMode').expression = "'simple'"
        # set offset stock side
        setup.parameters.itemByName('job_stockOffsetSides').expression = '0 mm'
        # set offset stock top
        setup.parameters.itemByName('job_stockOffsetTop').expression = '1 mm'
        # set setup origin
        setup.parameters.itemByName('wcs_origin_boxPoint').value.value = SetupWCSPoint.TOP_XMIN_YMIN.value
        #################### face operations ####################
        # calculate feed and speed for face operation
        toolDiameter = faceTool.parameters.itemByName('tool_diameter').value.value          # cm
        numberOfFlutes = faceTool.parameters.itemByName('tool_numberOfFlutes').value.value  # int
        spindleSpeed = ALUMINUM_CUTTING_SPEED / math.pi / (toolDiameter * 10) * 1000        # rpm
        cuttingFeedrate = spindleSpeed * ALUMINUM_FEED_PER_TOOTH * numberOfFlutes           # mm/min
        # create a preset with those calculated feeds
        facePreset = faceTool.presets.add()
        facePreset.name = 'Aluminum (set by script)'
        facePreset.parameters.itemByName('tool_spindleSpeed').value.value = int(spindleSpeed)
        facePreset.parameters.itemByName('tool_feedCutting').expression = str(int(cuttingFeedrate)) + ' mm/min'
        # create a face operation input
        input = setup.operations.createInput('face')
        input.tool = faceTool
        input.toolPreset = facePreset # assign created preset
        input.displayName = 'Face Operation'       
        input.parameters.itemByName('tolerance').expression = '0.01 mm'
        input.parameters.itemByName('stepover').expression = '0.75 * tool_diameter'
        input.parameters.itemByName('direction').expression = "'climb'"
        # determine pass angle along largest part dimension
        # get stock box dimensions in cm
        stockX = setup.parameters.itemByName('job_stockInfoDimensionX').value.value
        stockY = setup.parameters.itemByName('job_stockInfoDimensionY').value.value
        # determine pass angle to be along largest length (X or Y) of the block
        if stockX >= stockY:
            input.parameters.itemByName('passAngle').expression = '0 deg' 
        else:
            input.parameters.itemByName('passAngle').expression = '90 deg'
        # add the operation to the setup
        faceOp = setup.operations.add(input)
        #################### adaptive operations ####################
        input = setup.operations.createInput('adaptive')
        input.tool = adaptiveTool
        input.displayName = 'Adaptive Roughing'
        input.parameters.itemByName('tolerance').expression = '0.1 mm' 
        input.parameters.itemByName('maximumStepdown').expression = '5 mm' 
        input.parameters.itemByName('fineStepdown').expression = '0.25 * maximumStepdown'
        input.parameters.itemByName('flatAreaMachining').expression = 'false'
        # look if there is a tool preset related to aluminum roughing
        presets = adaptiveTool.presets.itemsByName(ALUMINUM_PRESET_ROUGHING)
        if len(presets) > 0:
            # we pick and use the first preset found
            adaptivePreset = presets[0]
            input.toolPreset = adaptivePreset
        # add the operation to the setup
        adaptiveOp = setup.operations.add(input)
        #################### finishing tool preset ####################
        # get a tool preset from the finishing tool
        finishingPreset = None
        presets = finishingTool.presets.itemsByName(ALUMINUM_PRESET_FINISHING)
        if len(presets) > 0:
            # use the first aluminum finishing preset found
            finishingPreset = presets[0]
        #################### parallel operations ####################
        input = setup.operations.createInput('parallel')
        input.tool = finishingTool
        input.displayName = 'Parallel Finishing'
        input.parameters.itemByName('tolerance').expression = '0.01 mm'
        input.parameters.itemByName('cuspHeightStepover').expression = '0.005 mm'
        input.parameters.itemByName('boundaryMode').expression = "'selection'"
        if finishingPreset:
            # assign the finishig tool preset
            input.toolPreset = finishingPreset
        # add the operation to the setup
        parallelOp = setup.operations.add(input)
        # lets use a contour for the sake of demonstration
        limitEdge = None
        for e in part.edges:
            # this is the inner one: intersection of a plane and a sphere making up a circle
            if e.geometry.curveType == adsk.core.Curve3DTypes.Circle3DCurveType:
                limitEdge = e
                break
        if limitEdge:
            # apply the limits edge to the operation
            cadcontours2dParam: adsk.cam.CadContours2dParameterValue = parallelOp.parameters.itemByName('machiningBoundarySel').value
            chains = cadcontours2dParam.getCurveSelections()
            chain = chains.createNewChainSelection()            chain.inputGeometry = [limitEdge]
            cadcontours2dParam.applyCurveSelections(chains)
        #################### steep and shallow operations ####################
        # Create folder for finishing operations that require Machining Extension
        operationInput = setup.operations.createInput('folder')
        operationInput.displayName = 'Machining Extension Required'
        folder: adsk.cam.CAMFolder = setup.operations.add(operationInput)
        # Create steep and shallow operation in the folder
        input = setup.operations.createInput('steep_and_shallow')
        input.tool = finishingTool
        input.displayName = 'Steep and Shallow Finishing'
        input.parameters.itemByName('tolerance').expression = '0.01 mm'
        input.parameters.itemByName('useAvoidFlats').expression = 'true'
        input.parameters.itemByName('cuspHeightStepdown').expression = '0.005 mm'
        input.parameters.itemByName('cuspHeightStepover').expression = 'cuspHeightStepdown'
        input.parameters.itemByName('spiral').expression = 'true'
        input.parameters.itemByName('shallowSpiral').expression = 'true'
        input.parameters.itemByName('offsetSmoothing').expression = 'true'
        if finishingPreset:
            # assign the finishig tool preset
            input.toolPreset = finishingPreset
        # add the operation to the folder
        steepAndShallowOp = folder.operations.add(input)
        # check if this toolpath is generatable ("steep_and_shallow" required the manufacturing extension)
        isSteepAndShallowGeneratable = False
        for op in setup.operations.compatibleStrategies:
            if op.name == 'steep_and_shallow':
                if op.isGenerationAllowed:
                    # isGenerationAllowed will be false if the extension isn't active which prevent from generating the steep_and_shallow operation
                    isSteepAndShallowGeneratable = True
                break
        #################### generate operations ####################
        # list the valid operations to generate
        operations = adsk.core.ObjectCollection.create()
        operations.add(faceOp)
        operations.add(adaptiveOp)
        operations.add(parallelOp)
        if isSteepAndShallowGeneratable:
            operations.add(steepAndShallowOp)
        # create progress bar
        progressDialog = ui.createProgressDialog()
        progressDialog.isCancelButtonShown = False
        progressDialog.show('Generating operations...', '%p%', 0, 100)
        adsk.doEvents() # allow Fusion 360 to update so the progressDialog show up nicely
        # generate the valid operations
        gtf = cam.generateToolpath(operations)
        # wait for the generation to be finished and update progress bar
        while not gtf.isGenerationCompleted:
            # calculate progress and update progress bar
            total = gtf.numberOfOperations
            completed = gtf.numberOfCompleted
            progress = int(completed * 100 / total)
            progressDialog.progressValue = progress
            adsk.doEvents() # allow Fusion 360 to update so the screen doesn't freeze
        # generation done
        progressDialog.progressValue = 100
        progressDialog.hide()
            
        #################### ncProgram and post-processing ####################
        # get the post library from library manager
        postLibrary = libraryManager.postLibrary
        # query post library to get postprocessor list
        postQuery = postLibrary.createQuery(adsk.cam.LibraryLocations.Fusion360LibraryLocation)
        postQuery.vendor = "Autodesk"
        postQuery.capability = adsk.cam.PostCapabilities.Milling
        postConfigs = postQuery.execute()
        # find the "XYZ" post in the post library and import it to local library
        for config in postConfigs:
            if config.description == 'XYZ':
                url = adsk.core.URL.create("user://")
                importedURL = postLibrary.importPostConfiguration(config, url, "NCProgramSamplePost.cps")
        # get the imported local post config
        postConfig = postLibrary.postConfigurationAtURL(importedURL)
       
        # create NCProgramInput object
        ncInput = cam.ncPrograms.createInput()
        ncInput.displayName = 'NC Program Sample'
        # change some nc program parameters...
        ncParameters = ncInput.parameters
        ncParameters.itemByName('nc_program_filename').value.value = 'NCProgramSample'
        ncParameters.itemByName('nc_program_openInEditor').value.value = True
        # set user desktop as output directory (Windows and Mac)
        # make the path valid for Fusion360 by replacing \\ to / in the path
        desktopDirectory = os.path.expanduser("~/Desktop").replace('\\', '/') 
        ncParameters.itemByName('nc_program_output_folder').value.value = desktopDirectory
        
        # select the operations to generate (we skip steep_and_shallow here)
        ncInput.operations = [faceOp, adaptiveOp, parallelOp]        # add a new ncprogram from the ncprogram input
        newProgram = cam.ncPrograms.add(ncInput)
        # set post processor
        newProgram.postConfiguration = postConfig
        # change some post parameter
        postParameters = newProgram.postParameters
        postParameters.itemByName('builtin_tolerance').value.value = 0.01  # NcProgram parameters is pass as it is to the postprocessor (it has no units)
        postParameters.itemByName('builtin_minimumChordLength').value.value = 0.33  # NcProgram parameters is pass as it is to the postprocessor (it has no units)
        # update/apply post parameters
        newProgram.updatePostParameters(postParameters)
        # set post options, by default post process only valid operations containing toolpath data
        postOptions = adsk.cam.NCProgramPostProcessOptions.create()
        # postOptions.PostProcessExecutionBehaviors = adsk.cam.PostProcessExecutionBehaviors.PostProcessExecutionBehavior_PostAll
        # post-process
        newProgram.postProcess(postOptions)
        
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
#################### Some functions to make our life easier ####################
def getLibrariesURLs(libraries: adsk.cam.ToolLibraries, url: adsk.core.URL):
    ''' Return the list of libraries URL in the specified library '''
    urls: list[str] = []
    libs = libraries.childAssetURLs(url)
    for lib in libs:
        urls.append(lib.toString())
    for folder in libraries.childFolderURLs(url):
        urls = urls + getLibrariesURLs(libraries, folder)
    return urls
def getToolsFromLibraryByTypeDiameterRangeAndMinFluteLength(toolLibrary: adsk.cam.ToolLibrary, tooltype: str, minDiameter: float, maxDiameter: float, minimumFluteLength: f
    ''' Return a list of tools that fits the search '''
    query = toolLibrary.createQuery()
    # set the search critera
    query.criteria.add('tool_type', adsk.core.ValueInput.createByString(tooltype))
    query.criteria.add('tool_diameter.min', adsk.core.ValueInput.createByReal(minDiameter))
    query.criteria.add('tool_diameter.max', adsk.core.ValueInput.createByReal(maxDiameter))
    if minimumFluteLength:
        query.criteria.add('tool_fluteLength.min', adsk.core.ValueInput.createByReal(minimumFluteLength))
    # get query results
    results = query.execute()
    # get the tools from the query
    tools: list[adsk.cam.Tool] = []
    for result in results:
        # a result has a tool, url, toollibrary and the index of the tool in that library: we just return the tool here
        tools.append(result.tool)
    return tools
#################### CAD creation ####################
def createSamplePart(design: adsk.fusion.Design) -> adsk.fusion.BRepBody:
    """ Creates the sample part for this script """
    box = createBox(design, 22, 15, 5)
    sphere = createSphere(design, adsk.core.Vector3D.create(0, 0, 10), 7.5)
    part = getBodyFromBooleanOperation(design, box, sphere)
    return part
def createBox(design: adsk.fusion.Design, sizeX: float, sizeY: float, sizeZ: float) -> adsk.fusion.BRepBody:
    ''' Creates a sample box'''
    component = design.rootComponent
    # Create sketch
    sketches = component.sketches
    sketch: adsk.fusion.Sketch = sketches.add(component.xYConstructionPlane)
    lines = sketch.sketchCurves.sketchLines
    recLines = lines.addTwoPointRectangle(adsk.core.Point3D.create(-sizeX / 2, -sizeY / 2, 0), adsk.core.Point3D.create(sizeX / 2, sizeY / 2, 0))
    prof = sketch.profiles.item(0)
    extrudes = component.features.extrudeFeatures
    distance = adsk.core.ValueInput.createByReal(sizeZ)
    ext = extrudes.addSimple(prof, distance, adsk.fusion.FeatureOperations.NewBodyFeatureOperation)
    return ext.bodies.item(0)
def createSphere(design: adsk.fusion.Design, origin: adsk.core.Vector3D, radius: float) -> adsk.fusion.BRepBody:
    ''' Creates a sample sphere '''
    component = design.rootComponent
    # Create a new sketch on the xy plane.
    sketches = component.sketches
    xyPlane = component.xYConstructionPlane
    sketch: adsk.fusion.Sketch = sketches.add(xyPlane)
    # Draw a circle.
    circles = sketch.sketchCurves.sketchCircles
    circle = circles.addByCenterRadius(adsk.core.Point3D.create(0, 0, 0), radius)
    # Draw a line to use as the axis of revolution.
    lines = sketch.sketchCurves.sketchLines
    axisLine = lines.addByTwoPoints(adsk.core.Point3D.create(-radius, 0, 0), adsk.core.Point3D.create(radius, 0, 0))
    # Get the profile defined by half of the circle.
    prof = sketch.profiles.item(0)
    # Create an revolution input to be able to define the input needed for a revolution
    # while specifying the profile and that a new component is to be created
    revolves = component.features.revolveFeatures
    revInput = revolves.createInput(prof, axisLine, adsk.fusion.FeatureOperations.NewComponentFeatureOperation)
    # Define that the extent is an angle of 2*pi to get a sphere
    angle = adsk.core.ValueInput.createByReal(2*math.pi)    revInput.setAngleExtent(False, angle)
    # Create the extrusion.
    ext = revolves.add(revInput)
    # Get the root component
    rootComp = design.rootComponent
    # Get the first Occurrence
    occs = rootComp.occurrences
    occ: adsk.fusion.Occurrence = occs.item(0)
    mat: adsk.core.Matrix3D = occ.transform
    # Matrix translation
    mat.translation = origin
    # set transform
    occ.transform = mat
    # snapshot - Determining the position is important!!!
    design.snapshots.add()
    body = ext.bodies.item(0)
    return body 
def getBodyFromBooleanOperation(design: adsk.fusion.Design, body1: adsk.fusion.BRepBody, body2: adsk.fusion.BRepBody) -> adsk.fusion.BRepBody:
    """ Creates a boolean operation between two bodies """
    model = design.activeComponent
    features = model.features
    bodyCollection = adsk.core.ObjectCollection.create()
    bodyCollection.add(body2)
    combineFeatures = features.combineFeatures
    combineFeatureInput = combineFeatures.createInput(body1, bodyCollection)
    combineFeatureInput.operation = 1
    combineFeatureInput.isKeepToolBodies = False
    combineFeatureInput.isNewComponent = False
    returnValue = combineFeatures.add(combineFeatureInput)
    part = returnValue.bodies[0]
    return part
New CAM Operation API Sample
Description
Demonstrates adding a new toolpath into the document using an existing CAM template. You can get a sample template here. To use the sample, create a new design and add a block.
Switch to the MANUF ACTURE workspace and create a setup. Run the script and it will create a new facing operation in the setup.
Code Samples
C++
Python
--

Copy Code
# For this sample script to run, the active Fusion document must contain at least one CAM operation.
import adsk.core, adsk.fusion, adsk.cam, traceback, os
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        doc = app.activeDocument
        products = doc.products
        product = products.itemByProductType('CAMProductType')
        # check if the document has a CAMProductType.  I will not if there are no CAM operations in it.
        if product == None:
            ui.messageBox('There are no CAM operations in the active document.  This script requires the active document to contain at least one CAM operation.',
                            'No CAM Operations Exist',
                            adsk.core.MessageBoxButtonTypes.OKButtonType,
                            adsk.core.MessageBoxIconTypes.CriticalIconType)
            return
        cam = adsk.cam.CAM.cast(product)
        # specify the program name, post configuration to use and a folder destination for the nc file
        programName = '101'
        outputFolder = cam.temporaryFolder
        # set the post configuration to use based on Operation Type of the first Setup
        firstSetupOperationType = cam.setups.item(0).operationType
        if firstSetupOperationType == adsk.cam.OperationTypes.MillingOperation:
            postConfig = os.path.join(cam.genericPostFolder, 'fanuc.cps') 
        elif firstSetupOperationType == adsk.cam.OperationTypes.TurningOperation:
            postConfig = os.path.join(cam.genericPostFolder, 'fanuc turning.cps') 
        elif firstSetupOperationType == adsk.cam.OperationTypes.JetOperation:
            postConfig = cam.genericPostFolder + '/' + 'omax.cps' 
        # prompt the user with an option to view the resulting NC file.
        viewResults = ui.messageBox('View results when post is complete?', 'Post NC Files',
                                    adsk.core.MessageBoxButtonTypes.YesNoButtonType,
                                    adsk.core.MessageBoxIconTypes.QuestionIconType)
        if viewResults == adsk.core.DialogResults.DialogNo:
            viewResult = False
        else:
            viewResult = True
        # specify the NC file output units
        units = adsk.cam.PostOutputUnitOptions.DocumentUnitsOutput
#        units = adsk.cam.PostOutputUnitOptions.InchesOutput
#        units = adsk.cam.PostOutputUnitOptions.MillimetersOutput
        # create the postInput object
        postInput = adsk.cam.PostProcessInput.create(programName, postConfig, outputFolder, units)
        postInput.isOpenInEditor = viewResult
        # create the post properties
        postProperties = adsk.core.NamedValues.create()
        # create the disable sequence number property
        disableSequenceNumbers = adsk.core.ValueInput.createByBoolean(False)
        postProperties.add("showSequenceNumbers", disableSequenceNumbers)
        # add the post properties to the post process input
        postInput.postProperties = postProperties
        # set the value of scenario to 1, 2 or 3 to post all, post the first setup, or post only the first operation of the first setup.
        scenario = 3
        if scenario == 1:
            ui.messageBox('All toolpaths will be posted')
            cam.postProcessAll(postInput)
        elif scenario == 2:
            ui.messageBox('Toolpaths in the first Setup will be posted')
            setups = cam.setups
            setup = setups.item(0)
            cam.postProcess(setup, postInput)
        elif scenario == 3:
            ui.messageBox('The first Toolpath in the first Setup will be posted')            setups = cam.setups
            setup = setups.item(0)
            operations = setup.allOperations
            operation = operations.item(0)
            if operation.hasToolpath == True:
                cam.postProcess(operation, postInput)
            else:
                ui.messageBox('Operation has no toolpath to post')
                return
        ui.messageBox('Post processing is complete. The results have been written to:\n"' + os.path.join(outputFolder, programName) + '.nc"') 
        # open the output folder in Finder on Mac or in Explorer on Windows
        if (os.name == 'posix'):
            os.system('open "%s"' % outputFolder)
        elif (os.name == 'nt'):
            os.startfile(outputFolder)
        # Prompt user with an option to switch to the CAM workspace if it's not already active
        if ui.activeWorkspace.name != 'CAM':
            activateCAMWorkspace = ui.messageBox('Activate the CAM Workspace?','CAM Workspace Activate',
                                                 adsk.core.MessageBoxButtonTypes.YesNoButtonType,
                                                 adsk.core.MessageBoxIconTypes.QuestionIconType)
            if activateCAMWorkspace == adsk.core.DialogResults.DialogYes:
                camWorkspace = ui.workspaces.itemById("CAMEnvironment")
                camWorkspace.activate()
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))
Wood Routing Workflow Sample
Description
This script demonstrates routing wood panels.
When running the sample, it assumes you have an open design containing one or more "panels" oriented flat in the X-Y  plane. The script creates a setup and a 2D contour operation with
tabs to route the panels from a standard sheet.
Code Samples
Python
--
#Assumes a model is loaded in Fusion, eg a couple of flat panels 
import adsk.core, adsk.fusion, adsk.cam, traceback
def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui  = app.userInterface
        
        # use existing doc:
        doc = app.activeDocument
        # switch to manufacturing space
        camWS = ui.workspaces.itemById('CAMEnvironment') 
        camWS.activate()
        # get the CAM product
        products = doc.products
        #################### Search a tool in our tool library ####################
        # get the tool libraries from the library manager
        camManager = adsk.cam.CAMManager.get()
        libraryManager = camManager.libraryManager
        toolLibraries = libraryManager.toolLibraries
        # we can use a library URl directly if we know its address (using Fusion metric sample lib)
        url = adsk.core.URL.create('systemlibraryroot://Samples/Milling Tools (Metric).json')
        
        # load tool library
        toolLibrary = toolLibraries.toolLibraryAtURL(url)
        MyTool = None  
        # search an end mill for the contour operation
        for tool in toolLibrary:
            # read the tool type
            toolType = tool.parameters.itemByName('tool_type').value.value 
 
            # compare toolType and filter on 'flat end mill'
            if toolType == 'flat end mill' and not MyTool:
                # search for tool diameter larger or equal to 10mm but less than 12mm
                diameter = tool.parameters.itemByName('tool_diameter').value.value
                if diameter >= 1.0 and diameter < 1.2: 
                    MyTool = tool
                    break
        #################### create setup ####################
        cam = adsk.cam.CAM.cast(products.itemByProductType("CAMProductType"))
        setups = cam.setups
        setupInput = setups.createInput(adsk.cam.OperationTypes.MillingOperation)        # create a list for the models to add to the setup Input
        models = [] 
          
        # loop across all bRep bodies and add them all to our model list
        countParts = cam.designRootOccurrence.bRepBodies.count
        i = 0
        while i < countParts:
            part = cam.designRootOccurrence.bRepBodies.item(i)
            models.append(part)
            i = i + 1
            
        # pass the model list to the setup input
        setupInput.models = models 
        # create the setup
        setup = setups.add(setupInput) 
        # change some properties of the setup & stock
        setup.name = 'CAM Woodworking Script Sample'  
        setup.stockMode = adsk.cam.SetupStockModes.FixedBoxStock
        # set setup origin in the corner
        setup.parameters.itemByName('wcs_origin_boxPoint').value.value = 'top 1'
        # set stock size XYZ
        setup.parameters.itemByName('job_stockFixedX').expression = '2440 mm'
        setup.parameters.itemByName('job_stockFixedY').expression = '1220 mm'
        setup.parameters.itemByName('job_stockFixedZ').expression = '18 mm'
        #################### 2D contour operation ####################
        # set operation properties
        input = setup.operations.createInput('contour2d')
        input.tool = MyTool
        input.displayName = '2D Contour'
        input.parameters.itemByName('tolerance').expression = '0.1 mm' 
        
        # add tabs
        # activate tabs group to enable tabs and be able to modify its parameters
        input.parameters.itemByName('group_tabs').expression = 'true'
        input.parameters.itemByName('tabWidth').expression = '18 mm'
        input.parameters.itemByName('tabHeight').expression = '18 mm'
        input.parameters.itemByName('tabDistance').expression = '100 mm'
        # add the operation to the setup
        contourOp = setup.operations.add(input)
        
        # add silhouette to contour selection for 2D contour operation
        # requires the operation to exist
        cadcontours2dParam: adsk.cam.CadContours2dParameterValue = contourOp.parameters.itemByName('contours').value
        chains = cadcontours2dParam.getCurveSelections()
        # calculate and add a new silhouette curve to the geometry selection list
        chains.createNewSilhouetteSelection()
        cadcontours2dParam.applyCurveSelections(chains)
        # calculate operation
        cam.generateToolpath(contourOp)
        #################### post process ####################
        # copy-paste from basic milling sample
    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))